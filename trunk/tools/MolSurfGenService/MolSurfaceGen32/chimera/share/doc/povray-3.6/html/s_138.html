
<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2003-2004  -->
<html> 
<head>
  
<!--  NOTE: In order to users to help find information about POV-Ray using  -->
 
<!--  web search engines, we ask you to *not* let them index documentation  -->
 
<!--  mirrors because effectively, when searching, users will get hundreds  -->
 
<!--  of results containing the same information! For this reason, the two  -->
 
<!--  meta tags below disable archiving and indexing of this page by all  -->
 
<!--  search engines that support these meta tags.  -->
 
 <meta content="noarchive" name="robots">
   
 <meta content="noindex" name="robots">
   
 <meta content="no-cache" http-equiv="Pragma">
   
 <meta content="0" http-equiv="expires">
   
<title>3.7.7 functions.inc</title>
 <link href="povray35.css" rel="stylesheet" type="text/css"> 
</head>
 <body> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_137.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_137.html">3.7.6 finish.inc</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong class="NavBar">POV-Ray 3.6 for UNIX documentation</strong><br> <strong>3.7.7 
   functions.inc</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_139.html">3.7.8 glass.inc, glass_old.inc</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_139.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 
<h3><a name="s03_07_07">3.7.7 </a>functions.inc</h3>
<a name="s03_07_07_i1">
<p>
  This include file contains interfaces to internal functions as well as several predefined functions. The ID's used 
 to access the internal functions through calls to &quot;internal(XX)&quot;, are not guaranteed to stay the same 
 between POV-Ray versions, so users are encouraged to use the functions declared here. 
</p>

<p>
  The number of required parameters and what they control are also given in the include file, this chapter gives more 
 information. <br>For starter values of the parameters, check the &quot;i_internal.pov&quot; demo file. 
</p>

<p>
  Syntax to be used: 
</p>

<pre>  #include &quot;functions.inc&quot;
  isosurface {
    function { f_torus_gumdrop(x,y,z, P0) }
    ...
  }

  pigment {
    function { f_cross_ellipsoids(x,y,z, P0, P1, P2, P3) }
    COLOR_MAP ...
  )
</pre>

<p>
  Some special parameters are found in several of these functions. These are described in the next section and later 
 referred to as &quot;Cross section type&quot;, &quot;Field Strength&quot;, &quot;Field Limit&quot;, &quot;SOR&quot; 
 parameters. 
</p>

<h4><a name="s03_07_07_01">3.7.7.1 </a>Common Parameters</h4>

<p>
  <strong>Cross Section Type:</strong><a name="s03_07_07_01_i1"><a name="Cross Section Type"></a> <br>In the helixes 
 and spiral functions, the 9th parameter is the cross section type. <br>Some shapes are: 
</p>

<dl>
 
 <dt>
   <code>0</code> : 
 <dd>
   square 
 <dt>
   <code>0.0 to 1.0</code> : 
 <dd>
   rounded squares 
 <dt>
   <code>1</code> : 
 <dd>
   circle 
 <dt>
   <code>1.0 to 2.0</code> : 
 <dd>
   rounded diamonds 
 <dt>
   <code>2</code> : 
 <dd>
   diamond 
 <dt>
   <code>2.0 to 3.0</code> : 
 <dd>
   partially concave diamonds 
 <dt>
   <code>3</code> : 
 <dd>
   concave diamond 
</dl>

<h5><a name="s03_07_07_01_01">3.7.7.1.1 </a>Field Strength</h5>

<p>
  The numerical value at a point in space generated by the function is multiplied by the Field Strength. The set of 
 points where the function evaluates to zero are unaffected by any positive value of this parameter, so if you are just 
 using the function on its own with threshold = 0, the generated surface is still the same. <br>In some cases, the 
 field strength has a considerable effect on the speed and accuracy of rendering the surface. In general, increasing 
 the field strength speeds up the rendering, but if you set the value too high the surface starts to break up and may 
 disappear completely. <br>Setting the field strength to a negative value produces the inverse of the surface, like 
 making the function negative. 
</p>

<h5><a name="s03_07_07_01_02">3.7.7.1.2 </a>Field Limit</h5>

<p>
  This will not make any difference to the generated surface if you are using threshold that is within the field 
 limit (and will kill the surface completely if the threshold is greater than the field limit). However, it may make a 
 huge difference to the rendering times. <br>If you use the function to generate a pigment, then all points that are a 
 long way from the surface will have the same color, the color that corresponds to the numerical value of the field 
 limit. 
</p>

<h5><a name="s03_07_07_01_03">3.7.7.1.3 </a>SOR Switch</h5>

<p>
  If greater than zero, the curve is swept out as a surface of revolution (SOR). <br>If the value is zero or 
 negative, the curve is extruded linearly in the Z direction.<br> 
</p>

<h5><a name="s03_07_07_01_04">3.7.7.1.4 </a>SOR Offset</h5>

<p>
  If the SOR switch is on, then the curve is shifted this distance in the X direction before being swept out. 
</p>

<h5><a name="s03_07_07_01_05">3.7.7.1.5 </a>SOR Angle</h5>

<p>
  If the SOR switch is on, then the curve is rotated this number of degrees about the Z axis before being swept out. 
</p>

<h5><a name="s03_07_07_01_06">3.7.7.1.6 </a>Invert Isosurface</h5>

<p>
  Sometimes, when you render a surface, you may find that you get only the shape of the container. This could be 
 caused by the fact that some of the build in functions are defined inside out. <br>We can invert the isosurface by 
 negating the whole function: <br><code>&nbsp;&nbsp;-(function) - threshold</code> 
</p>

<h4><a name="s03_07_07_02">3.7.7.2 </a>Internal Functions</h4>

<p>
  Here is a list of the internal functions in the order they appear in the &quot;functions.inc&quot; include file<a name="s03_07_07_02_i1"><a name="f_algbr_cyl1"></a> 
 
</p>

<p>
  <code>f_algbr_cyl1(x,y,z, P0, P1, P2, P3, P4)</code>. An algebraic cylinder is what you get if you take any 2d 
 curve and plot it in 3d. The 2d curve is simply extruded along the third axis, in this case the z axis. <br>With the 
 SOR Switch switched on, the figure-of-eight curve will be rotated around the Y axis instead of being extruded along 
 the Z axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> 
 </li>

 <li>
   <code>P1</code> : <a href="s_138.html#s03_07_07_01_02">Field Limit</a> 
 </li>

 <li>
   <code>P2</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i2"><a name="f_algbr_cyl2"></a>
<p>
  <code>f_algbr_cyl2(x,y,z, P0, P1, P2, P3, P4)</code>. An algebraic cylinder is what you get if you take any 2d 
 curve and plot it in 3d. The 2d curve is simply extruded along the third axis, in this case the z axis. <br>With the 
 SOR Switch switched on, the cross section curve will be rotated around the Y axis instead of being extruded along the 
 Z axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : <a href="s_138.html#s03_07_07_01_02">Field Limit</a> 
 </li>

 <li>
   <code>P2</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i3"><a name="f_algbr_cyl3"></a>
<p>
  <code>f_algbr_cyl3(x,y,z, P0, P1, P2, P3, P4)</code>. An algebraic cylinder is what you get if you take any 2d 
 curve and plot it in 3d. The 2d curve is simply extruded along the third axis, in this case the Z axis. <br>With the 
 SOR Switch switched on, the cross section curve will be rotated around the Y axis instead of being extruded along the 
 Z axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : <a href="s_138.html#s03_07_07_01_02">Field Limit</a> 
 </li>

 <li>
   <code>P2</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i4"><a name="f_algbr_cyl4"></a>
<p>
  <code>f_algbr_cyl4(x,y,z, P0, P1, P2, P3, P4)</code>. An algebraic cylinder is what you get if you take any 2d 
 curve and plot it in 3d. The 2d curve is simply extruded along the third axis, in this case the z axis. <br>With the 
 SOR Switch switched on, the cross section curve will be rotated around the Y axis instead of being extruded along the 
 Z axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : <a href="s_138.html#s03_07_07_01_02">Field Limit</a> 
 </li>

 <li>
   <code>P2</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i5"><a name="f_bicorn"></a>
<p>
  <code>f_bicorn(x,y,z, P0, P1)</code>. The surface is a surface of revolution. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Scale. The mathematics of this surface suggest that the shape should be different for different 
  values of this parameter. In practice the difference in shape is hard to spot. Setting the scale to 3 gives a surface 
  with a radius of about 1 unit 
 </li>

</ul>
<a name="s03_07_07_02_i6"><a name="f_bifolia"></a>
<p>
  <code>f_bifolia(x,y,z, P0, P1)</code>. The bifolia surface looks something like the top part of a a paraboloid 
 bounded below by another paraboloid. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Scale. The surface is always the same shape. Changing this parameter has the same effect as 
  adding a scale modifier. Setting the scale to 1 gives a surface with a radius of about 1 unit 
 </li>

</ul>
<a name="s03_07_07_02_i7"><a name="f_blob"></a>
<p>
  <code>f_blob(x,y,z, P0, P1, P2, P3, P4)</code>. This function generates blobs that are similar to a CSG blob with 
 two spherical components. This function only seems to work with negative threshold settings. 
</p>

<ul>
 
 <li>
   <code>P0</code> : X distance between the two components 
 </li>

 <li>
   <code>P1</code> : Blob strength of component 1 
 </li>

 <li>
   <code>P2</code> : Inverse blob radius of component 1 
 </li>

 <li>
   <code>P3</code> : Blob strength of component 2 
 </li>

 <li>
   <code>P4</code> : Inverse blob radius of component 2 
 </li>

</ul>
<a name="s03_07_07_02_i8"><a name="f_blob2"></a>
<p>
  <code>f_blob2(x,y,z, P0, P1, P2, P3)</code>. The surface is similar to a CSG blob with two spherical components. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Separation. One blob component is at the origin, and the other is this distance away on the X 
  axis 
 </li>

 <li>
   <code>P1</code> : Inverse size. Increase this to decrease the size of the surface 
 </li>

 <li>
   <code>P2</code> : Blob strength 
 </li>

 <li>
   <code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the same effect as 
  setting this parameter to zero and the threshold to -1 
 </li>

</ul>
<a name="s03_07_07_02_i9"><a name="f_boy_surface"></a>
<p>
  <code>f_boy_surface(x,y,z, P0, P1)</code>. For this surface, it helps if the field strength is set low, otherwise 
 the surface has a tendency to break up or disappear entirely. This has the side effect of making the rendering times 
 extremely long. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Scale. The surface is always the same shape. Changing this parameter has the same effect as 
  adding a scale modifier 
 </li>

</ul>
<a name="s03_07_07_02_i10"><a name="f_comma"></a>
<p>
  <code>f_comma(x,y,z, P0)</code>. The 'comma' surface is very much like a comma-shape. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Scale 
 </li>

</ul>
<a name="s03_07_07_02_i11"><a name="f_cross_ellipsoids"></a>
<p>
  <code>f_cross_ellipsoids(x,y,z, P0, P1, P2, P3)</code>. The 'cross ellipsoids' surface is like the union of three 
 crossed ellipsoids, one oriented along each axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Eccentricity. When less than 1, the ellipsoids are oblate, when greater than 1 the ellipsoids 
  are prolate, when zero the ellipsoids are spherical (and hence the whole surface is a sphere) 
 </li>

 <li>
   <code>P1</code> : Inverse size. Increase this to decrease the size of the surface 
 </li>

 <li>
   <code>P2</code> : Diameter. Increase this to increase the size of the ellipsoids 
 </li>

 <li>
   <code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the same effect as 
  setting this parameter to zero and the threshold to -1 
 </li>

</ul>
<a name="s03_07_07_02_i12"><a name="f_crossed_trough"></a>
<p>
  <code>f_crossed_trough(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i13"><a name="f_cubic_saddle"></a>
<p>
  <code>f_cubic_saddle(x,y,z, P0)</code>. For this surface, it helps if the field strength is set quite low, 
 otherwise the surface has a tendency to break up or disappear entirely. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i14"><a name="f_cushion"></a>
<p>
  <code>f_cushion(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i15"><a name="f_devils_curve"></a>
<p>
  <code>f_devils_curve(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Field Strength (Needs a negative field strength or a negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i16"><a name="f_devils_curve_2d"></a>
<p>
  <code>f_devils_curve_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The <code>f_devils_curve_2d</code> curve can be 
 extruded along the z axis, or using the SOR parameters it can be made into a surface of revolution. The X and Y 
 factors control the size of the central feature. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : X factor 
 </li>

 <li>
   <code>P2</code> : Y factor 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i17"><a name="f_dupin_cyclid"></a>
<p>
  <code>f_dupin_cyclid(x,y,z, P0, P1, P2, P3, P4, P5)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Major radius of torus 
 </li>

 <li>
   <code>P2</code> : Minor radius of torus 
 </li>

 <li>
   <code>P3</code> : X displacement of torus 
 </li>

 <li>
   <code>P4</code> : Y displacement of torus 
 </li>

 <li>
   <code>P5</code> : Radius of inversion 
 </li>

</ul>
<a name="s03_07_07_02_i18"><a name="f_ellipsoid"></a>
<p>
  <code>f_ellipsoid(x,y,z, P0, P1, P2)</code>. <code>f_ellipsoid</code> generates spheres and ellipsoids. Needs 
 &quot;threshold 1&quot;.<br>Setting these scaling parameters to 1/n gives exactly the same effect as performing a 
 scale operation to increase the scaling by n in the corresponding direction. 
</p>

<ul>
 
 <li>
   <code>P0</code> : X scale (inverse) 
 </li>

 <li>
   <code>P1</code> : Y scale (inverse) 
 </li>

 <li>
   <code>P2</code> : Z scale (inverse) 
 </li>

</ul>
<a name="s03_07_07_02_i19"><a name="f_enneper"></a>
<p>
  <code>f_enneper(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i20"><a name="f_flange_cover"></a>
<p>
  <code>f_flange_cover(x,y,z, P0, P1, P2, P3)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Spikiness. Set this to very low values to increase the spikes. Set it to 1 and you get a sphere 
 </li>

 <li>
   <code>P1</code> : Inverse size. Increase this to decrease the size of the surface. (The other parameters also 
  drastically affect the size, but this parameter has no other effects) 
 </li>

 <li>
   <code>P2</code> : Flange. Increase this to increase the flanges that appear between the spikes. Set it to 1 for 
  no flanges 
 </li>

 <li>
   <code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the same effect as 
  setting this parameter to zero and the threshold to -1 
 </li>

</ul>
<a name="s03_07_07_02_i21"><a name="f_folium_surface"></a>
<p>
  <code>f_folium_surface(x,y,z, P0, P1, P2)</code>. A 'folium surface' looks something like a paraboloid glued to a 
 plane. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Neck width factor - the larger you set this, the narrower the neck where the paraboloid meets 
  the plane 
 </li>

 <li>
   <code>P2</code> : Divergence - the higher you set this value, the wider the paraboloid gets 
 </li>

</ul>
<a name="s03_07_07_02_i22"><a name="f_folium_surface_2d"></a>
<p>
  <code>f_folium_surface_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The <code>f_folium_surface_2d</code> curve can be 
 rotated around the X axis to generate the same 3d surface as the <code>f_folium_surface</code>, or it can be extruded 
 in the Z direction (by switching the SOR switch off) 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Neck width factor - same as the 3d surface if you are revolving it around the Y axis 
 </li>

 <li>
   <code>P2</code> : Divergence - same as the 3d surface if you are revolving it around the Y axis 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i23"><a name="f_glob"></a>
<p>
  <code>f_glob(x,y,z, P0)</code>. One part of this surface would actually go off to infinity if it were not 
 restricted by the contained_by shape. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i24"><a name="f_heart"></a>
<p>
  <code>f_heart(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i25"><a name="f_helical_torus"></a>
<p>
  <code>f_helical_torus(x,y,z, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)</code>. With some sets of parameters, it looks 
 like a torus with a helical winding around it. The winding optionally has grooves around the outside. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Major radius 
 </li>

 <li>
   <code>P1</code> : Number of winding loops 
 </li>

 <li>
   <code>P2</code> : Twistiness of winding. When zero, each winding loop is separate. When set to one, each loop 
  twists into the next one. When set to two, each loop twists into the one after next 
 </li>

 <li>
   <code>P3</code> : Fatness of winding? 
 </li>

 <li>
   <code>P4</code> : Threshold. Setting this parameter to 1 and the threshold to zero has s similar effect as 
  setting this parameter to zero and the threshold to 1 
 </li>

 <li>
   <code>P5</code> : Negative minor radius? Reducing this parameter increases the minor radius of the central torus. 
  Increasing it can make the torus disappear and be replaced by a vertical column. The value at which the surface 
  switches from one form to the other depends on several other parameters 
 </li>

 <li>
   <code>P6</code> : Another fatness of winding control? 
 </li>

 <li>
   <code>P7</code> : Groove period. Increase this for more grooves 
 </li>

 <li>
   <code>P8</code> : Groove amplitude. Increase this for deeper grooves 
 </li>

 <li>
   <code>P9</code> : Groove phase. Set this to zero for symmetrical grooves 
 </li>

</ul>
<a name="s03_07_07_02_i26"><a name="f_helix1"></a>
<p>
  <code>f_helix1(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Number of helixes - e.g. 2 for a double helix 
 </li>

 <li>
   <code>P1</code> : Period - is related to the number of turns per unit length 
 </li>

 <li>
   <code>P2</code> : Minor radius (major radius &gt; minor radius) 
 </li>

 <li>
   <code>P3</code> : Major radius 
 </li>

 <li>
   <code>P4</code> : Shape parameter. If this is greater than 1 then the tube becomes fatter in the y direction 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01">Cross section type</a> 
 </li>

 <li>
   <code>P6</code> : Cross section rotation angle (degrees) 
 </li>

</ul>
<a name="s03_07_07_02_i27"><a name="f_helix2"></a>
<p>
  <code>f_helix2(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>. Needs a negated function 
</p>

<ul>
 
 <li>
   <code>P0</code> : Not used 
 </li>

 <li>
   <code>P1</code> : Period - is related to the number of turns per unit length 
 </li>

 <li>
   <code>P2</code> : Minor radius (minor radius &gt; major radius) 
 </li>

 <li>
   <code>P3</code> : Major radius 
 </li>

 <li>
   <code>P4</code> : Not used 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01">Cross section type</a> 
 </li>

 <li>
   <code>P6</code> : Cross section rotation angle (degrees) 
 </li>

</ul>
<a name="s03_07_07_02_i28"><a name="f_hex_x"></a>
<p>
  <code>f_hex_x(x,y,z, P0)</code>. This creates a grid of hexagonal cylinders stretching along the z-axis. The 
 fatness is controlled by the threshold value. When this value equals 0.8660254 or cos(30) the sides will touch, 
 because this is the distance between centers. Negating the function will inverse the surface and create a honey-comb 
 structure. This function is also useful as pigment function. 
</p>

<ul>
 
 <li>
   <code>P0</code> : No effect (but the syntax requires at least one parameter) 
 </li>

</ul>
<a name="s03_07_07_02_i29"><a name="f_hex_y"></a>
<p>
  <code>f_hex_y(x,y,z, P0)</code>. This is function forms a lattice of infinite boxes stretching along the z-axis. 
 The fatness is controlled by the threshold value. These boxes are rotated 60 degrees around centers, which are 
 0.8660254 or cos(30) away from each other. This function is also useful as pigment function. 
</p>

<ul>
 
 <li>
   <code>P0</code> : No effect (but the syntax requires at least one parameter) 
 </li>

</ul>
<a name="s03_07_07_02_i30"><a name="f_hetero_mf"></a>
<p>
  <code>f_hetero_mf(x,y,z, P0, P1, P2, P3, P4, P5)</code>. <code>f_hetero_mf (x,0,z)</code> makes multifractal height 
 fields and patterns of '1/f' noise <br>'Multifractal' refers to their characteristic of having a fractal dimension 
 which varies with altitude. Built from summing noise of a number of frequencies, the hetero_mf parameters determine 
 how many, and which frequencies are to be summed. <br>An advantage to using these instead of a height_field {} from an 
 image (a number of height field programs output multifractal types of images) is that the hetero_mf function domain 
 extends arbitrarily far in the x and z directions so huge landscapes can be made without losing resolution or having 
 to tile a height field. Other functions of interest are <code>f_ridged_mf</code> and <code>f_ridge</code>. 
</p>

<ul>
 
 <li>
   <code>P0</code> : H is the negative of the exponent of the basis noise frequencies used in building these 
  functions (each frequency f's amplitude is weighted by the factor f - H ). In landscapes, and many natural forms, the 
  amplitude of high frequency contributions are usually less than the lower frequencies. <br>When H is 1, the 
  fractalization is relatively smooth (&quot;1/f noise&quot;). <br>As H nears 0, the high frequencies contribute 
  equally with low frequencies as in &quot;white noise&quot;. 
 </li>

 <li>
   <code>P1</code> : Lacunarity' is the multiplier used to get from one 'octave' to the next. This parameter affects 
  the size of the frequency gaps in the pattern. Make this greater than 1.0 
 </li>

 <li>
   <code>P2</code> : Octaves is the number of different frequencies added to the fractal. Each 'Octave' frequency is 
  the previous one multiplied by 'Lacunarity', so that using a large number of octaves can get into very high 
  frequencies very quickly. 
 </li>

 <li>
   <code>P3</code> : Offset is the 'base altitude' (sea level) used for the heterogeneous scaling 
 </li>

 <li>
   <code>P4</code> : T scales the 'heterogeneity' of the fractal. T=0 gives 'straight 1/f' (no heterogeneous 
  scaling). T=1 suppresses higher frequencies at lower altitudes 
 </li>

 <li>
   <code>P5</code> : Generator type used to generate the noise3d. 0, 1, 2 and 3 are legal values. 
 </li>

</ul>
<a name="s03_07_07_02_i31"><a name="f_hunt_surface"></a>
<p>
  <code>f_hunt_surface(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i32"><a name="f_hyperbolic_torus"></a>
<p>
  <code>f_hyperbolic_torus(x,y,z, P0, P1, P2)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Major radius: separation between the centers of the tubes at the closest point 
 </li>

 <li>
   <code>P2</code> : Minor radius: thickness of the tubes at the closest point 
 </li>

</ul>
<a name="s03_07_07_02_i33"><a name="f_isect_ellipsoids"></a>
<p>
  <code>f_isect_ellipsoids(x,y,z, P0, P1, P2, P3)</code>. The 'isect ellipsoids' surface is like the intersection of 
 three crossed ellipsoids, one oriented along each axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Eccentricity. When less than 1, the ellipsoids are oblate, when greater than 1 the ellipsoids 
  are prolate, when zero the ellipsoids are spherical (and hence the whole surface is a sphere) 
 </li>

 <li>
   <code>P1</code> : Inverse size. Increase this to decrease the size of the surface 
 </li>

 <li>
   <code>P2</code> : Diameter. Increase this to increase the size of the ellipsoids 
 </li>

 <li>
   <code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the same effect as 
  setting this parameter to zero and the threshold to -1 
 </li>

</ul>
<a name="s03_07_07_02_i34"><a name="f_kampyle_of_eudoxus"></a>
<p>
  <code>f_kampyle_of_eudoxus(x,y,z, P0, P1, P2)</code>. The 'kampyle of eudoxus' is like two infinite planes with a 
 dimple at the center. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Dimple: When zero, the two dimples punch right through and meet at the center. Non-zero values 
  give less dimpling 
 </li>

 <li>
   <code>P2</code> : Closeness: Higher values make the two planes become closer 
 </li>

</ul>
<a name="s03_07_07_02_i35"><a name="f_kampyle_of_eudoxus_2d"></a>
<p>
  <code>f_kampyle_of_eudoxus_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>The 2d curve that generates the above surface 
 can be extruded in the Z direction or rotated about various axes by using the SOR parameters. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Dimple: When zero, the two dimples punch right through and meet at the center. Non-zero values 
  give less dimpling 
 </li>

 <li>
   <code>P2</code> : Closeness: Higher values make the two planes become closer 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i36"><a name="f_klein_bottle"></a>
<p>
  <code>f_klein_bottle(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i37"><a name="f_kummer_surface_v1"></a>
<p>
  <code>f_kummer_surface_v1(x,y,z, P0)</code>. The Kummer surface consists of a collection of radiating rods. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i38"><a name="f_kummer_surface_v2"></a>
<p>
  <code>f_kummer_surface_v2(x,y,z, P0, P1, P2, P3)</code>. Version 2 of the kummer surface only looks like radiating 
 rods when the parameters are set to particular negative values. For positive values it tends to look rather like a 
 superellipsoid. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Rod width (negative): Setting this parameter to larger negative values increases the diameter 
  of the rods 
 </li>

 <li>
   <code>P2</code> : Divergence (negative): Setting this number to -1 causes the rods to become approximately 
  cylindrical. Larger negative values cause the rods to become fatter further from the origin. Smaller negative numbers 
  cause the rods to become narrower away from the origin, and have a finite length 
 </li>

 <li>
   <code>P3</code> : Influences the length of half of the rods. Changing the sign affects the other half of the 
  rods. 0 has no effect 
 </li>

</ul>
<a name="s03_07_07_02_i39"><a name="f_lemniscate_of_gerono"></a>
<p>
  <code>f_lemniscate_of_gerono(x,y,z, P0)</code>. The &quot;Lemniscate of Gerono&quot; surface is an hourglass shape. 
 Two teardrops with their ends connected. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i40"><a name="f_lemniscate_of_gerono_2d"></a>
<p>
  <code>f_lemniscate_of_gerono_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The 2d version of the Lemniscate can be 
 extruded in the Z direction, or used as a surface of revolution to generate the equivalent of the 3d version, or 
 revolved in different ways. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Size: increasing this makes the 2d curve larger and less rounded 
 </li>

 <li>
   <code>P2</code> : Width: increasing this makes the 2d curve fatter 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i41"><a name="f_mesh1"></a>
<p>
  <code>f_mesh1(x,y,z, P0, P1, P2, P3, P4)</code> The overall thickness of the threads is controlled by the 
 isosurface threshold, not by a parameter. If you render a mesh1 with zero threshold, the threads have zero thickness 
 and are therefore invisible. Parameters P2 and P4 control the shape of the thread relative to this threshold 
 parameter. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Distance between neighboring threads in the x direction 
 </li>

 <li>
   <code>P1</code> : Distance between neighboring threads in the z direction 
 </li>

 <li>
   <code>P2</code> : Relative thickness in the x and z directions 
 </li>

 <li>
   <code>P3</code> : Amplitude of the weaving effect. Set to zero for a flat grid 
 </li>

 <li>
   <code>P4</code> : Relative thickness in the y direction 
 </li>

</ul>
<a name="s03_07_07_02_i42"><a name="f_mitre"></a>
<p>
  <code>f_mitre(x,y,z, P0)</code>. The 'Mitre' surface looks a bit like an ellipsoid which has been nipped at each 
 end with a pair of sharp nosed pliers. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i43"><a name="f_nodal_cubic"></a>
<p>
  <code>f_nodal_cubic(x,y,z, P0)</code>. The 'Nodal Cubic' is something like what you would get if you were to 
 extrude the Stophid2D curve along the X axis and then lean it over. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i44"><a name="f_noise3d"></a>
<p>
  <code>f_noise3d(x,y,z)</code><a name="s03_07_07_02_i45"><a name="f_noise_generator"></a> 
</p>

<p>
  <code>f_noise_generator(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Noise generator number 
 </li>

</ul>
<a name="s03_07_07_02_i46"><a name="f_odd"></a>
<p>
  <code>f_odd(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i47"><a name="f_ovals_of_cassini"></a>
<p>
  <code>f_ovals_of_cassini(x,y,z, P0, P1, P2, P3)</code>. The Ovals of Cassini are a generalization of the torus 
 shape. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Major radius - like the major radius of a torus 
 </li>

 <li>
   <code>P2</code> : Filling. Set this to zero, and you get a torus. Set this to a higher value and the hole in the 
  middle starts to heal up. Set it even higher and you get an ellipsoid with a dimple 
 </li>

 <li>
   <code>P3</code> : Thickness. The higher you set this value, the plumper is the result 
 </li>

</ul>
<a name="s03_07_07_02_i48"><a name="f_paraboloid"></a>
<p>
  <code>f_paraboloid(x,y,z, P0)</code>. This paraboloid is the surface of revolution that you get if you rotate a 
 parabola about the Y axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i49"><a name="f_parabolic_torus"></a>
<p>
  <code>f_parabolic_torus(x,y,z, P0, P1, P2)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Major radius 
 </li>

 <li>
   <code>P2</code> : Minor radius 
 </li>

</ul>
<a name="s03_07_07_02_i50"><a name="f_ph"></a>
<p>
  <code>f_ph(x,y,z)</code> = atan2( sqrt( x*x + z*z ), y ) <br>When used alone, the &quot;PH&quot; function gives a 
 surface that consists of all points that are at a particular latitude, i.e. a cone. If you use a threshold of zero 
 (the default) this gives a cone of width zero, which is invisible. Also look at <code>f_th</code> and <code>f_r</code> <a name="s03_07_07_02_i51"><a name="f_pillow"></a> 
 
</p>

<p>
  <code>f_pillow(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> 
 </li>

</ul>
<a name="s03_07_07_02_i52"><a name="f_piriform"></a>
<p>
  <code>f_piriform(x,y,z, P0)</code>. The piriform surface looks rather like half a lemniscate. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> 
 </li>

</ul>
<a name="s03_07_07_02_i53"><a name="f_piriform_2d"></a>
<p>
  <code>f_piriform_2d(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>. The 2d version of the &quot;Piriform&quot; can be 
 extruded in the Z direction, or used as a surface of revolution to generate the equivalent of the 3d version. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Size factor 1: increasing this makes the curve larger 
 </li>

 <li>
   <code>P2</code> : Size factor 2: making this less negative makes the curve larger but also thinner 
 </li>

 <li>
   <code>P3</code> : Fatness: increasing this makes the curve fatter 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P6</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i54"><a name="f_poly4"></a>
<p>
  <code>f_poly4(x,y,z, P0, P1, P2, P3, P4)</code>. This <code>f_poly4</code> can be used to generate the surface of 
 revolution of any polynomial up to degree 4.<br>To put it another way: If we call the parameters A, B, C, D, E; then 
 this function generates the surface of revolution formed by revolving &quot;x = A + By + Cy2 + Dy3 + Ey4&quot; around 
 the Y axis. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Constant 
 </li>

 <li>
   <code>P1</code> : Y coefficient 
 </li>

 <li>
   <code>P2</code> : Y2 coefficient 
 </li>

 <li>
   <code>P3</code> : Y3 coefficient 
 </li>

 <li>
   <code>P4</code> : Y4 coefficient 
 </li>

</ul>
<a name="s03_07_07_02_i55"><a name="f_polytubes"></a>
<p>
  <code>f_polytubes(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The 'Polytubes' surface consists of a number of tubes. 
 Each tube follows a 2d curve which is specified by a polynomial of degree 4 or less. If we look at the parameters, 
 then this function generates &quot;P0&quot; tubes which all follow the equation &quot; x = P1 + P2y + P3y2 + P4y3 + 
 P5y4 &quot; arranged around the Y axis. <br>This function needs a positive threshold (fatness of the tubes). 
</p>

<ul>
 
 <li>
   <code>P0</code> : Number of tubes 
 </li>

 <li>
   <code>P1</code> : Constant 
 </li>

 <li>
   <code>P2</code> : Y coefficient 
 </li>

 <li>
   <code>P3</code> : Y2 coefficient 
 </li>

 <li>
   <code>P4</code> : Y3 coefficient 
 </li>

 <li>
   <code>P5</code> : Y4 coefficient 
 </li>

</ul>
<a name="s03_07_07_02_i56"><a name="f_quantum"></a>
<p>
  <code>f_quantum(x,y,z, P0)</code>. It resembles the shape of the electron density cloud for one of the d orbitals. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Not used, but required 
 </li>

</ul>
<a name="s03_07_07_02_i57"><a name="f_quartic_paraboloid"></a>
<p>
  <code>f_quartic_paraboloid(x,y,z, P0)</code>. The 'Quartic Paraboloid' is similar to a paraboloid, but has a 
 squarer shape. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i58"><a name="f_quartic_saddle"></a>
<p>
  <code>f_quartic_saddle(x,y,z, P0)</code>. The 'Quartic saddle' is similar to a saddle, but has a squarer shape. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> 
 </li>

</ul>
<a name="s03_07_07_02_i59"><a name="f_quartic_cylinder"></a>
<p>
  <code>f_quartic_cylinder(x,y,z, P0, P1, P2)</code>. The 'Quartic cylinder' looks a bit like a cylinder that is 
 swallowed an egg. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Diameter of the &quot;egg&quot; 
 </li>

 <li>
   <code>P2</code> : Controls the width of the tube and the vertical scale of the &quot;egg&quot; 
 </li>

</ul>
<a name="s03_07_07_02_i60"><a name="f_r"></a>
<p>
  <code>f_r(x,y,z)</code> = sqrt( x*x + y*y + z*z ) <br>When used alone, the &quot;R&quot; function gives a surface 
 that consists of all the points that are a specific distance (threshold value) from the origin, i.e. a sphere. Also 
 look at <code>f_ph</code> and <code>f_th</code> <a name="s03_07_07_02_i61"><a name="f_ridge"></a> 
</p>

<p>
  <code>f_ridge(x,y,z, P0, P1, P2, P3, P4, P5)</code>. This function is mainly intended for modifying other surfaces 
 as you might use a height field or to use as pigment function. Other functions of interest are <code>f_hetero_mf</code> 
 and <code>f_ridged_mf</code>. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Lambda 
 </li>

 <li>
   <code>P1</code> : Octaves 
 </li>

 <li>
   <code>P2</code> : Omega 
 </li>

 <li>
   <code>P3</code> : Offset 
 </li>

 <li>
   <code>P4</code> : Ridge 
 </li>

 <li>
   <code>P5</code> : Generator type used to generate the noise3d. 0, 1, 2 and 3 are legal values. 
 </li>

</ul>
<a name="s03_07_07_02_i62"><a name="f_ridged_mf"></a>
<p>
  <code>f_ridged_mf(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The &quot;Ridged Multifractal&quot; surface can be used to 
 create multifractal height fields and patterns. 'Multifractal' refers to their characteristic of having a fractal 
 dimension which varies with altitude. They are built from summing noise of a number of frequencies. The f_ridged_mf 
 parameters determine how many, and which frequencies are to be summed, and how the different frequencies are weighted 
 in the sum. <br>An advantage to using these instead of a <code>height_field{}</code> from an image is that the 
 ridged_mf function domain extends arbitrarily far in the x and z directions so huge landscapes can be made without 
 losing resolution or having to tile a height field. Other functions of interest are <code>f_hetero_mf</code> and <code>f_ridge</code>. 
 
</p>

<ul>
 
 <li>
   <code>P0</code> : H is the negative of the exponent of the basis noise frequencies used in building these 
  functions (each frequency f's amplitude is weighted by the factor fE- H ). When H is 1, the fractalization is 
  relatively smooth. As H nears 0, the high frequencies contribute equally with low frequencies 
 </li>

 <li>
   <code>P1</code> : Lacunarity is the multiplier used to get from one &quot;octave&quot; to the next in the 
  &quot;fractalization&quot;. <br>This parameter affects the size of the frequency gaps in the pattern. (Use values 
  greater than 1.0) 
 </li>

 <li>
   <code>P2</code> : Octaves is the number of different frequencies added to the fractal. Each octave frequency is 
  the previous one multiplied by &quot;Lacunarity&quot;. So, using a large number of octaves can get into very high 
  frequencies very quickly 
 </li>

 <li>
   <code>P3</code> : Offset gives a fractal whose fractal dimension changes from altitude to altitude. The high 
  frequencies at low altitudes are more damped than at higher altitudes, so that lower altitudes are smoother than 
  higher areas 
 </li>

 <li>
   <code>P4</code> : Gain weights the successive contributions to the accumulated fractal result to make creases 
  stick up as ridges 
 </li>

 <li>
   <code>P5</code> : Generator type used to generate the noise3d. 0, 1, 2 and 3 are legal values. 
 </li>

</ul>
<a name="s03_07_07_02_i63"><a name="f_rounded_box"></a>
<p>
  <code>f_rounded_box(x,y,z, P0, P1, P2, P3)</code>. The Rounded Box is defined in a cube from &lt;-1, -1, -1&gt; to 
 &lt;1, 1, 1&gt;. By changing the &quot; Scale&quot; parameters, the size can be adjusted, without affecting the Radius 
 of curvature. 
</p>

<ul>
 
 <li>
   <code>P0</code> : Radius of curvature. Zero gives square corners, 0.1 gives corners that match &quot;sphere {0, 
  0.1}&quot; 
 </li>

 <li>
   <code>P1</code> : Scale x 
 </li>

 <li>
   <code>P2</code> : Scale y 
 </li>

 <li>
   <code>P3</code> : Scale z 
 </li>

</ul>
<a name="s03_07_07_02_i64"><a name="f_sphere"></a>
<p>
  <code>f_sphere(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code>: radius of the sphere 
 </li>

</ul>
<a name="s03_07_07_02_i65"><a name="f_spikes"></a>
<p>
  <code>f_spikes(x,y,z, P0, P1, P2, P3, P4)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Spikiness. Set this to very low values to increase the spikes. Set it to 1 and you get a sphere 
 </li>

 <li>
   <code>P1</code> : Hollowness. Increasing this causes the sides to bend in more 
 </li>

 <li>
   <code>P2</code> : Size. Increasing this increases the size of the object 
 </li>

 <li>
   <code>P3</code> : Roundness. This parameter has a subtle effect on the roundness of the spikes 
 </li>

 <li>
   <code>P4</code> : Fatness. Increasing this makes the spikes fatter 
 </li>

</ul>
<a name="s03_07_07_02_i66"><a name="f_spikes_2d"></a>
<p>
  <code>f_spikes_2d(x,y,z, P0, P1, P2, P3)</code> =2-D function : f = f( x, z ) - y 
</p>

<ul>
 
 <li>
   <code>P0</code> : Height of central spike 
 </li>

 <li>
   <code>P1</code> : Frequency of spikes in the X direction 
 </li>

 <li>
   <code>P2</code> : Frequency of spikes in the Z direction 
 </li>

 <li>
   <code>P3</code> : Rate at which the spikes reduce as you move away from the center 
 </li>

</ul>
<a name="s03_07_07_02_i67"><a name="f_spiral"></a>
<p>
  <code>f_spiral(x,y,z, P0, P1, P2, P3, P4, P5)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Distance between windings 
 </li>

 <li>
   <code>P1</code> : Thickness 
 </li>

 <li>
   <code>P2</code> : Outer diameter of the spiral. The surface behaves as if it is contained_by a sphere of this 
  diameter 
 </li>

 <li>
   <code>P3</code> : Not used 
 </li>

 <li>
   <code>P4</code> : Not used 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01">Cross section type</a> 
 </li>

</ul>
<a name="s03_07_07_02_i68"><a name="f_steiners_roman"></a>
<p>
  <code>f_steiners_roman(x,y,z, P0)</code>. The &quot;Steiners Roman&quot; is composed of four identical triangular 
 pads which together make up a sort of rounded tetrahedron. There are creases along the X, Y and Z axes where the pads 
 meet. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i69"><a name="f_strophoid"></a>
<p>
  <code>f_strophoid(x,y,z, P0, P1, P2, P3)</code>. The &quot;Strophoid&quot; is like an infinite plane with a bulb 
 sticking out of it. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Size of bulb. Larger values give larger bulbs. Negative values give a bulb on the other side of 
  the plane 
 </li>

 <li>
   <code>P2</code> : Sharpness. When zero, the bulb is like a sphere that just touches the plane. When positive, 
  there is a crossover point. When negative the bulb simply bulges out of the plane like a pimple 
 </li>

 <li>
   <code>P3</code> : Flatness. Higher values make the top end of the bulb fatter 
 </li>

</ul>
<a name="s03_07_07_02_i70"><a name="f_strophoid_2d"></a>
<p>
  <code>f_strophoid_2d(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>. The 2d strophoid curve can be extruded in the Z 
 direction or rotated about various axes by using the SOR parameters. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> 
 </li>

 <li>
   <code>P1</code> : Size of bulb. Larger values give larger bulbs. Negative values give a bulb on the other side of 
  the plane 
 </li>

 <li>
   <code>P2</code> : Sharpness. When zero, the bulb is like a sphere that just touches the plane. When positive, 
  there is a crossover point. When negative the bulb simply bulges out of the plane like a pimple 
 </li>

 <li>
   <code>P3</code> : Fatness. Higher values make the top end of the bulb fatter 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P6</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>
<a name="s03_07_07_02_i71"><a name="f_superellipsoid"></a>
<p>
  <code>f_superellipsoid(x,y,z, P0, P1)</code>. Needs a negative field strength or a negated function. 
</p>

<ul>
 
 <li>
   <code>P0</code> : east-west exponentx 
 </li>

 <li>
   <code>P1</code> : north-south exponent 
 </li>

</ul>
<a name="s03_07_07_02_i72"><a name="f_th"></a>
<p>
  <code>f_th(x,y,z)</code> = atan2( x, z ) <br><code>f_th()</code> is a function that is only useful when combined 
 with other surfaces. <br>It produces a value which is equal to the &quot;theta&quot; angle, in radians, at any point. 
 The theta angle is like the longitude coordinate on the Earth. It stays the same as you move north or south, but 
 varies from east to west. Also look at <code>f_ph</code> and <code>f_r</code> <a name="s03_07_07_02_i73"><a name="f_torus"></a> 
 
</p>

<p>
  <code>f_torus(x,y,z, P0, P1)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : Major radius 
 </li>

 <li>
   <code>P1</code> : Minor radius 
 </li>

</ul>
<a name="s03_07_07_02_i74"><a name="f_torus2"></a>
<p>
  <code>f_torus2(x,y,z, P0, P1, P2)</code>. This is different from the f_torus function which just has the major and 
 minor radii as parameters. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Major radius 
 </li>

 <li>
   <code>P2</code> : Minor radius 
 </li>

</ul>
<a name="s03_07_07_02_i75"><a name="f_torus_gumdrop"></a>
<p>
  <code>f_torus_gumdrop(x,y,z, P0)</code>. The &quot;Torus Gumdrop&quot; surface is something like a torus with a 
 couple of gumdrops hanging off the end. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i76"><a name="f_umbrella"></a>
<p>
  <code>f_umbrella(x,y,z, P0)</code> 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

</ul>
<a name="s03_07_07_02_i77"><a name="f_witch_of_agnesi"></a>
<p>
  <code>f_witch_of_agnesi(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The &quot;Witch of Agnesi&quot; surface looks 
 something like a witches hat. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Controls the width of the spike. The height of the spike is always about 1 unit 
 </li>

</ul>
<a name="s03_07_07_02_i78"><a name="f_witch_of_agnesi_2d"></a>
<p>
  <code>f_witch_of_agnesi_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>. The 2d version of the &quot;Witch of Agnesi&quot; 
 curve can be extruded in the Z direction or rotated about various axes by use of the SOR parameters. 
</p>

<ul>
 
 <li>
   <code>P0</code> : <a href="s_138.html#s03_07_07_01_01">Field Strength</a> (Needs a negative field strength or a 
  negated function) 
 </li>

 <li>
   <code>P1</code> : Controls the size of the spike 
 </li>

 <li>
   <code>P2</code> : Controls the height of the spike 
 </li>

 <li>
   <code>P3</code> : <a href="s_138.html#s03_07_07_01_03">SOR Switch</a> 
 </li>

 <li>
   <code>P4</code> : <a href="s_138.html#s03_07_07_01_04">SOR Offset</a> 
 </li>

 <li>
   <code>P5</code> : <a href="s_138.html#s03_07_07_01_05">SOR Angle</a> 
 </li>

</ul>

<h4><a name="s03_07_07_03">3.7.7.3 </a>Pre defined functions</h4>
<a name="s03_07_07_03_i1"><a name="eval_pigment"></a>
<p>
  <code>eval_pigment(Pigm, Vect)</code>, This macro evaluates the color of a pigment at a specific point. Some 
 pigments require more information than simply a point, slope pattern based pigments for example, and will not work 
 with this macro. However, most pigments will work fine.<br> Parameters: 
</p>

<ul>
 
 <li>
   <code>Vect</code> = The point at which to evaluate the pigment. 
 </li>

 <li>
   <code>Pigm</code> = The pigment to evaluate. 
 </li>

</ul>
<a name="s03_07_07_03_i2"><a name="f_snoise3d"></a>
<p>
  <code>f_snoise3d(x, y, z)</code>. Just like f_noise3d(), but returns values in the range [-1, 1]. <a name="s03_07_07_03_i3"><a name="f_sine_wave"></a> 
 
</p>

<p>
  <code>f_sine_wave(val, amplitude, frequency)</code>. Turns a ramping waveform into a sine waveform. <a name="s03_07_07_03_i4"><a name="f_scallop_wave"></a> 
 
</p>

<p>
  <code>f_scallop_wave(val, amplitude, frequency)</code>. Turns a ramping waveform into a &quot;scallop_wave&quot; 
 waveform. 
</p>

<h5><a name="s03_07_07_03_01">3.7.7.3.1 </a>Pattern functions</h5>

<p>
  Predefined pattern functions, useful for building custom function patterns or performing &quot;displacement 
 mapping&quot; on isosurfaces. Many of them are not really useful for these purposes, they are simply included for 
 completeness. 
</p>

<p>
  Some are not implemented at all because they require special parameters that must be specified in the definition, 
 or information that is not available to pattern functions. For this reason, you probably would want to define your own 
 versions of these functions. 
</p>

<p>
  All of these functions take three parameters, the XYZ coordinates of the point to evaluate the pattern at. 
</p>

<dl>
 
 <dt>
   <code>f_agate(x, y, z)</code> 
 <dt>
   <code>f_boxed(x, y, z)</code> 
 <dt>
   <code>f_bozo(x, y, z)</code> 
 <dt>
   <code>f_brick(x, y, z)</code> 
 <dt>
   <code>f_bumps(x, y, z)</code> 
 <dt>
   <code>f_checker(x, y, z)</code> 
 <dt>
   <code>f_crackle(x, y, z)</code> 
 <dd>
   This pattern has many more options, this function uses the defaults. 
 <dt>
   <code>f_cylindrical(x, y, z)</code> 
 <dt>
   <code>f_dents(x, y, z)</code> 
 <dt>
   <code>f_gradientX(x, y, z)</code> 
 <dt>
   <code>f_gradientY(x, y, z)</code> 
 <dt>
   <code>f_gradientZ(x, y, z)</code> 
 <dt>
   <code>f_granite(x, y, z)</code> 
 <dt>
   <code>f_hexagon(x, y, z)</code> 
 <dt>
   <code>f_leopard(x, y, z)</code> 
 <dt>
   <code>f_mandel(x, y, z)</code> 
 <dd>
   Only the basic mandel pattern is implemented, its variants and the other fractal patterns are not implemented. 
 <dt>
   <code>f_marble(x, y, z)</code> 
 <dt>
   <code>f_onion(x, y, z)</code> 
 <dt>
   <code>f_planar(x, y, z)</code> 
 <dt>
   <code>f_radial(x, y, z)</code> 
 <dt>
   <code>f_ripples(x, y, z)</code> 
 <dt>
   <code>f_spherical(x, y, z)</code> 
 <dt>
   <code>f_spiral1(x, y, z)</code> 
 <dt>
   <code>f_spiral2(x, y, z)</code> 
 <dt>
   <code>f_spotted(x, y, z)</code> 
 <dt>
   <code>f_waves(x, y, z)</code> 
 <dt>
   <code>f_wood(x, y, z)</code> 
 <dt>
   <code>f_wrinkles(x, y, z)</code> 
</dl>
 <br> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_137.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_137.html">3.7.6 finish.inc</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong>3.7.7 functions.inc</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_139.html">3.7.8 glass.inc, glass_old.inc</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_139.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 </body> </html>