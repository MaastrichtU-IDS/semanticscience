
<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2003-2004  -->
<html> 
<head>
  
<!--  NOTE: In order to users to help find information about POV-Ray using  -->
 
<!--  web search engines, we ask you to *not* let them index documentation  -->
 
<!--  mirrors because effectively, when searching, users will get hundreds  -->
 
<!--  of results containing the same information! For this reason, the two  -->
 
<!--  meta tags below disable archiving and indexing of this page by all  -->
 
<!--  search engines that support these meta tags.  -->
 
 <meta content="noarchive" name="robots">
   
 <meta content="noindex" name="robots">
   
 <meta content="no-cache" http-equiv="Pragma">
   
 <meta content="0" http-equiv="expires">
   
<title>3.4.1 Finite Solid Primitives</title>
 <link href="povray35.css" rel="stylesheet" type="text/css"> 
</head>
 <body> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_104.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_104.html">3.4 Objects</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong class="NavBar">POV-Ray 3.6 for UNIX documentation</strong><br> <strong>3.4.1 
   Finite Solid Primitives</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_106.html">3.4.2 Finite Patch Primitives</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_106.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 
<h3><a name="s03_04_01">3.4.1 </a>Finite Solid Primitives</h3>

<p>
  There are fourteen different solid finite primitive shapes: blob, box, cone, cylinder, height field, Julia fractal, 
 lathe, prism, sphere, spheresweep, superellipsoid, surface of revolution, text object and torus. These have a 
 well-defined <em>inside</em> and can be used in CSG (see section &quot;<a href="s_110.html#s03_04_06">Constructive 
 Solid Geometry</a>&quot;). They are finite and respond to automatic bounding. You may specify an interior for these 
 objects. 
</p>

<h4><a name="s03_04_01_01">3.4.1.1 </a>Blob</h4>
<a name="s03_04_01_01_i1"><a name="s03_04_01_01_i2"><a name="blob"></a><a name="s03_04_01_01_i3"><a name="blob, keyword"></a><a name="s03_04_01_01_i4"><a name="s03_04_01_01_i5"><a name="sphere, blob"></a><a name="s03_04_01_01_i6"><a name="s03_04_01_01_i7"><a name="strength, blob"></a><a name="s03_04_01_01_i8"><a name="s03_04_01_01_i9"><a name="cylinder, blob"></a><a name="s03_04_01_01_i10"><a name="s03_04_01_01_i11"><a name="component, blob"></a><a name="s03_04_01_01_i12"><a name="s03_04_01_01_i13"><a name="threshold, blob"></a><a name="s03_04_01_01_i14"><a name="s03_04_01_01_i15"><a name="hierarchy, blob"></a><a name="s03_04_01_01_i16"><a name="s03_04_01_01_i17"><a name="sturm, blob"></a><a name="s03_04_01_01_i18">
<p>
  Blobs are an interesting and flexible object type. Mathematically they are iso-surfaces of scalar fields, i.e. 
 their surface is defined by the strength of the field in each point. If this strength is equal to a threshold value 
 you are on the surface otherwise you are not. 
</p>

<p>
  Picture each blob component as an object floating in space. This object is <em> filled</em> with a field that has 
 its maximum at the center of the object and drops off to zero at the object's surface. The field strength of all those 
 components are added together to form the field of the blob. Now POV-Ray looks for points where this field has a given 
 value, the threshold value. All these points form the surface of the blob object. Points with a greater field value 
 than the threshold value are considered to be inside while points with a smaller field value are outside. 
</p>

<p>
  There's another, simpler way of looking at blobs. They can be seen as a union of flexible components that attract 
 or repel each other to form a blobby organic looking shape. The components' surfaces actually stretch out smoothly and 
 connect as if they were made of honey or something similar. 
</p>

<p>
  The syntax for <code>blob</code> is defined as follows: 
</p>

<pre>
BLOB:
    blob { BLOB_ITEM... [BLOB_MODIFIERS...]}
BLOB_ITEM:
    sphere{&lt;Center&gt;, Radius,
           [ strength ] Strength[COMPONENT_MODIFIER...] } |
    cylinder{&lt;End1&gt;, &lt;End2&gt;, Radius,
             [ strength ] Strength [COMPONENT_MODIFIER...] } |
    component Strength, Radius, &lt;Center&gt; |
    threshold Amount
COMPONENT_MODIFIER:
    TEXTURE | PIGMENT | NORMAL | FINISH | TRANSFORMATION
BLOB_MODIFIER:
    hierarchy [Boolean] | sturm [Boolean] | OBJECT_MODIFIER
</pre>

<p>
  Blob default values: <a name="s03_04_01_01_i19"> 
</p>

<pre>
hierarchy : on
sturm     : off
threshold : 1.0
</pre>
<a name="s03_04_01_01_i20"><a name="threshold"></a>
<p>
  The <code>threshold</code> keyword is followed by a float value which determines the total field strength value 
 that POV-Ray is looking for. The default value if none is specified is <code>threshold 1.0</code>. By following the 
 ray out into space and looking at how each blob component affects the ray, POV-Ray will find the points in space where 
 the field strength is equal to the threshold value. The following list shows some things you should know about the 
 threshold value. 
</p>

<ol>
 
 <li>
   The threshold value must be positive. 
 </li>

 <li>
   A component disappears if the threshold value is greater than its strength. 
 </li>

 <li>
   As the threshold value gets larger, the surface you see gets closer to the centers of the components. 
 </li>

 <li>
   As the threshold value gets smaller, the surface you see gets closer to the surface of the components. 
 </li>

</ol>
<a name="s03_04_01_01_i21"><a name="s03_04_01_01_i22">
<p>
  Cylindrical components are specified by a <code>cylinder</code> statement. The center of the end-caps of the 
 cylinder is defined by the vectors <em> <code>&lt;End1&gt;</code></em> and <em><code> &lt;End2&gt;</code></em>. Next 
 is the float value of the <em>Radius</em> followed by the float <em> Strength</em>. These vectors and floats are 
 required and should be separated by commas. The keyword <code> strength</code> may optionally precede the strength 
 value. The cylinder has hemispherical caps at each end.<a name="s03_04_01_01_i23"><a name="s03_04_01_01_i24"> 
</p>

<p>
  Spherical components are specified by a <code>sphere</code> statement. The location is defined by the vector <em> <code>&lt;Center&gt;</code></em>. 
 Next is the float value of the <em> Radius</em> followed by the float <em> Strength</em>. These vector and float 
 values are required and should be separated by commas. The keyword <code> strength</code> may optionally precede the 
 strength value. 
</p>

<p>
  You usually will apply a single texture to the entire blob object, and you typically use transformations to change 
 its size, location, and orientation. However both the <code>cylinder</code> and <code>sphere</code> statements may 
 have individual texture, pigment, normal, finish, and transformations applied to them. You may not apply separate <code>interior</code> 
 statements to the components but you may specify one for the entire blob. 
</p>

<p class="Note">
  <strong>Note:</strong> by unevenly scaling a spherical component you can create ellipsoidal 
 components. The tutorial section on &quot;<a href="s_68.html#s02_03_03_01">Blob Object</a>&quot; illustrates 
 individually textured blob components and many other blob examples. 
</p>

<p>
  <a name="s03_04_01_01_i25"><a name="component"></a> <a name="s03_04_01_01_i26"> The <code>component</code> keyword 
 is an obsolete method for specifying a spherical component and is only used for compatibility with earlier POV-Ray 
 versions. It may not have textures or transformations individually applied to it. 
</p>

<p>
  <a name="s03_04_01_01_i27"><a name="strength"></a> <a name="s03_04_01_01_i28"> The <code>strength</code> parameter 
 of either type of blob component is a float value specifying the field strength at the center of the object. The 
 strength may be positive or negative. A positive value will make that component attract other components while a 
 negative value will make it repel other components. Components in different, separate blob shapes do not affect each 
 other. 
</p>

<p>
  You should keep the following things in mind. 
</p>

<ol>
 
 <li>
   The strength value may be positive or negative. Zero is a bad value, as the net result is that no field was added 
  -- you might just as well have not used this component. 
 </li>

 <li>
   If strength is positive, then POV-Ray will add the component's field to the space around the center of the 
  component. If this adds enough field strength to be greater than the threshold value you will see a surface. 
 </li>

 <li>
   If the strength value is negative, then POV-Ray will subtract the component's field from the space around the 
  center of the component. This will only do something if there happen to be positive components nearby. The surface 
  around any nearby positive components will be dented away from the center of the negative component. 
 </li>

</ol>
<a name="s03_04_01_01_i29"><a name="hierarchy"></a><a name="s03_04_01_01_i30">
<p>
  After all components and the optional <code>threshold</code> value have been specified you may specify zero or more 
 blob modifiers. A blob modifier is any regular object modifier or the <code>hierarchy</code> or <code> sturm</code> 
 keywords. 
</p>

<p>
  The components of each blob object are internally bounded by a spherical bounding hierarchy to speed up blob 
 intersection tests and other operations. Using the optional keyword <code> hierarchy</code> followed by an optional 
 boolean float value will turn it off or on. By default it is on. 
</p>

<p>
  The calculations for blobs must be very accurate. If this shape renders improperly you may add the keyword <code> 
 sturm</code> followed by an optional boolean float value to turn off or on POV-Ray's slower-yet-more-accurate Sturmian 
 root solver. By default it is off. 
</p>

<p>
  An example of a three component blob is: 
</p>

<pre>
BLOB:
 blob {
  threshold 0.6
  sphere { &lt;.75, 0, 0&gt;, 1, 1 }
  sphere { &lt;-.375, .64952, 0&gt;, 1, 1 }
  sphere { &lt;-.375, -.64952, 0&gt;, 1, 1 }
  scale 2
 }
</pre>

<p>
  If you have a single blob component then the surface you see will just look like the object used, i.e. a sphere or 
 a cylinder, with the surface being somewhere inside the surface specified for the component. The exact surface 
 location can be determined from the blob equation listed below (you will probably never need to know this, blobs are 
 more for visual appeal than for exact modeling). 
</p>

<p>
  For the more mathematically minded, here's the formula used internally by POV-Ray to create blobs. You do not need 
 to understand this to use blobs. The density of the blob field of a single component is: 
</p>

<p>
  <br><center><img alt="Density of a blob field." src="images/reference/blobdens.png"></center> 
</p>

<p>
  where <em>distance</em> is the distance of a given point from the spherical blob's center or cylinder blob's axis. 
 This formula has the nice property that it is exactly equal to the strength parameter at the center of the component 
 and drops off to exactly 0 at a distance from the center of the component that is equal to the radius value. The 
 density formula for more than one blob component is just the sum of the individual component densities. 
</p>

<h4><a name="s03_04_01_02">3.4.1.2 </a>Box</h4>
<a name="s03_04_01_02_i1"><a name="box"></a><a name="s03_04_01_02_i2"><a name="box, keyword"></a><a name="s03_04_01_02_i3">
<p>
  A simple box can be defined by listing two corners of the box using the following syntax for a <code>box</code> 
 statement: 
</p>

<pre>
BOX:
    box
    {
        &lt;Corner_1&gt;, &lt;Corner_2&gt;
        [OBJECT_MODIFIERS...]
    }
</pre>

<p>
  <br><center><img alt="The geometry of a box." src="images/reference/boxgeom.png"></center> 
</p>

<p>
  Where <em><code>&lt;Corner_1&gt;</code></em> and <em><code> &lt;Corner_2&gt;</code></em> are vectors defining the 
 x, y, z coordinates of the opposite corners of the box. 
</p>

<p class="Note">
  <strong>Note:</strong> that all boxes are defined with their faces parallel to the coordinate axes. 
 They may later be rotated to any orientation using the <code> rotate</code> keyword. 
</p>

<p>
  Boxes are calculated efficiently and make good bounding shapes (if manually bounding seems to be necessary). 
</p>

<h4><a name="s03_04_01_03">3.4.1.3 </a>Cone</h4>
<a name="s03_04_01_03_i1"><a name="cone"></a><a name="s03_04_01_03_i2"><a name="cone, keyword"></a><a name="s03_04_01_03_i3"><a name="s03_04_01_03_i4"><a name="open, cone"></a><a name="s03_04_01_03_i5">
<p>
  The <code>cone</code> statement creates a finite length cone or a <em> frustum</em> (a cone with the point cut 
 off). The syntax is: 
</p>

<pre>
CONE:
    cone
    {
        &lt;Base_Point&gt;, Base_Radius, &lt;Cap_Point&gt;, Cap_Radius
        [ open ][OBJECT_MODIFIERS...]
    }
</pre>

<p>
  <br><center><img alt="The geometry of a cone." src="images/reference/conegeom.png"></center> 
</p>

<p>
  Where <em><code>&lt;Base_Point&gt;</code></em> and <em><code>&lt; Cap_Point&gt;</code></em> are vectors defining 
 the x, y, z coordinates of the center of the cone's base and cap and <em><code> Base_Radius</code></em> and <em><code>Cap_Radius</code></em> 
 are float values for the corresponding radii. 
</p>

<p>
  Normally the ends of a cone are closed by flat discs that are parallel to each other and perpendicular to the 
 length of the cone. Adding the optional keyword <code>open</code> after <em><code>Cap_Radius</code></em> will remove 
 the end caps and results in a tapered hollow tube like a megaphone or funnel. 
</p>

<h4><a name="s03_04_01_04">3.4.1.4 </a>Cylinder</h4>
<a name="s03_04_01_04_i1"><a name="cylinder"></a><a name="s03_04_01_04_i2"><a name="cylinder, keyword"></a><a name="s03_04_01_04_i3"><a name="s03_04_01_04_i4"><a name="open, cylinder"></a><a name="s03_04_01_04_i5">
<p>
  The <code>cylinder</code> statement creates a finite length cylinder with parallel end caps The syntax is: 
</p>

<pre>
CYLINDER:
    cylinder
    {
        &lt;Base_Point&gt;, &lt;Cap_Point&gt;, Radius
        [ open ][OBJECT_MODIFIERS...]
    }
</pre>

<p>
  <br><center><img alt="The geometry of a cylinder." src="images/reference/cylgeom.png"></center> 
</p>

<p>
  Where <em><code>&lt;Base_Point&gt;</code></em> and <em><code> &lt;Cap_Point&gt;</code></em> are vectors defining 
 the x, y, z coordinates of the cylinder's base and cap and <em><code>Radius</code></em> is a float value for the 
 radius. 
</p>

<p>
  Normally the ends of a cylinder are closed by flat discs that are parallel to each other and perpendicular to the 
 length of the cylinder. Adding the optional keyword <code>open</code> after the radius will remove the end caps and 
 results in a hollow tube. 
</p>

<h4><a name="s03_04_01_05">3.4.1.5 </a>Height Field</h4>
<a name="s03_04_01_05_i1"><a name="height_field"></a><a name="s03_04_01_05_i2"><a name="height_field, keyword"></a><a name="s03_04_01_05_i3"><a name="s03_04_01_05_i4"><a name="hierarchy, height_field"></a><a name="s03_04_01_05_i5"><a name="s03_04_01_05_i6"><a name="smooth, height_field"></a><a name="s03_04_01_05_i7"><a name="s03_04_01_05_i8"><a name="water_level, height_field"></a><a name="s03_04_01_05_i9"><a name="s03_04_01_05_i10"><a name="gif, height_field"></a><a name="s03_04_01_05_i11"><a name="s03_04_01_05_i12"><a name="tga, height_field"></a><a name="s03_04_01_05_i13"><a name="s03_04_01_05_i14"><a name="pot, height_field"></a><a name="s03_04_01_05_i15"><a name="s03_04_01_05_i16"><a name="png, height_field"></a><a name="s03_04_01_05_i17"><a name="s03_04_01_05_i18"><a name="pgm, height_field"></a><a name="s03_04_01_05_i19"><a name="s03_04_01_05_i20"><a name="jpeg, height_field"></a><a name="s03_04_01_05_i21"><a name="s03_04_01_05_i22"><a name="tiff, height_field"></a><a name="s03_04_01_05_i23"><a name="s03_04_01_05_i24"><a name="sys, height_field"></a><a name="s03_04_01_05_i25"><a name="s03_04_01_05_i26"><a name="function, height_field"></a><a name="s03_04_01_05_i27"><a name="s03_04_01_05_i28">
<p>
  Height fields are fast, efficient objects that are generally used to create mountains or other raised surfaces out 
 of hundreds of triangles in a mesh. The <code>height_field</code> statement syntax is: 
</p>

<pre>
HEIGHT_FIELD:
    height_field{
      [HF_TYPE]
      &quot;filename&quot;
      [HF_MODIFIER...]
      [OBJECT_MODIFIER...]
    }
HF_TYPE:
    gif | tga | pot | png | pgm | ppm | jpeg | tiff | sys | function
HF_MODIFIER:
    hierarchy [Boolean]  |
    smooth               |
    water_level Level
</pre>

<p>
  Height_field default values: <a name="s03_04_01_05_i29"> 
</p>

<pre>
hierarchy   : on
smooth      : off
water_level : 0.0
</pre>

<p>
  A height field is essentially a one unit wide by one unit long square with a mountainous surface on top. The height 
 of the mountain at each point is taken from the color number or palette index of the pixels in a graphic image file. 
 The maximum height is one, which corresponds to the maximum possible color or palette index value in the image file. 
</p>

<p>
  <br><center><img alt="The size and orientation of an un-scaled height field." src="images/reference/unhfield.png"></center> 
 
</p>

<p>
  The mesh of triangles corresponds directly to the pixels in the image file. Each square formed by four neighboring 
 pixels is divided into two triangles. An image with a resolution of <em><code>N*M</code></em> pixels has <em><code>(N-1)*(M-1)</code></em> 
 squares that are divided into <em> <code> 2*(N-1)*(M-1)</code></em> triangles. 
</p>

<p>
  <br><center><img alt="Relationship of pixels and triangles in a height field." src="images/reference/pixhfld.png"></center> 
 
</p>

<p>
  The resolution of the height field is influenced by two factors: the resolution of the image and the resolution of 
 the color/index values. The size of the image determines the resolution in the x- and z-direction. A larger image uses 
 more triangles and looks smoother. The resolution of the color/index value determines the resolution along the y-axis. 
 A height field made from an 8-bit image can have 256 different height levels while one made from a 16-bit image can 
 have up to 65536 different height levels. Thus the second height field will look much smoother in the y-direction if 
 the height field is created appropriately. 
</p>

<p>
  The size/resolution of the image does not affect the size of the height field. The un-scaled height field size will 
 always be 1 by 1 by 1. Higher resolution image files will create smaller triangles, not larger height fields. 
</p>

<p>
  <a name="s03_04_01_05_i30"><a name="pot"></a> There are eight or possibly nine types of files which can define a 
 height field. The image file type used to create a height field is specified by one of the keywords <code>gif</code>, <code>tga</code>, 
 <code>pot</code>, <code>png</code>, <code> pgm</code>, <code> ppm</code>,<code> tiff</code>, <code>jpeg</code> and 
 possibly <code> sys</code> which is a system specific (e. g. Windows BMP or Macintosh Pict) format file. Specifying 
 the file type is optional. If it is not defined the same file type will be assumed as the one that is set as the 
 output file type. This is useful when the source for the <code>height_field</code> is also generated with POV-Ray. 
</p>

<p>
  The GIF, PNG, PGM, TIFF and possibly SYS format files are the only ones that can be created using a standard paint 
 program. Though there are paint programs for creating TGA image files they will not be of much use for creating the 
 special 16 bit TGA files used by POV-Ray (see below and &quot;HF_Gray_16&quot; for more details). 
</p>

<p>
  In an image file that uses a color palette, like GIF, the color number is the palette index at a given pixel. Use a 
 paint program to look at the palette of a GIF image. The first color is palette index zero, the second is index one, 
 the third is index two and so on. The last palette entry is index 255. Portions of the image that use low palette 
 entries will result in lower parts of the height field. Portions of the image that use higher palette entries will 
 result in higher parts of the height field. 
</p>

<p>
  Height fields created from GIF files can only have 256 different height levels because the maximum number of colors 
 in a GIF file is 256. 
</p>

<p>
  The color of the palette entry does not affect the height of the pixel. Color entry 0 could be red, blue, black or 
 orange but the height of any pixel that uses color entry 0 will always be 0. Color entry 255 could be indigo, hot 
 pink, white or sky blue but the height of any pixel that uses color entry 255 will always be 1. 
</p>

<p>
  You can create height field GIF images with a paint program or a fractal program like <code> Fractint</code>. You 
 can usually get <code> Fractint</code> from most of the same sources as POV-Ray. 
</p>

<p>
  A POT file is essentially a GIF file with a 16 bit palette. The maximum number of colors in a POT file is 65536. 
 This means a POT height field can have up to 65536 possible height values. This makes it possible to have much 
 smoother height fields. 
</p>

<p class="Note">
  <strong>Note:</strong> the maximum height of the field is still 1 even though more intermediate values 
 are possible. 
</p>

<p>
  At the time of this writing the only program that created POT files was a freeware MS-Dos/Windows program called <code>Fractint</code>. 
 POT files generated with this fractal program create fantastic landscapes. 
</p>

<p>
  The TGA and PPM file formats may be used as a storage device for 16 bit numbers rather than an image file. These 
 formats use the red and green bytes of each pixel to store the high and low bytes of a height value. These files are 
 as smooth as POT files but they must be generated with special custom-made programs. Several programs can create TGA 
 heightfields in the format POV uses, such as <code>Gforge</code> and <code>Terrain Maker</code>. 
</p>

<p>
  PNG format heightfields are usually stored in the form of a grayscale image with black corresponding to lower and 
 white to higher parts of the height field. Because PNG files can store up to 16 bits in grayscale images they will be 
 as smooth as TGA and PPM images. Since they are grayscale images you will be able to view them with a regular image 
 viewer. <code> gforge</code> can create 16-bit heightfields in PNG format. Color PNG images will be used in the same 
 way as TGA and PPM images. 
</p>

<p>
  SYS format is a platform specific file format. See your platform specific documentation for details. 
</p>

<p>
  In addition to all the usual object modifiers, there are three additional height field modifiers available. 
</p>

<p>
  <a name="s03_04_01_05_i31"><a name="water_level"></a> The optional <code>water_level</code> parameter may be added 
 after the file name. It consists of the keyword <code>water_level</code> followed by a float value telling the program 
 to ignore parts of the height field below that value. The default value is zero and legal values are between zero and 
 one. For example <code>water_level 0.5</code> tells POV-Ray to only render the top half of the height field. The other 
 half is <em>below the water</em> and could not be seen anyway. Using <code>water_level</code> renders faster than 
 cutting off the lower part using CSG or clipping. This term comes from the popular use of height fields to render 
 landscapes. A height field would be used to create islands and another shape would be used to simulate water around 
 the islands. A large portion of the height field would be obscured by the water so the <code> water_level</code> 
 parameter was introduced to allow the ray-tracer to ignore the unseen parts of the height field. <code>water_level</code> 
 is also used to cut away unwanted lower values in a height field. For example if you have an image of a fractal on a 
 solid colored background, where the background color is palette entry 0, you can remove the background in the height 
 field by specifying, <code> water_level 0.001</code>. 
</p>

<p>
  <a name="s03_04_01_05_i32"><a name="smooth"></a> Normally height fields have a rough, jagged look because they are 
 made of lots of flat triangles. Adding the keyword <code> smooth</code> causes POV-Ray to modify the surface normal 
 vectors of the triangles in such a way that the lighting and shading of the triangles will give a smooth look. This 
 may allow you to use a lower resolution file for your height field than would otherwise be needed. However, smooth 
 triangles will take longer to render. The default value is off. 
</p>

<p>
  <a name="s03_04_01_05_i33"> In order to speed up the intersection tests a one-level bounding hierarchy is 
 available. By default it is always used but it can be switched off using <code>hierarchy off</code> to improve the 
 rendering speed for small height fields (i.e. low resolution images). You may optionally use a boolean value such as <code> 
 hierarchy on</code> or <code> hierarchy off</code>. 
</p>

<h4><a name="s03_04_01_06">3.4.1.6 </a>Julia Fractal</h4>
<a name="s03_04_01_06_i1"><a name="s03_04_01_06_i2"><a name="fractal"></a><a name="s03_04_01_06_i3"><a name="julia_fractal"></a><a name="s03_04_01_06_i4"><a name="julia_fractal, keyword"></a><a name="s03_04_01_06_i5"><a name="s03_04_01_06_i6"><a name="max_iteration, julia_fractal"></a><a name="s03_04_01_06_i7"><a name="s03_04_01_06_i8"><a name="precision, julia_fractal"></a><a name="s03_04_01_06_i9"><a name="s03_04_01_06_i10"><a name="quaternion, julia_fractal"></a><a name="s03_04_01_06_i11"><a name="s03_04_01_06_i12"><a name="hypercomplex, julia_fractal"></a><a name="s03_04_01_06_i13"><a name="s03_04_01_06_i14"><a name="sqr, julia_fractal"></a><a name="s03_04_01_06_i15"><a name="s03_04_01_06_i16"><a name="cube, julia_fractal"></a><a name="s03_04_01_06_i17"><a name="s03_04_01_06_i18"><a name="exp, julia_fractal"></a><a name="s03_04_01_06_i19"><a name="s03_04_01_06_i20"><a name="reciprocal, julia_fractal"></a><a name="s03_04_01_06_i21"><a name="s03_04_01_06_i22"><a name="sin, julia_fractal"></a><a name="s03_04_01_06_i23"><a name="s03_04_01_06_i24"><a name="asin, julia_fractal"></a><a name="s03_04_01_06_i25"><a name="s03_04_01_06_i26"><a name="sinh, julia_fractal"></a><a name="s03_04_01_06_i27"><a name="s03_04_01_06_i28"><a name="asinh, julia_fractal"></a><a name="s03_04_01_06_i29"><a name="s03_04_01_06_i30"><a name="cos, julia_fractal"></a><a name="s03_04_01_06_i31"><a name="s03_04_01_06_i32"><a name="acos, julia_fractal"></a><a name="s03_04_01_06_i33"><a name="s03_04_01_06_i34"><a name="cosh, julia_fractal"></a><a name="s03_04_01_06_i35"><a name="s03_04_01_06_i36"><a name="acosh, julia_fractal"></a><a name="s03_04_01_06_i37"><a name="s03_04_01_06_i38"><a name="tan, julia_fractal"></a><a name="s03_04_01_06_i39"><a name="s03_04_01_06_i40"><a name="atan, julia_fractal"></a><a name="s03_04_01_06_i41"><a name="s03_04_01_06_i42"><a name="tanh, julia_fractal"></a><a name="s03_04_01_06_i43"><a name="s03_04_01_06_i44"><a name="atanh, julia_fractal"></a><a name="s03_04_01_06_i45"><a name="s03_04_01_06_i46"><a name="ln, julia_fractal"></a><a name="s03_04_01_06_i47"><a name="s03_04_01_06_i48"><a name="pwr, julia_fractal"></a><a name="s03_04_01_06_i49">
<p>
  A <em>julia fractal</em> object is a 3-D <em>slice</em> of a 4-D object created by generalizing the process used to 
 create the classic Julia sets. You can make a wide variety of strange objects using the <code> julia_fractal</code> 
 statement including some that look like bizarre blobs of twisted taffy. The <code>julia_fractal</code> syntax is: 
</p>

<pre>
JULIA_FRACTAL:
    julia_fractal
    {
        &lt;4D_Julia_Parameter&gt;
        [JF_ITEM...] [OBJECT_MODIFIER...]
    }
JF_ITEM:
    ALGEBRA_TYPE | FUNCTION_TYPE | max_iteration Count |
    precision Amt | slice &lt;4D_Normal&gt;, Distance
ALGEBRA_TYPE:
    quaternion | hypercomplex
FUNCTION_TYPE:
    QUATERNATION: 
         sqr | cube
    HYPERCOMPLEX:
         sqr | cube | exp | reciprocal | sin | asin | sinh |
         asinh | cos | acos | cosh | acosh | tan | atan |tanh |
         atanh | ln | pwr( X_Val, Y_Val )
</pre>

<p>
  Julia Fractal default values: <a name="s03_04_01_06_i50"> 
</p>

<pre>
ALGEBRA_TYPE    : quaternion
FUNCTION_TYPE   : sqr
max_iteration   : 20
precision       : 20
slice, DISTANCE : &lt;0,0,0,1&gt;, 0.0
</pre>
<a name="s03_04_01_06_i51"><a name="max_iteration"></a>
<p>
  The required 4-D vector <em><code>&lt;4D_Julia_Parameter&gt;</code></em> is the classic Julia parameter <em><code>p</code></em> 
 in the iterated formula <em><code>f(h) + p</code></em>. The julia fractal object is calculated by using an algorithm 
 that determines whether an arbitrary point <em><code>h(0)</code></em> in 4-D space is inside or outside the object. 
 The algorithm requires generating the sequence of vectors <em><code>h(0), h(1), ...</code></em> by iterating the 
 formula <em><code>h(n+1) = f(h(n)) + p (n = 0, 1, ..., max_iteration-1)</code></em> where <em><code> p</code></em> is 
 the fixed 4-D vector parameter of the julia fractal and <em><code>f()</code></em> is one of the functions <code>sqr</code>, 
 <code> cube</code>, ... specified by the presence of the corresponding keyword. The point <em><code> h(0)</code></em> 
 that begins the sequence is considered inside the julia fractal object if none of the vectors in the sequence escapes 
 a hypersphere of radius 4 about the origin before the iteration number reaches the integer <code>max_iteration</code> 
 value. As you increase <code>max_iteration</code>, some points escape that did not previously escape, forming the 
 julia fractal. Depending on the <em><code> &lt;4D_Julia_Parameter&gt;</code></em>, the julia fractal object is not 
 necessarily connected; it may be scattered fractal dust. Using a low <code> max_iteration</code> can fuse together the 
 dust to make a solid object. A high <code>max_iteration</code> is more accurate but slows rendering. Even though it is 
 not accurate, the solid shapes you get with a low <code>max_iteration</code> value can be quite interesting. If none 
 is specified, the default is <code>max_iteration 20</code>. 
</p>

<p>
  <a name="s03_04_01_06_i52"><a name="slice"></a> Since the mathematical object described by this algorithm is 
 four-dimensional and POV-Ray renders three dimensional objects, there must be a way to reduce the number of dimensions 
 of the object from four dimensions to three. This is accomplished by intersecting the 4-D fractal with a 3-D 
 &quot;plane&quot; defined by the <code>slice</code> modifier and then projecting the intersection to 3-D space. The 
 keyword is followed by 4-D vector and a float separated by a comma. The slice plane is the 3-D space that is 
 perpendicular to <em><code> &lt;4D_Normal&gt;</code></em> and is <em><code> Distance</code></em> units from the 
 origin. Zero length <em><code> &lt;4D_Normal&gt;</code></em> vectors or a <em><code> &lt;4D_Normal&gt;</code></em> 
 vector with a zero fourth component are illegal. If none is specified, the default is <code> slice &lt;0,0,0,1&gt;,0</code>. 
 
</p>

<p>
  You can get a good feel for the four dimensional nature of a julia fractal by using POV-Ray's animation feature to 
 vary a slice's <em><code> Distance</code></em> parameter. You can make the julia fractal appear from nothing, grow, 
 then shrink to nothing as <em><code> Distance</code></em> changes, much as the cross section of a 3-D object changes 
 as it passes through a plane. 
</p>

<p>
  <a name="s03_04_01_06_i53"><a name="precision"></a> The <code> precision</code> parameter is a tolerance used in 
 the determination of whether points are inside or outside the fractal object. Larger values give more accurate results 
 but slower rendering. Use as low a value as you can without visibly degrading the fractal object's appearance but note 
 values less than 1.0 are clipped at 1.0. The default if none is specified is <code>precision 20</code>. 
</p>

<p>
  <a name="s03_04_01_06_i54"><a name="quaternion"></a><a name="s03_04_01_06_i55"><a name="hypercomplex"></a> The 
 presence of the keywords <code> quaternion</code> or <code> hypercomplex</code> determine which 4-D algebra is used to 
 calculate the fractal. The default is <code>quaternion</code>. Both are 4-D generalizations of the complex numbers but 
 neither satisfies all the field properties (all the properties of real and complex numbers that many of us slept 
 through in high school). Quaternions have non-commutative multiplication and hypercomplex numbers can fail to have a 
 multiplicative inverse for some non-zero elements (it has been proved that you cannot successfully generalize complex 
 numbers to four dimensions with all the field properties intact, so something has to break). Both of these algebras 
 were discovered in the 19th century. Of the two, the quaternions are much better known, but one can argue that 
 hypercomplex numbers are more useful for our purposes, since complex valued functions such as sin, cos, etc. can be 
 generalized to work for hypercomplex numbers in a uniform way. 
</p>

<p>
  For the mathematically curious, the algebraic properties of these two algebras can be derived from the 
 multiplication properties of the unit basis vectors 1 = &lt;1,0,0,0&gt;, i=&lt; 0,1,0,0&gt;, j=&lt;0,0,1,0&gt; and 
 k=&lt; 0,0,0,1&gt;. In both algebras 1 x = x 1 = x for any x (1 is the multiplicative identity). The basis vectors 1 
 and i behave exactly like the familiar complex numbers 1 and i in both algebras. 
</p>

<table summary="Quaternion basis vector multiplication rules" width="75%">
 
 <tr>
  
  <td width="33%">
    <code>ij = k</code> 
  </td>

  <td width="33%">
    <code>jk = i</code> 
  </td>

  <td width="33%">
    <code>ki = j</code> 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>ji = -k</code> 
  </td>

  <td>
    <code>kj = -i</code> 
  </td>

  <td>
    <code>ik = -j</code> 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>ii = jj = kk = -1</code> 
  </td>

  <td>
    <code>ijk = -1</code> 
  </td>

  <td>
    &nbsp;&nbsp;&nbsp; 
  </td>

 </tr>

</table>

<table summary="Hypercomplex basis vector multiplication rules" width="75%">
 
 <tr>
  
  <td width="33%">
    <code>ij = k</code> 
  </td>

  <td width="33%">
    <code>jk = -i</code> 
  </td>

  <td width="33%">
    <code>ki = -j</code> 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>ji = k</code> 
  </td>

  <td>
    <code>kj = -i</code> 
  </td>

  <td>
    <code>ik = -j</code> 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>ii = jj = kk = -1</code> 
  </td>

  <td>
    <code>ijk = 1</code> 
  </td>

  <td>
    &nbsp;&nbsp;&nbsp; 
  </td>

 </tr>

</table>

<p>
  A distance estimation calculation is used with the quaternion calculations to speed them up. The proof that this 
 distance estimation formula works does not generalize from two to four dimensions but the formula seems to work well 
 anyway, the absence of proof notwithstanding! 
</p>

<p>
  <a name="s03_04_01_06_i56"><a name="sqr"></a> <a name="s03_04_01_06_i57"><a name="cube"></a> The presence of one of 
 the function keywords <code>sqr</code>, <code> cube</code>, etc. determines which function is used for <em><code> f(h)</code></em> 
 in the iteration formula <em> <code>h(n+1) = f(h(n)) + p</code></em>. The default is <code>sqr.</code> Most of the 
 function keywords work only if the <code>hypercomplex</code> keyword is present. Only <code> sqr</code> and <code>cube</code> 
 work with <code> quaternion</code>. The functions are all familiar complex functions generalized to four dimensions. 
 Function Keyword Maps 4-D value h to: 
</p>

<table summary="Function Keyword Maps 4-D value of h" width="75%">
 
 <tr>
  
  <td width="30%">
    <code>sqr</code> 
  </td>

  <td width="70%">
    h*h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>cube</code> 
  </td>

  <td>
    h*h*h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>exp</code><a name="s03_04_01_06_i58"> 
  </td>

  <td>
    e raised to the power h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>reciprocal</code><a name="s03_04_01_06_i59"><a name="reciprocal"></a> 
  </td>

  <td>
    1/h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>sin</code><a name="s03_04_01_06_i60"> 
  </td>

  <td>
    sine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>asin</code><a name="s03_04_01_06_i61"> 
  </td>

  <td>
    arcsine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>sinh</code><a name="s03_04_01_06_i62"> 
  </td>

  <td>
    hyperbolic sine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>asinh</code><a name="s03_04_01_06_i63"> 
  </td>

  <td>
    inverse hyperbolic sine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>cos</code><a name="s03_04_01_06_i64"> 
  </td>

  <td>
    cosine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>acos</code><a name="s03_04_01_06_i65"> 
  </td>

  <td>
    arccosine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>cosh</code><a name="s03_04_01_06_i66"> 
  </td>

  <td>
    hyperbolic cos of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>acosh</code><a name="s03_04_01_06_i67"> 
  </td>

  <td>
    inverse hyperbolic cosine of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>tan</code><a name="s03_04_01_06_i68"> 
  </td>

  <td>
    tangent of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>atan</code><a name="s03_04_01_06_i69"><a name="atan"></a> 
  </td>

  <td>
    arctangent of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>tanh</code><a name="s03_04_01_06_i70"> 
  </td>

  <td>
    hyperbolic tangent of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>atanh</code><a name="s03_04_01_06_i71"> 
  </td>

  <td>
    inverse hyperbolic tangent of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>ln</code><a name="s03_04_01_06_i72"> 
  </td>

  <td>
    natural logarithm of h 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>pwr(x,y)</code><a name="s03_04_01_06_i73"><a name="pwr"></a> 
  </td>

  <td>
    h raised to the complex power x+iy 
  </td>

 </tr>

</table>

<p>
  A simple example of a julia fractal object is: 
</p>

<pre>
 julia_fractal {
  &lt;-0.083,0.0,-0.83,-0.025&gt;
  quaternion
  sqr
  max_iteration 8
  precision 15
 }
</pre>

<p>
  The first renderings of julia fractals using quaternions were done by Alan Norton and later by John Hart in the 
 '80's. This POV-Ray implementation follows <code>Fractint</code> in pushing beyond what is known in the literature by 
 using hypercomplex numbers and by generalizing the iterating formula to use a variety of transcendental functions 
 instead of just the classic Mandelbrot <em>z2 + c</em> formula. With an extra two dimensions and eighteen functions to 
 work with, intrepid explorers should be able to locate some new fractal beasts in hyperspace, so have at it! 
</p>

<h4><a name="s03_04_01_07">3.4.1.7 </a>Lathe</h4>
<a name="s03_04_01_07_i1"><a name="lathe"></a><a name="s03_04_01_07_i2"><a name="lathe, keyword"></a><a name="s03_04_01_07_i3"><a name="s03_04_01_07_i4"><a name="linear_spline, lathe"></a><a name="s03_04_01_07_i5"><a name="s03_04_01_07_i6"><a name="quadratic_spline, lathe"></a><a name="s03_04_01_07_i7"><a name="s03_04_01_07_i8"><a name="cubic_spline, lathe"></a><a name="s03_04_01_07_i9"><a name="s03_04_01_07_i10"><a name="bezier_spline, lathe"></a><a name="s03_04_01_07_i11"><a name="s03_04_01_07_i12"><a name="sturm, lathe"></a><a name="s03_04_01_07_i13">
<p>
  The <code>lathe</code> is an object generated from rotating a two-dimensional curve about an axis. This curve is 
 defined by a set of points which are connected by linear, quadratic, cubic or bezier spline curves. The syntax is: 
</p>

<pre>
LATHE:
    lathe
    {
        [SPLINE_TYPE] Number_Of_Points, &lt;Point_1&gt;
        &lt;Point_2&gt;... &lt;Point_n&gt;
        [LATHE_MODIFIER...]
    }
SPLINE_TYPE:
    linear_spline | quadratic_spline | cubic_spline | bezier_spline
LATHE_MODIFIER:
    sturm | OBJECT_MODIFIER
</pre>

<p>
  Lathe default values: <a name="s03_04_01_07_i14"> 
</p>

<pre>
SPLINE_TYPE   : linear_spline
sturm         : off
</pre>
<a name="s03_04_01_07_i15"><a name="linear_spline"></a>
<p>
  The first item is a keyword specifying the type of spline. The default if none is specified is <code>linear_spline</code>. 
 The required integer value <em><code>Number_Of_Points</code></em> specifies how many two-dimensional points are used 
 to define the curve. The points follow and are specified by 2-D vectors. The curve is not automatically closed, i.e. 
 the first and last points are not automatically connected. You will have to do this yourself if you want a closed 
 curve. The curve thus defined is rotated about the y-axis to form the lathe object, centered at the origin. 
</p>

<p>
  The following examples creates a simple lathe object that looks like a thick cylinder, i.e. a cylinder with a thick 
 wall: 
</p>

<pre>
 lathe {
  linear_spline
  5,
  &lt;2, 0&gt;, &lt;3, 0&gt;, &lt;3, 5&gt;, &lt;2, 5&gt;, &lt;2, 0&gt;
  pigment {Red}
 }
</pre>

<p>
  The cylinder has an inner radius of 2 and an outer radius of 3, giving a wall width of 1. It's height is 5 and it's 
 located at the origin pointing up, i.e. the rotation axis is the y-axis. 
</p>

<p class="Note">
  <strong>Note:</strong> the first and last point are equal to get a closed curve. 
</p>

<p>
  The splines that are used by the lathe and prism objects are a little bit difficult to understand. The basic 
 concept of splines is to draw a curve through a given set of points in a determined way. The default <code> 
 linear_spline</code> is the simplest spline because it's nothing more than connecting consecutive points with a line. 
 This means the curve that is drawn between two points only depends on those two points. No additional information is 
 taken into account. The other splines are different in that they do take other points into account when connecting two 
 points. This creates a smooth curve and, in the case of the cubic spline, produces smoother transitions at each point. 
</p>

<p>
  <a name="s03_04_01_07_i16"><a name="quadratic_spline"></a> The <code>quadratic_spline</code> keyword creates 
 splines that are made of quadratic curves. Each of them connects two consecutive points. Since those two points (call 
 them second and third point) are not sufficient to describe a quadratic curve, the predecessor of the second point is 
 taken into account when the curve is drawn. Mathematically, the relationship (their relative locations on the 2-D 
 plane) between the first and second point determines the slope of the curve at the second point. The slope of the 
 curve at the third point is out of control. Thus quadratic splines look much smoother than linear splines but the 
 transitions at each point are generally not smooth because the slopes on both sides of the point are different. 
</p>

<p>
  <a name="s03_04_01_07_i17"><a name="cubic_spline"></a> The <code>cubic_spline</code> keyword creates splines which 
 overcome the transition problem of quadratic splines because they also take a fourth point into account when drawing 
 the curve between the second and third point. The slope at the fourth point is under control now and allows a smooth 
 transition at each point. Thus cubic splines produce the most flexible and smooth curves. 
</p>

<p>
  <a name="s03_04_01_07_i18"><a name="bezier_spline"></a> The <code>bezier_spline</code> is an alternate kind of 
 cubic spline. Points 1 and 4 specify the end points of a segment and points 2 and 3 are control points which specify 
 the slope at the endpoints. Points 2 and 3 do not actually lie on the spline. They adjust the slope of the spline. If 
 you draw an imaginary line between point 1 and 2, it represents the slope at point 1. It is a line tangent to the 
 curve at point 1. The greater the distance between 1 and 2, the flatter the curve. With a short tangent the spline can 
 bend more. The same holds true for control point 3 and endpoint 4. If you want the spline to be smooth between 
 segments, points 3 and 4 on one segment and points 1 and 2 on the next segment must form a straight line and point 4 
 of one segment must be the same as point 1 on the next segment. 
</p>

<p>
  You should note that the number of spline segments, i. e. curves between two points, depends on the spline type 
 used. For linear splines you get n-1 segments connecting the points P[i], i=1,...,n. A quadratic spline gives you n-2 
 segments because the last point is only used for determining the slope, as explained above (thus you will need at 
 least three points to define a quadratic spline). The same holds for cubic splines where you get n-3 segments with the 
 first and last point used only for slope calculations (thus needing at least four points). The bezier spline requires 
 4 points per segment, creating n/4 segments. 
</p>

<p>
  If you want to get a closed quadratic and cubic spline with smooth transitions at the end points you have to make 
 sure that in the cubic case P[n-1] = P[2] (to get a closed curve), P[n] = P[3] and P[n-2] = P[1] (to smooth the 
 transition). In the quadratic case P[n-1] = P[1] (to close the curve) and P[n] = P[2]. 
</p>

<p>
  <a name="s03_04_01_07_i19"> The <code>sturm</code> keyword can be used to specify that the slower, but more 
 accurate, Sturmian root solver should be used. Use it, if the shape does not render properly. Since a quadratic 
 polynomial has to be solved for the linear spline lathe, the Sturmian root solver is not needed. 
</p>

<h4><a name="s03_04_01_08">3.4.1.8 </a>Prism</h4>
<a name="s03_04_01_08_i1"><a name="prism"></a><a name="s03_04_01_08_i2"><a name="prism, keyword"></a><a name="s03_04_01_08_i3"><a name="s03_04_01_08_i4"><a name="open, prism"></a><a name="s03_04_01_08_i5"><a name="s03_04_01_08_i6"><a name="linear_spline, prism"></a><a name="s03_04_01_08_i7"><a name="s03_04_01_08_i8"><a name="quadratic_spline, prism"></a><a name="s03_04_01_08_i9"><a name="s03_04_01_08_i10"><a name="cubic_spline, prism"></a><a name="s03_04_01_08_i11"><a name="s03_04_01_08_i12"><a name="bezier_spline, prism"></a><a name="s03_04_01_08_i13"><a name="s03_04_01_08_i14"><a name="linear_sweep, prism"></a><a name="s03_04_01_08_i15"><a name="s03_04_01_08_i16"><a name="conic_sweep, prism"></a><a name="s03_04_01_08_i17"><a name="s03_04_01_08_i18"><a name="sturm, prism"></a><a name="s03_04_01_08_i19">
<p>
  The <code>prism</code> is an object generated specifying one or more two-dimensional, closed curves in the x-z 
 plane and sweeping them along y axis. These curves are defined by a set of points which are connected by linear, 
 quadratic, cubic or bezier splines. The syntax for the prism is: 
</p>

<pre>
PRISM:
    prism
    {
        [PRISM_ITEMS...] Height_1, Height_2, Number_Of_Points,
        &lt;Point_1&gt;, &lt;Point_2&gt;, ... &lt;Point_n&gt;
        [ open ] [PRISM_MODIFIERS...]
    }
PRISM_ITEM:
    linear_spline | quadratic_spline | cubic_spline |
    bezier_spline | linear_sweep | conic_sweep
PRISM_MODIFIER:
    sturm | OBJECT_MODIFIER
</pre>

<p>
  Prism default values: <a name="s03_04_01_08_i20"> 
</p>

<pre>
SPLINE_TYPE   : linear_spline
SWEEP_TYPE    : linear_sweep
sturm         : off
</pre>
<a name="s03_04_01_08_i21"><a name="linear_sweep"></a>
<p>
  The first items specify the spline type and sweep type. The defaults if none is specified is <code>linear_spline</code> 
 and <code> linear_sweep</code>. This is followed by two float values <em><code> Height_1</code></em> and <em> <code>Height_2</code></em> 
 which are the y coordinates of the top and bottom of the prism. This is followed by a float value specifying the 
 number of 2-D points you will use to define the prism. (This includes all control points needed for quadratic, cubic 
 and bezier splines). This is followed by the specified number of 2-D vectors which define the shape in the x-z plane. 
</p>

<p>
  The interpretation of the points depends on the spline type. The prism object allows you to use any number of 
 sub-prisms inside one prism statement (they are of the same spline and sweep type). Wherever an even number of 
 sub-prisms overlaps a hole appears. 
</p>

<p class="Note">
  <strong>Note:</strong> you need not have multiple sub-prisms and they need not overlap as these 
 examples do. 
</p>

<p>
  In the <code>linear_spline</code> the first point specified is the start of the first sub-prism. The following 
 points are connected by straight lines. If you specify a value identical to the first point, this closes the sub-prism 
 and next point starts a new one. When you specify the value of that sub-prism's start, then it is closed. Each of the 
 sub-prisms has to be closed by repeating the first point of a sub-prism at the end of the sub-prism's point sequence. 
 In this example, there are two rectangular sub-prisms nested inside each other to create a frame. 
</p>

<pre>
 prism {
  linear_spline
  0, 1, 10,
  &lt;0,0&gt;, &lt;6,0&gt;, &lt;6,8&gt;, &lt;0,8&gt;, &lt;0,0&gt;,  //outer rim
  &lt;1,1&gt;, &lt;5,1&gt;, &lt;5,7&gt;, &lt;1,7&gt;, &lt;1,1&gt;   //inner rim
 }
</pre>

<p>
  The last sub-prism of a linear spline prism is automatically closed - just like the last sub-polygon in the polygon 
 statement - if the first and last point of the sub-polygon's point sequence are not the same. This make it very easy 
 to convert between polygons and prisms. Quadratic, cubic and bezier splines are never automatically closed. 
</p>

<p>
  In the <code> quadratic_spline</code>, each sub-prism needs an additional control point at the beginning of each 
 sub-prisms' point sequence to determine the slope at the start of the curve. The first point specified is the control 
 point which is not actually part of the spline. The second point is the start of the spline. The sub-prism ends when 
 this second point is duplicated. The next point is the control point of the next sub-prism. The point after that is 
 the first point of the second sub-prism. Here is an example: 
</p>

<pre>
 prism {
   quadratic_spline
   0, 1, 12,
   &lt;1,-1&gt;, &lt;0,0&gt;, &lt;6,0&gt;, //outer rim; &lt;1,-1&gt; is control point and 
   &lt;6,8&gt;, &lt;0,8&gt;, &lt;0,0&gt;,  //&lt;0,0&gt; is first &amp; last point

   &lt;2,0&gt;, &lt;1,1&gt;, &lt;5,1&gt;,  //inner rim; &lt;2,0&gt; is control point and 
   &lt;5,7&gt;, &lt;1,7&gt;, &lt;1,1&gt;   //&lt;1,1&gt; is first &amp; last point
 }
</pre>

<p>
  In the <code>cubic_spline</code>, each sub-prism needs two additional control points -- one at the beginning of 
 each sub-prisms' point sequence to determine the slope at the start of the curve and one at the end. The first point 
 specified is the control point which is not actually part of the spline. The second point is the start of the spline. 
 The sub-prism ends when this second point is duplicated. The next point is the control point of the end of the first 
 sub-prism. Next is the beginning control point of the next sub-prism. The point after that is the first point of the 
 second sub-prism. 
</p>

<p>
  Here is an example: 
</p>

<pre>
 prism {
   cubic_spline
   0, 1, 14,
   &lt;1,-1&gt;, &lt;0,0&gt;, &lt;6,0&gt;, //outer rim; First control is &lt;1,-1&gt; and
   &lt;6,8&gt;, &lt;0,8&gt;, &lt;0,0&gt;,  //&lt;0,0&gt; is first &amp; last point.
   &lt;-1,1&gt;,               //Last control of first spline is &lt;-1,1&gt;

   &lt;2,0&gt;, &lt;1,1&gt;, &lt;5,1&gt;,  //inner rim; First control is &lt;2,0&gt; and 
   &lt;5,7&gt;, &lt;1,7&gt;, &lt;1,1&gt;,  //&lt;1,1&gt; is first &amp; last point
   &lt;0,2&gt;                 //Last control of first spline is &lt;0,2&gt;
 }
</pre>
<a name="s03_04_01_08_i22"><a name="conic_sweep"></a>
<p>
  The <code>bezier_spline</code> is an alternate kind of cubic spline. Points 1 and 4 specify the end points of a 
 segment and points 2 and 3 are control points which specify the slope at the endpoints. Points 2 and 3 do not actually 
 lie on the spline. They adjust the slope of the spline. If you draw an imaginary line between point 1 and 2, it 
 represents the slope at point 1. It is a line tangent to the curve at point 1. The greater the distance between 1 and 
 2, the flatter the curve. With a short tangent the spline can bend more. The same holds true for control point 3 and 
 endpoint 4. If you want the spline to be smooth between segments, point 3 and 4 on one segment and point 1 and 2 on 
 the next segment must form a straight line and point 4 of one segment must be the same as point one on the next 
 segment. 
</p>

<p>
  By default linear sweeping is used to create the prism, i.e. the prism's walls are perpendicular to the x-z-plane 
 (the size of the curve does not change during the sweep). You can also use <code>conic_sweep</code> that leads to a 
 prism with cone-like walls by scaling the curve down during the sweep. 
</p>

<p>
  Like cylinders the prism is normally closed. You can remove the caps on the prism by using the <code>open</code> 
 keyword. If you do so you should not use it with CSG because the results may get wrong. 
</p>

<p>
  For an explanation of the spline concept read the description of the &quot;<a href="s_105.html#s03_04_01_07">Lathe</a>&quot; 
 object. Also see the tutorials on &quot;Lathe Object&quot; and &quot;Prism Object&quot;.<a name="s03_04_01_08_i23"> 
</p>

<p>
  The <code> sturm</code> keyword specifies the slower but more accurate Sturmian root solver which may be used with 
 the cubic or bezier spline prisms if the shape does not render properly. The linear and quadratic spline prisms do not 
 need the Sturmian root solver. 
</p>

<h4><a name="s03_04_01_09">3.4.1.9 </a>Sphere</h4>
<a name="s03_04_01_09_i1"><a name="sphere"></a><a name="s03_04_01_09_i2"><a name="sphere, keyword"></a><a name="s03_04_01_09_i3">
<p>
  The syntax of the <code>sphere</code> object is: 
</p>

<pre>
SPHERE:
    sphere
    {
        &lt;Center&gt;, Radius
        [OBJECT_MODIFIERS...]
    }
</pre>

<p>
  <br><center><img alt="The geometry of a sphere." src="images/reference/sphgeom.png"></center> 
</p>

<p>
  Where <em><code>&lt;Center&gt;</code></em> is a vector specifying the x, y, z coordinates of the center of the 
 sphere and <em><code> Radius</code></em> is a float value specifying the radius. Spheres may be scaled unevenly giving 
 an ellipsoid shape. 
</p>

<p>
  Because spheres are highly optimized they make good bounding shapes (if manual bounding seems to be necessary). 
</p>

<h4><a name="s03_04_01_10">3.4.1.10 </a>Sphere Sweep</h4>
<a name="s03_04_01_10_i1"><a name="b_spline"></a><a name="s03_04_01_10_i2"><a name="tolerance"></a><a name="s03_04_01_10_i3"><a name="sphere_sweep"></a><a name="s03_04_01_10_i4"><a name="sphere_sweep, keyword"></a><a name="s03_04_01_10_i5"><a name="s03_04_01_10_i6"><a name="linear_spline, sphere_sweep"></a><a name="s03_04_01_10_i7"><a name="s03_04_01_10_i8"><a name="b_spline, sphere_sweep"></a><a name="s03_04_01_10_i9"><a name="s03_04_01_10_i10"><a name="cubic_spline, sphere_sweep"></a><a name="s03_04_01_10_i11"><a name="s03_04_01_10_i12"><a name="tolerance, sphere_sweep"></a><a name="s03_04_01_10_i13">
<p>
  The syntax of the <code>sphere_sweep</code> object is: 
</p>

<pre>
SPHERE_SWEEP:
sphere_sweep {
  linear_spline | b_spline | cubic_spline
  NUM_OF_SPHERES,

  CENTER, RADIUS,
  CENTER, RADIUS,
  ...
  CENTER, RADIUS
  [tolerance DEPTH_TOLERANCE]
  [OBJECT_MODIFIERS]
}
</pre>

<p>
  Sphere_sweep default values: <a name="s03_04_01_10_i14"> 
</p>

<pre>
tolerance : 1.0e-6 (0.000001) 
</pre>

<p>
  A Sphere Sweep is the envelope of a moving sphere with varying radius, or, in other words, the space a sphere 
 occupies during its movement along a spline. <br>Sphere Sweeps are modeled by specifying a list of single spheres 
 which are then interpolated. <br>Three kinds of interpolation are supported: 
</p>

<ul>
 
 <li>
   <code>linear_spline</code> : Interpolating the input data with a linear function, which means that the single 
  spheres are connected by straight tubes. 
 </li>

 <li>
   <code>b_spline</code> : Approximating the input data using a cubic b-spline function, which results in a curved 
  object. 
 </li>

 <li>
   <code>cubic_spline</code> : Approximating the input data using a cubic spline, which results in a curved object. 
 </li>

</ul>

<p>
  The sphere list (center and radius of each sphere) can take as many spheres as you like to describe the object, but 
 you will need at least two spheres for a <code>linear_spline</code>, and four spheres for <code>b_spline</code> or <code>cubic_spline</code>. 
 
</p>

<p>
  Optional: The depth tolerance that should be used for the intersection calculations. This is done by adding the <code>tolerance</code> 
 keyword and the desired value: the default distance is 1.0e-6 (0.000001) and should do for most sphere sweep objects. <br>You 
 should change this when you see dark spots on the surface of the object. These are probably caused by an effect called 
 &quot;Self-Shading&quot;. This means that the object casts shadows onto itself at some points because of calculation 
 errors. A ray tracing program usually defines the minimal distance a ray must travel before it actually hits another 
 (or the same) object to avoid this effect. If this distance is chosen too small, Self-Shading may occur. <br>If so, 
 specify <code>tolerance 1.0e-4</code> or higher. 
</p>

<p class="Note">
  <strong>Note:</strong> if these dark spots remain after raising the tolerance, you might get rid of 
 these spots by using Adaptive Supersampling (Method 2) for antialiasing. Images look better with antialiasing anyway. 
</p>

<p class="Note">
  <strong>Note:</strong> the merge CSG operation is not recommended with Sphere Sweeps: there could be a 
 small gap between the merged objects! 
</p>

<h4><a name="s03_04_01_11">3.4.1.11 </a>Superquadric Ellipsoid</h4>
<a name="s03_04_01_11_i1"><a name="superquadric"></a><a name="s03_04_01_11_i2"><a name="superellipsoid"></a><a name="s03_04_01_11_i3"><a name="superellipsoid, keyword"></a><a name="s03_04_01_11_i4">
<p>
  The <code>superellipsoid</code> object creates a shape known as a <em> superquadric ellipsoid</em> object. It is an 
 extension of the quadric ellipsoid. It can be used to create boxes and cylinders with round edges and other 
 interesting shapes. Mathematically it is given by the equation: 
</p>

<p>
  <br><center><img alt="" src="images/reference/sqemath.png"></center> 
</p>

<p>
  The values of <em><code>e</code></em> and <em><code>n</code></em>, called the <em>east-west</em> and <em>north-south</em> 
 exponent, determine the shape of the superquadric ellipsoid. Both have to be greater than zero. The sphere is given by <em>e 
 = 1</em> and <em>n = 1</em>. 
</p>

<p>
  The syntax of the superquadric ellipsoid is: 
</p>

<pre>
SUPERELLIPSOID:
    superellipsoid
    {
        &lt;Value_E, Value_N&gt;
        [OBJECT_MODIFIERS...]
    }
</pre>

<p>
  The 2-D vector specifies the <em><code>e</code></em> and <em><code> n</code></em> values in the equation above. The 
 object sits at the origin and occupies a space about the size of a <code> box{&lt;-1,-1,-1&gt;,&lt;1,1,1&gt;}</code>. 
</p>

<p>
  Two useful objects are the rounded box and the rounded cylinder. These are declared in the following way. 
</p>

<pre>
 #declare Rounded_Box = superellipsoid { &lt;Round, Round&gt; }
 #declare Rounded_Cylinder = superellipsoid { &lt;1, Round&gt; }
</pre>

<p>
  The roundedness value <code>Round</code> determines the roundedness of the edges and has to be greater than zero 
 and smaller than one. The smaller you choose the values, the smaller and sharper the edges will get. 
</p>

<p>
  Very small values of <em><code>e</code></em> and <em><code>n</code></em> might cause problems with the root solver 
 (the Sturmian root solver cannot be used). 
</p>

<h4><a name="s03_04_01_12">3.4.1.12 </a>Surface of Revolution</h4>
<a name="s03_04_01_12_i1"><a name="sor"></a><a name="s03_04_01_12_i2"><a name="sor, keyword"></a><a name="s03_04_01_12_i3"><a name="s03_04_01_12_i4"><a name="open, sor"></a><a name="s03_04_01_12_i5"><a name="s03_04_01_12_i6"><a name="sturm, sor"></a><a name="s03_04_01_12_i7">
<p>
  The <code>sor</code> object is a <em>surface of revolution</em> generated by rotating the graph of a function about 
 the y-axis. This function describes the dependence of the radius from the position on the rotation axis. The syntax 
 is: 
</p>

<pre>
SOR:
    sor
    {
        Number_Of_Points, &lt;Point_1&gt;, &lt;Point_2&gt;, ... &lt;Point_n&gt;
        [ open ] [SOR_MODIFIERS...]
    }
SOR_MODIFIER:
    sturm | OBJECT_MODIFIER
</pre>

<p>
  SOR default values: <a name="s03_04_01_12_i8"> 
</p>

<pre>
sturm : off
</pre>

<p>
  The float value <em><code>Number_Of_Points</code></em> specifies the number of 2-D vectors which follow. The points <em><code> 
 &lt;Point_1&gt;</code></em> through <em><code>&lt;Point_n&gt;</code></em> are two-dimensional vectors consisting of 
 the radius and the corresponding height, i.e. the position on the rotation axis. These points are smoothly connected 
 (the curve is passing through the specified points) and rotated about the y-axis to form the SOR object. The first and 
 last points are only used to determine the slopes of the function at the start and end point. They do not actually lie 
 on the curve. The function used for the SOR object is similar to the splines used for the lathe object. The difference 
 is that the SOR object is less flexible because it underlies the restrictions of any mathematical function, i.e. to 
 any given point y on the rotation axis belongs at most one function value, i.e. one radius value. You cannot rotate 
 closed curves with the SOR object. Also, make sure that the curve does not cross zero (y-axis) as this can result in 
 'less than perfect' bounding cylinders. POV-Ray will very likely fail to render large chunks of the part of the spline 
 contained in such an interval. 
</p>

<p>
  The optional keyword <code> open</code> allows you to remove the caps on the SOR object. If you do this you should 
 not use it with CSG because the results may be wrong. 
</p>

<p>
  The SOR object is useful for creating bottles, vases, and things like that. A simple vase could look like this: 
</p>

<pre>
 #declare Vase = sor {
  7,
  &lt;0.000000, 0.000000&gt;
  &lt;0.118143, 0.000000&gt;
  &lt;0.620253, 0.540084&gt;
  &lt;0.210970, 0.827004&gt;
  &lt;0.194093, 0.962025&gt;
  &lt;0.286920, 1.000000&gt;
  &lt;0.468354, 1.033755&gt;
  open
 }
</pre>

<p>
  One might ask why there is any need for a SOR object if there is already a lathe object which is much more 
 flexible. The reason is quite simple. The intersection test with a SOR object involves solving a cubic polynomial 
 while the test with a lathe object requires to solve a 6th order polynomial (you need a cubic spline for the same 
 smoothness). Since most SOR and lathe objects will have several segments this will make a great difference in speed. 
 The roots of the 3rd order polynomial will also be more accurate and easier to find. 
</p>

<p>
  <a name="s03_04_01_12_i9"> The <code>sturm</code> keyword may be added to specify the slower but more accurate 
 Sturmian root solver. It may be used with the surface of revolution object if the shape does not render properly. 
</p>

<p>
  The following explanations are for the mathematically interested reader who wants to know how the surface of 
 revolution is calculated. Though it is not necessary to read on it might help in understanding the SOR object. 
</p>

<p>
  The function that is rotated about the y-axis to get the final SOR object is given by 
</p>

<p>
  <br><center><img alt="" src="images/reference/sormath.png"></center> 
</p>

<p>
  with radius <em><code>r</code></em> and height <em><code>h</code></em>. Since this is a cubic function in h it has 
 enough flexibility to allow smooth curves. 
</p>

<p>
  The curve itself is defined by a set of n points P(i), i=0...n-1, which are interpolated using one function for 
 every segment of the curve. A segment j, j=1...n-3, goes from point P(j) to point P(j+1) and uses points P(j-1) and 
 P(j+2) to determine the slopes at the endpoints. If there are n points we will have n-3 segments. This means that we 
 need at least four points to get a proper curve. The coefficients A(j), B(j), C(j) and D(j) are calculated for every 
 segment using the equation 
</p>

<p>
  <br><center><img alt="" src="images/reference/curvmath.png"></center> 
</p>

<p>
  where r(j) is the radius and h(j) is the height of point P(j). 
</p>

<p>
  The figure below shows the configuration of the points P(i), the location of segment j, and the curve that is 
 defined by this segment. 
</p>

<p>
  <br><center><img alt="Points on a surface of revolution." src="images/reference/segmpts.png"></center> 
</p>

<h4><a name="s03_04_01_13">3.4.1.13 </a>Text</h4>
<a name="s03_04_01_13_i1"><a name="text"></a><a name="s03_04_01_13_i2"><a name="text, keyword"></a><a name="s03_04_01_13_i3"><a name="s03_04_01_13_i4"><a name="ttf, text"></a><a name="s03_04_01_13_i5"><a name="s03_04_01_13_i6"><a name="ttf"></a>
<p>
  A <code>text</code> object creates 3-D text as an extruded block letter. Currently only TrueType fonts (ttf) and 
 TrueType Collections (ttc) are supported but the syntax allows for other font types to be added in the future. If 
 TrueType Collections are used, the first font found in the collection will be used. The syntax is: 
</p>

<pre>
TEXT_OBECT:
  text {
    ttf &quot;fontname.ttf/ttc&quot; &quot;String_of_Text&quot;
	Thickness, &lt;Offset&gt;
    [OBJECT_MODIFIERS...]
  }
</pre>

<p>
  Where <code>fontname.ttf</code> or <code>fontname.ttc</code> is the name of the TrueType font file. It is a quoted 
 string literal or string expression. The string expression which follows is the actual text of the string object. It 
 too may be a quoted string literal or string expression. See section &quot;<a href="#l132">Strings</a>&quot; for more 
 on string expressions. 
</p>

<p>
  The text will start with the origin at the lower left, front of the first character and will extend in the 
 +x-direction. The baseline of the text follows the x-axis and descender drop into the -y-direction. The front of the 
 character sits in the x-y-plane and the text is extruded in the +z-direction. The front-to-back thickness is specified 
 by the required value <em><code> Thickness</code></em>. 
</p>

<p>
  Characters are generally sized so that 1 unit of vertical spacing is correct. The characters are about 0.5 to 0.75 
 units tall. 
</p>

<p>
  The horizontal spacing is handled by POV-Ray internally including any kerning information stored in the font. The 
 required vector <em><code> &lt;Offset&gt;</code></em> defines any extra translation between each character. Normally 
 you should specify a zero for this value. Specifying <code>0.1*x</code> would put additional 0.1 units of space 
 between each character. Here is an example: 
</p>

<pre>
  text {
    ttf &quot;timrom.ttf&quot; &quot;POV-Ray&quot; 1, 0
    pigment { Red }
  }
</pre>

<p>
  Only printable characters are allowed in text objects. Characters such as return, line feed, tabs, backspace etc. 
 are not supported. 
</p>

<p>
  For easy access to your fonts, set the <a href="s_95.html#s03_01_02_05_04">Library_Path</a> to the directory that 
 contains your font collection. 
</p>

<h4><a name="s03_04_01_14">3.4.1.14 </a>Torus</h4>
<a name="s03_04_01_14_i1"><a name="torus"></a><a name="s03_04_01_14_i2"><a name="torus, keyword"></a><a name="s03_04_01_14_i3"><a name="s03_04_01_14_i4"><a name="s03_04_01_14_i5">
<p>
  A <code>torus</code> is a 4th order quartic polynomial shape that looks like a donut or inner tube. Because this 
 shape is so useful and quartics are difficult to define, POV-Ray lets you take a short-cut and define a torus by: 
</p>

<pre>
TORUS:
    torus
    {
        Major, Minor
        [TORUS_MODIFIER...]
    }
TORUS_MODIFIER:
    sturm | OBJECT_MODIFIER
</pre>

<p>
  Torus default values: <a name="s03_04_01_14_i6"> 
</p>

<pre>
sturm : off
</pre>

<p>
  where <em><code>Major</code></em> is a float value giving the major radius and <em><code>Minor</code></em> is a 
 float specifying the minor radius. The major radius extends from the center of the hole to the mid-line of the rim 
 while the minor radius is the radius of the cross-section of the rim. The torus is centered at the origin and lies in 
 the x-z-plane with the y-axis sticking through the hole. 
</p>

<p>
  <br><center><img alt="Major and minor radius of a torus." src="images/reference/mimxrtor.png"></center> 
</p>

<p>
  The torus is internally bounded by two cylinders and two rings forming a thick cylinder. With this bounding 
 cylinder the performance of the torus intersection test is vastly increased. The test for a valid torus intersection, 
 i.e. solving a 4th order polynomial, is only performed if the bounding cylinder is hit. Thus a lot of slow root 
 solving calculations are avoided. 
</p>

<p>
  <a name="s03_04_01_14_i7"> Calculations for all higher order polynomials must be very accurate. If the torus 
 renders improperly you may add the keyword <code> sturm</code> to use POV-Ray's slower-yet-more-accurate Sturmian root 
 solver. 
</p>

<p>
 <a name="l132">
<small><strong>More about &quot;Strings&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_155.html#s03_08_03_05">3.8.3.5 Strings</a> in 3.8.3 Language Basics
  </small>

  <li><small>
   <a href="s_97.html#s03_02_01_07">3.2.1.7 Strings</a> in 3.2.1 Language Basics
  </small>

 </ul>

</p>
 <br> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_104.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_104.html">3.4 Objects</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong>3.4.1 Finite Solid Primitives</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_106.html">3.4.2 Finite Patch Primitives</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_106.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 </body> </html>