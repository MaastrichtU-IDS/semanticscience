
<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2003-2004  -->
<html> 
<head>
  
<!--  NOTE: In order to users to help find information about POV-Ray using  -->
 
<!--  web search engines, we ask you to *not* let them index documentation  -->
 
<!--  mirrors because effectively, when searching, users will get hundreds  -->
 
<!--  of results containing the same information! For this reason, the two  -->
 
<!--  meta tags below disable archiving and indexing of this page by all  -->
 
<!--  search engines that support these meta tags.  -->
 
 <meta content="noarchive" name="robots">
   
 <meta content="noindex" name="robots">
   
 <meta content="no-cache" http-equiv="Pragma">
   
 <meta content="0" http-equiv="expires">
   
<title>2.3.9 While-loop tutorial</title>
 <link href="povray35.css" rel="stylesheet" type="text/css"> 
</head>
 <body> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_73.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_73.html">2.3.8 Making Animations</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong class="NavBar">POV-Ray 3.6 for UNIX documentation</strong><br> <strong>2.3.9 
   While-loop tutorial</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_75.html">2.3.10 SDL tutorial: A raytracer</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_75.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 
<h3><a name="s02_03_09">2.3.9 </a>While-loop tutorial</h3>

<p>
  Usually people who have never programmed have great difficulties understanding how simple while-loops work and how 
 they should be used. When you get into nested loops, the problem is even worse. 
</p>

<p>
  Sometimes even people who have programmed a bit with some language get confused with POV-Ray's while-loops. This 
 usually happens when they have only used a for-loop which in itself has an index variable (which is often even 
 incremented automatically). 
</p>

<h4><a name="s02_03_09_01">2.3.9.1 </a>What a while-loop is and what it is not</h4>

<p>
  A while-loop in POV-Ray is just a control structure which tells POV-Ray to loop a command block while the specified 
 condition is true (ie. until it gets false). 
</p>

<p>
  That is, a while-loop is like this: 
</p>

<pre>
#while(condition)
  ...
#end
</pre>

<p>
  The commands between <code>#while</code> and <code>#end</code> are run over and over as long as the condition 
 evaluates to true. 
</p>

<p>
  A while-loop <strong>is not</strong> a for-loop nor any kind of loop which has an index variable by itself (which 
 may be incremented automatically in each loop). 
</p>

<p>
  The while-loop <strong>does not</strong> care what the conditions are between the parentheses (as long as they 
 evaluate to some value) or what does the block between <code>#while</code> and <code>#end</code> contain. It will just 
 execute that block until the condition becomes false. 
</p>

<p>
  The while-loop does not do anything else. You can think about it as a kind of &quot;dumb&quot; loop, which does not 
 do anything automatically (and this is not necessarily a bad thing). 
</p>

<h4><a name="s02_03_09_02">2.3.9.2 </a>How does a single while-loop work?</h4>

<p>
  The while-loop works like this: 
</p>

<ol>
 
 <li>
   If the condition between the parentheses evaluates to false, jump to the command after the <code>#end</code> 
  statement. If the condition evaluates to true, just continue normally. 
 </li>

 <li>
   At the <code>#end</code> statement jump to the <code>#while</code> statement and start again. 
 </li>

</ol>

<p>
  That is: 
</p>

<ul>
 
 <li>
   When POV-Ray gets to the <code>#while</code> statement it evaluates the condition between parentheses. 
 </li>

 <li>
   If the statement evaluated to true then it will just continue normally with the next command. 
 </li>

 <li>
   However, if the statement evaluated to false, POV-Ray will skip the entire body of the loop and continue from the 
  command after the <code>#end</code> statement. 
 </li>

 <li>
   At an <code>#end</code> statement POV-Ray will just jump back to the corresponding <code>#while</code>-statement 
  and then continue normally (ie. testing the condition and so on). 
 </li>

</ul>

<p>
  Note that nowhere there is any mention about any index variable or anything else that could be used to 
 automatically end the loop or whatever. As said, it is just a &quot;dumb&quot; loop that continues forever if 
 necessary, only testing the statement between the parentheses (but it is not interested in what it is, only in its 
 evaluated value). 
</p>

<p>
  Although one could easily think that this kind of &quot;dumb&quot; loop is bad and it should be more 
 &quot;intelligent&quot; and better, the fact is that this kind of &quot;dumb&quot; loop is actually a lot more 
 flexible and versatile. It allows you to make things not possible or very difficult to do with an 
 &quot;intelligent&quot; for-loop with automatic index variables. 
</p>

<h4><a name="s02_03_09_03">2.3.9.3 </a>How do I make a while-loop?</h4>

<p>
  It depends on what you are trying to make. 
</p>

<p>
  The most common usage is to use it as a simple for-loop, that is, a loop which loops a certain number of times (for 
 example 10 times) with an index value getting successive values (for example 1, 2, 3, ..., 10). 
</p>

<p>
  For this you need to first declare your index identifier with the first value. For example: 
</p>

<pre>
#declare Index = 1;
</pre>

<p>
  Now you want to loop 10 times. Remember how the condition worked: The while-loop loops as long as the condition is 
 true. So it should loop as long as our 'Index' identifier is less or equal to 10: 
</p>

<pre>
#while(Index &lt;= 10)
</pre>

<p>
  When the 'Index' gets the value 11 the loop ends, as it should. 
</p>

<p>
  Now we only have to add 1 to 'Index' at each loop, so we should do it at the end of the loop, thus getting: 
</p>

<pre>
#declare Index = 1;
#while(Index &lt;= 10)

  (some commands here)

  #declare Index = Index + 1;
#end
</pre>

<p>
  The incrementation before the <code>#end</code> is important. If we do not do it, 'Index' would always have the 
 value 1 and the loop would go forever since 1 is always less or equal to 10. 
</p>

<p>
  What happens here? 
</p>

<ol>
 
 <li>
   First POV-Ray sets the value 1 to 'Index'. 
 </li>

 <li>
   Then it sees the <code>#while</code> statement and evaluates what is between the parentheses: Index &lt;= 10 
 </li>

 <li>
   As 'Index' has the value of 1 and 1 &lt;= 10, the condition evaluates to true. 
 </li>

 <li>
   So, it just continues normally. It executes the commands following the <code>#while</code> statement (denoted in 
  the above example as &quot;(some commands here)&quot;). 
 </li>

 <li>
   Then it arrives normally to the last #declare command in the block. This causes the value 2 to be assigned to 
  'Index'. 
 </li>

 <li>
   Now it arrives the the <code>#end</code> command and so it just jumps to the <code>#while</code>. 
 </li>

 <li>
   After that it executes the steps 2-6 again because also 2 is less or equal to 10. 
 </li>

 <li>
   After this has been done 10 times, the value 11 is assigned to 'Index' in the last command of the block. 
 </li>

 <li>
   Now, when POV-Ray evaluates the condition it sees that it is false (because 11 is not less or equal to 10). This 
  causes POV-Ray to jump to the command after the <code>#end</code> statement. 
 </li>

 <li>
   The net effect of all this is that POV-Ray looped 10 times and the 'Index' variable got successive values from 1 
  to 10 along the way. 
 </li>

</ol>

<p>
  If you read carefully the above description you will notice that the looping is done in a quite &quot;dumb&quot; 
 way, that is, there is no higher logic hidden inside the loop structure. In fact, POV-Ray does not have the slightest 
 idea how many times the loop is executed and what variable is used to count the loops. It just follows orders. 
</p>

<p>
  The higher logic in this type of loop is in the combination of commands we wrote. The effect of this combination is 
 that the loop works like a simple for-loop in most programming languages (like BASIC, etc). 
</p>

<h4><a name="s02_03_09_04">2.3.9.4 </a>What is a condition and how do I make one?</h4>

<p>
  A condition is an expression that evaluates to a boolean value (ie. true or false) and is used in POV-Ray in <code>#while</code>-loops 
 and <code>#if</code>-statements. 
</p>

<p>
  A condition is mainly a comparison between two values (although there are also some other ways of making a 
 condition, but that is not important now). For example: 
</p>

<pre>
1 &lt; 2  is true
1 &gt; 2  is false
1 = 1  is true
1 = 2  is false

and so on.
</pre>

<p>
  Usually it makes no sense to make comparisons like those. However, when comparing identifiers with some value or 
 two identifiers together it starts to be very useful. Consider this: 
</p>

<pre>
#if(version &lt; 3.1)
  #error &quot;Wrong version!&quot;
#end
</pre>

<p>
  If the identifier called 'version' has a value which is less than 3.1 the <code>#error</code> line will be 
 executed. If 'version' has a value which is 3.1 or greater, the <code>#error</code> line is just skipped. 
</p>

<p>
  You can combine conditions together with the boolean operators &amp; (and) and | (or). You can also invert the 
 value of a condition with ! (not). 
</p>

<p>
  For example, if you want something to be done when 'a' is less than 10 <strong>and</strong> 'b' is greater or equal 
 to 20, the condition would be: 
</p>

<pre>
a&lt;10 &amp; b&gt;=20
</pre>

<p>
  For more information about these comparison operators, see the <a href="s_97.html#s03_02_01_03_03">'Float operators'</a> 
 section of the POV-Ray documentation. 
</p>

<h4><a name="s02_03_09_05">2.3.9.5 </a>What about loop types other than simple for-loops?</h4>

<p>
  As POV-Ray does not care what the condition is and what we are using to make that condition, we can use the 
 while-loop in many other ways. 
</p>

<p>
  For example, this is a typical use of the while-loop which is not a simple for-loop: 
</p>

<pre>
#declare S = seed(0);
#declare Point = &lt;2*rand(S)-1, 2*rand(S)-1, 2*rand(S)-1&gt;;
#while(vlength(Point) &gt; 1)
  #declare Point = &lt;2*rand(S)-1, 2*rand(S)-1, 2*rand(S)-1&gt;;
#end
</pre>

<p>
  What we are doing here is this: Take a random point between &lt;-1, -1, -1&gt; and &lt;1, 1, 1&gt; and if it is not 
 inside the unit sphere take another random point in that range. Do this until we get a point inside the unit sphere. 
</p>

<p>
  This is not an unrealistic example since it is very handy. 
</p>

<p>
  As we see, this has nothing to do with an ordinary for-loop: 
</p>

<ul>
 
 <li>
   It does not have any &quot;index&quot; value which gets consecutive values during the loop. 
 </li>

 <li>
   We do not know how many times it will loop. In this case it loops a random number of times. 
 </li>

 <li>
   For-loops are usually used to get a series of things (eg. objects). At each loop another instance of that thing 
  is created. Here, however, we are only interested in the value that results <strong>after</strong> the loop, not the 
  values inside it. 
 </li>

</ul>

<p>
  As we can see, a while-loop can also be used for a task of type &quot;calculate a value or some values until the 
 result is inside a specified range&quot; (among many other tasks). 
</p>

<p>
  By the way, there is a variant of this kind of loop where the task is: &quot;Calculate a value until the result is 
 inside a specified range, but make only a certain number of tries. If the value does not get inside that range after 
 that number of tries, stop trying&quot;. This is used when there is a possibility for the loop for going on forever. 
</p>

<p>
  In the above example about the point inside the unit sphere we do not need this because the random point will 
 surely hit the inside of the sphere at some time. In some other situations, however, we cannot be so sure. 
</p>

<p>
  In this case we need a regular index variable to count the number of loops. If we have made that amount of loops 
 then we stop. 
</p>

<p>
  Suppose that we wanted to modify our point searching program to be completely safe and to try only up to 10 times. 
 If the point does not hit the inside of the sphere after 10 tries, we just give up and take the point &lt;0,0,0&gt;. 
</p>

<pre>
#declare S = seed(0);
#declare Point = &lt;2*rand(S)-1, 2*rand(S)-1, 2*rand(S)-1&gt;;
#declare Index = 1;
#while(Index &lt;= 10 &amp; vlength(Point) &gt; 1)
  #declare Point = &lt;2*rand(S)-1, 2*rand(S)-1, 2*rand(S)-1&gt;;
  #declare Index = Index + 1;
#end

#if(vlength(Point) &gt; 1)
  #declare Point = &lt;0,0,0&gt;
#end
</pre>

<p>
  What did we do? 
</p>

<ul>
 
 <li>
   We added an 'Index' value which counts the amount of loops gone so far. It is quite similar to the index loop of 
  a simple for-loop. 
 </li>

 <li>
   We added an extra condition to the while-loop: Besides testing that the point is outside the unit sphere it also 
  tests that our index variable has not bailed out. So now there are two conditions for the loop to continue: The 
  'Index' value must be less or equal to 10 <strong>and</strong> the 'Point' has to be outside the unit sphere. If 
  either one of them fails, the loop is ended. 
 </li>

 <li>
   Then we check if the point is still outside the unit sphere. If it is, we just take &lt;0,0,0&gt;. 
 </li>

</ul>

<p>
  Btw, sometimes it is not convenient to make the test again in the <code>#if</code> statement. There is another way 
 of determining whether the loop bailed out without successful termination or not: Since the loop ends when the 'Index' 
 gets the value 11, we can use this to test the successfulness of the loop: 
</p>

<pre>
#if(Index = 11)
  (loop was not successful)
#end
</pre>

<h4><a name="s02_03_09_06">2.3.9.6 </a>What about nested loops?</h4>

<p>
  Even when one masters simple loops, nested loops can be a frightening thing (or at least hard to understand). 
</p>

<p>
  Nested loops are used for example for creating a 2D array of objects (with rows and columns of objects), etc. For 
 example if you want to create a 10x20 array of spheres in your scene, a nested loop is the tool for it. 
</p>

<p>
  There is nothing special about nested loops. You only have to pay attention to where you initialize and update your 
 index variables. 
</p>

<p>
  Let's recall the form of a simple for-loop: 
</p>

<pre>
#declare Index = initial_value;
#while(Index &lt;= final_value)

  [Something here]

  #declare Index = Index + index_step;
#end
</pre>

<p>
  The [Something here] part can be anything. If it is another while-loop, then we have nested loops. The inner loop 
 should have the same structure as the outer one. 
</p>

<p>
  Note that proper indentation helps us distinguishing between the loops. It is always a good idea to use a good 
 indentation scheme: 
</p>

<pre>
#declare Index1 = initial_value1;
#while(Index1 &lt;= final_value1)

   #declare Index2 = initial_value2;
   #while(Index2 &lt;= final_value2)

      [Something here]

      #declare Index2 = Index2 + index2_step;
   #end

   #declare Index1 = Index1 + index1_step;
#end
</pre>

<p>
  It is a common mistake for beginners to break this structure. For example it is common to declare the 'Index2' 
 before the first <code>#while</code>. This breaks the for-loop structure and thus does not work. If you follow step by 
 step what POV-Ray does, as explained earlier, you will see why it does not work. Do not mix the structures of the 
 inner and the outer loops together or your code will simply not work as expected. 
</p>

<p>
  So, if we want to make our 10x20 array of spheres, it will look like this: 
</p>

<pre>
#declare Index1 = 0;
#while(Index1 &lt;= 9)

   #declare Index2 = 0;
   #while(Index2 &lt;= 19)

      sphere { &lt;Index1, Index2, 0&gt;, .5 }

      #declare Index2 = Index2 + 1;
   #end

   #declare Index1 = Index1 + 1;
#end
</pre>

<p>
  Note how we now start from 0 and continue to 9 in the outer loop and from 0 to 19 in the inner loop. This has been 
 done to get the sphere array start from the origin (instead of starting from &lt;1, 1, 0&gt;). Of course we could have 
 made the 'Index1' and 'Index2' go from 1 to 10 and from 1 to 20 respectively and then created the sphere in this way: 
</p>

<pre>
  sphere { &lt;Index1-1, Index2-1, 0&gt;, .5 }
</pre>

<p>
  Although you should not mix the loop structures together, you can perfectly use the values of the outer loop in the 
 inner loop (eg. in its condition). For example, if we wanted to create a triangular array of spheres instead of a 
 rectangular one (that is, we create only half of the spheres), we could have made the inner <code>#while</code> like 
 this: 
</p>

<pre>
  #while(Index2 &lt; Index1*2)
</pre>

<p>
  ('Index2' will go from 0 to the value of 'Index1' multiplied by 2.) 
</p>

<p>
  There is no reason why we should limit ourselves to just two nested loops. There is virtually no limit how many 
 loops you can nest. For example, if we wanted to create a box-shape filled by spheres rows, colums and depth, we just 
 make three nested loops, one for the x-axis, another for the y-axis and the third for the z-axis. 
</p>

<h4><a name="s02_03_09_07">2.3.9.7 </a>Mixed-type nested loops</h4>

<p>
  It is perfectly possible to put a for-loop inside a non-for-loop or vice-versa. Again, you just have to be careful 
 (with experience it gets easier). 
</p>

<p>
  For example, suppose that we want to create 50 spheres which are randomly placed inside the unit sphere. 
</p>

<p>
  So the distinction is clear: First we need a loop to create 50 spheres (a for-loop type suffices) and then we need 
 another loop inside it to calculate the location of the sphere. It will look like this: 
</p>

<pre>
#declare S = seed(0);
#declare Index = 1;
#while(Index &lt;= 50)

   #declare Point = &lt;2*rand(S)-1, 2*rand(S)-1, 2*rand(S)-1&gt;;
   #while(vlength(Point) &gt; 1)
      #declare Point = &lt;2*rand(S)-1, 2*rand(S)-1, 2*rand(S)-1&gt;;
   #end

   sphere { Point, .1 }

   #declare Index = Index + 1;
#end
</pre>

<p>
  There are some important things to note in this specific example: 
</p>

<ul>
 
 <li>
   Although this is a nested loop, the sphere is not created in the inner loop but in the outer one. The reason is 
  clear: We want to create 50 spheres, so the sphere creation has to be inside the loop that counts to 50. The inner 
  loop just calculates an appropriate location. 
 </li>

 <li>
   The seed value 'S' is declared outside all the loops although it is used only in the inner loop. Can you guess 
  why? (Putting it inside the outer loop would have caused an undesired result: Which one?) 
 </li>

</ul>

<h4><a name="s02_03_09_08">2.3.9.8 </a>Other things to note</h4>

<p>
  There is no reason why the index value in your simple for-loop should step one unit at a time. Since the while-loop 
 does not care how the index changes, you can change it in whichever way you want. Eg: 
</p>

<pre>
#declare Index = Index - 1;  Decrements the index (be careful with the
                             while loop condition)

#declare Index = Index + 0.2;  Increases by steps of 0.2

#declare Index = Index * 2;  Doubles the value of the index at each step.

etc.
</pre>

<p>
  - Be careful <strong>where</strong> you put your while-loop. 
</p>

<p>
  I have seen this kind of mistake more than once: 
</p>

<pre>
#declare Index = 1;
#while(Index &lt;= 10)
   blob
   {  threshold 0.6
      sphere { &lt;Index, 0, 0&gt;, 2, 1 }
   }
   #declare Index = Index + 1;
#end
</pre>

<p>
  You will probably see immediately the problem. 
</p>

<p>
  This code creates 10 blobs with one component each. It does not seem to make much sense. Most probably the user 
 wanted to make one blob with 10 components. 
</p>

<p>
  Why did this mistake happen? It may be that the user (more or less subconsciously) thought that the while-loop must 
 be the outermost control structure and does not realize that while-loops can be anywhere, also inside objects 
 (creating subcomponents or whatever). 
</p>

<p>
  The correct code is, of course: 
</p>

<pre>
blob
{  threshold 0.6

   #declare Index = 1;
   #while(Index &lt;= 10)

      sphere { &lt;Index, 0, 0&gt;, 2, 1 }

      #declare Index = Index + 1;
   #end
}
</pre>

<p>
  The essential difference here is that it is only the sphere code which is run 10 times instead of the whole blob 
 code. The net result is the same as if we had written the sphere code 10 times with proper values of 'Index'. 
</p>

<p>
  Be also careful with the placement of the braces. If you put them in the wrong place you can end up accidentally 
 repeating an opening or a closing brace 10 times. Again, a proper indentation usually helps a lot with this (as seen 
 in the above example). 
</p>

<p>
  - Tip: You can use while-loops in conjunction with arrays to automatize the creation of long lists of elements with 
 differing data. 
</p>

<p>
  Imagine that you are making something like this: 
</p>

<pre>
  color_map
  {  [0.00 rgb &lt;.1,1,.6&gt;]
     [0.05 rgb &lt;.8,.3,.6&gt;]
     [0.10 rgb &lt;.3,.7,.9&gt;]
     [0.15 rgb &lt;1,.7,.3&gt;]
     ...
     and so on
</pre>

<p>
  It is tedious to have to write the same things over and over just changing the index value and the values in the 
 vector (even if you use copy-paste to copy the lines). 
</p>

<p>
  There is also one very big problem here: If you ever want to add a new color to the color map or remove a color, 
 you would have to renumber all the indices again, which can be extremely tedious and frustrating. 
</p>

<p>
  Would not it be nice to automatize the creation of the color map so that you only have to write the vectors and 
 that is it? 
</p>

<p>
  Well, you can. Using a while-loop which reads an array of vectors: 
</p>

<pre>
#declare MyColors = array[20]
   {  &lt;.1,1,.6&gt;, &lt;.8,.3,.6&gt;, &lt;.3,.7,.9&gt;,
      &lt;1,.7,.3&gt;, ...
   }

...

   color_map
   {  #declare LastIndex = dimension_size(MyColors, 1)-1;
      #declare Index = 0;
      #while(Index &lt;= LastIndex)

         [Index/LastIndex rgb MyColors[Index]]

         #declare Index = Index + 1;
      #end
   }
</pre>

<p>
  Now it is easy to add, remove or modify colors in your color map. Just edit the vector array (remembering to change 
 its size number accordingly) and the while-loop will automatically calculate the right values and create the color map 
 for you. 
</p>
 <br> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_73.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_73.html">2.3.8 Making Animations</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong>2.3.9 While-loop tutorial</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_75.html">2.3.10 SDL tutorial: A raytracer</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_75.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 </body> </html>