
<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2003-2004  -->
<html> 
<head>
  
<!--  NOTE: In order to users to help find information about POV-Ray using  -->
 
<!--  web search engines, we ask you to *not* let them index documentation  -->
 
<!--  mirrors because effectively, when searching, users will get hundreds  -->
 
<!--  of results containing the same information! For this reason, the two  -->
 
<!--  meta tags below disable archiving and indexing of this page by all  -->
 
<!--  search engines that support these meta tags.  -->
 
 <meta content="noarchive" name="robots">
   
 <meta content="noindex" name="robots">
   
 <meta content="no-cache" http-equiv="Pragma">
   
 <meta content="0" http-equiv="expires">
   
<title>3.5.11 Patterns</title>
 <link href="povray35.css" rel="stylesheet" type="text/css"> 
</head>
 <body> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_124.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_124.html">3.5.10 Cutaway Textures</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong class="NavBar">POV-Ray 3.6 for UNIX documentation</strong><br> <strong>3.5.11 
   Patterns</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_126.html">3.5.12 Pattern Modifiers</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_126.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 
<h3><a name="s03_05_11">3.5.11 </a>Patterns</h3>

<p>
  POV-Ray uses a method called <em>three-dimensional solid texturing</em> to define the color, bumpiness and other 
 properties of an object. You specify the way that the texture varies over a surface by specifying a <em> pattern</em>. 
 Patterns are used in pigments, normals and texture maps as well as media density. 
</p>

<p>
  All patterns in POV-Ray are three dimensional. For every point in space, each pattern has a unique value. Patterns 
 do not wrap around a surface like putting wallpaper on an object. The patterns exist in 3d and the objects are carved 
 from them like carving an object from a solid block of wood or stone. 
</p>

<p>
  Consider a block of wood. It contains light and dark bands that are concentric cylinders being the growth rings of 
 the wood. On the end of the block you see these concentric circles. Along its length you see lines that are the veins. 
 However the pattern exists throughout the entire block. If you cut or carve the wood it reveals the pattern inside. 
 Similarly an onion consists of concentric spheres that are visible only when you slice it. Marble stone consists of 
 wavy layers of colored sediments that harden into rock. 
</p>

<p>
  These solid patterns can be simulated using mathematical functions. Other random patterns such as granite or bumps 
 and dents can be generated using a random number system and a noise function. 
</p>

<p>
  In each case, the x, y, z coordinate of a point on a surface is used to compute some mathematical function that 
 returns a float value. When used with color maps or pigment maps, that value looks up the color of the pigment to be 
 used. In normal statements the pattern function result modifies or perturbs the surface normal vector to give a bumpy 
 appearance. Used with a texture map, the function result determines which combinations of entire textures to be used. 
 When used with media density it specifies the density of the particles or gasses. 
</p>

<p>
  The following sections describe each pattern. See the sections &quot;<a href="#l146">Pigment</a>&quot;, &quot;<a href="#l147">Normal</a>&quot; 
 &quot;<a href="s_119.html#s03_05_05">Patterned Textures</a>&quot; and &quot;<a href="s_129.html#s03_06_02_03">Density</a>&quot; 
 for more details on how to use patterns. Unless mentioned otherwise, all patterns use the <code>ramp_wave</code> wave 
 type by default but may use any wave type and may be used with <code>color_map</code>, <code>pigment_map</code>, <code>normal_map</code>, 
 <code>slope_map</code>, <code> texture_map</code>, <code>density</code>, and <code>density_map</code>. 
</p>

<p class="Note">
  <strong>Note:</strong> Some patterns have a built in default color_map that does not result in a 
 grey-scale pattern. This may lead to unexpected results when one of these patterns is used without a user specified 
 color_map, for example in functions or media. 
</p>

<p>
  These patterns are: 
</p>

<ul>
 
 <li>
   <code>agate</code> 
 </li>

 <li>
   <code>bozo</code> 
 </li>

 <li>
   <code>brick</code> 
 </li>

 <li>
   <code>checker</code> 
 </li>

 <li>
   <code>mandel</code> 
 </li>

 <li>
   <code>hexagon</code> 
 </li>

 <li>
   <code>marble</code> 
 </li>

 <li>
   <code>radial</code> 
 </li>

 <li>
   <code>wood</code> 
 </li>

</ul>

<h4><a name="s03_05_11_01">3.5.11.1 </a>Agate</h4>
<a name="s03_05_11_01_i1"><a name="agate"></a><a name="s03_05_11_01_i2"><a name="agate, keyword"></a><a name="s03_05_11_01_i3"><a name="agate, pattern"></a><a name="s03_05_11_01_i4"><a name="s03_05_11_01_i5"><a name="s03_05_11_01_i6"><a name="agate_turb, agate"></a><a name="s03_05_11_01_i7">
<p>
  The <code>agate</code> pattern is a banded pattern similar to marble but it uses a specialized built-in turbulence 
 function that is different from the traditional turbulence. The traditional turbulence can be used as well but it is 
 generally not necessary because agate is already very turbulent. You may control the amount of the built-in turbulence 
 by adding the optional <code> agate_turb</code> keyword followed by a float value. For example: 
</p>

<pre>
  pigment {
    agate
    agate_turb 0.5
    color_map {MyMap}
  }
</pre>

<p>
  The <code>agate</code> pattern has a default color_map built in that results in a brown and white pattern with 
 smooth transitions. 
</p>

<p>
  Agate as used in a normal: 
</p>

<pre>
  normal {
    agate [Bump_Size]
    [MODIFIERS...]
  }
</pre>

<h4><a name="s03_05_11_02">3.5.11.2 </a>Average</h4>
<a name="s03_05_11_02_i1"><a name="average"></a><a name="s03_05_11_02_i2"><a name="average, keyword"></a><a name="s03_05_11_02_i3"><a name="average, pattern"></a><a name="s03_05_11_02_i4"><a name="s03_05_11_02_i5"><a name="s03_05_11_02_i6"><a name="pigment_map, average"></a><a name="s03_05_11_02_i7">
<p>
  Technically <code>average</code> is not a pattern type but it is listed here because the syntax is similar to other 
 patterns. Typically a pattern type specifies how colors or normals are chosen from a <code>pigment_map</code>, <code>texture_map</code>, 
 <code>density_map</code>, or <code>normal_map </code>, however <code>average</code> tells POV-Ray to average together 
 all of the patterns you specify. Average was originally designed to be used in a normal statement with a <code>normal_map</code> 
 as a method of specifying more than one normal pattern on the same surface. However average may be used in a pigment 
 statement with a <code> pigment_map</code> or in a texture statement with a <code> texture_map</code> or media density 
 with <code>density_map</code> to average colors too. 
</p>

<p>
  When used with pigments, the syntax is: 
</p>

<pre>
AVERAGED_PIGMENT:
    pigment
    {
        pigment_map
        {
            PIGMENT_MAP_ENTRY...
        }
    }
PIGMENT_MAP_ENTRY:
    [ [Weight] PIGMENT_BODY ]
</pre>

<p>
  Where <em><code>Weight</code></em> is an optional float value that defaults to 1.0 if not specified. This weight 
 value is the relative weight applied to that pigment. Each <em>PIGMENT_BODY</em> is anything which can be inside a <code>pigment{...}</code> 
 statement. The <code>pigment</code> keyword and <code>{}</code> braces need not be specified. 
</p>

<p class="Note">
  <strong>Note:</strong> that the <code>[]</code> brackets are part of the actual <em> PIGMENT_MAP_ENTRY</em>. 
 They are not notational symbols denoting optional parts. The brackets surround each entry in the <code>pigment_map</code>. 
 
</p>

<p>
  There may be from 2 to 256 entries in the map. 
</p>

<p>
  For example 
</p>

<pre>
    pigment {
      average
      pigment_map {
        [1.0  Pigment_1]
        [2.0  Pigment_2]
        [0.5  Pigment_3]
      }
    }
</pre>

<p>
  All three pigments are evaluated. The weight values are multiplied by the resulting color. It is then divided by 
 the total of the weights which, in this example is 3.5. When used with <code>texture_map</code> or <code> density_map</code> 
 it works the same way. 
</p>

<p>
  When used with a <code> normal_map</code> in a normal statement, multiple copies of the original surface normal are 
 created and are perturbed by each pattern. The perturbed normals are then weighted, added and normalized. 
</p>

<p>
  See the sections &quot;Pigment Maps and Pigment Lists&quot;, &quot;Normal Maps and Normal Lists&quot;, 
 &quot;Texture Maps&quot;, and &quot;Density Maps and Density Lists&quot; for more information. 
</p>

<h4><a name="s03_05_11_03">3.5.11.3 </a>Boxed</h4>
<a name="s03_05_11_03_i1"><a name="boxed"></a><a name="s03_05_11_03_i2"><a name="boxed, keyword"></a><a name="s03_05_11_03_i3"><a name="boxed, pattern"></a><a name="s03_05_11_03_i4"><a name="s03_05_11_03_i5">
<p>
  The <code>boxed</code> pattern creates a 2x2x2 unit cube centered at the origin. It is computed by: <em> value 
 =1.0- min(1, max(abs(X), abs(Y), abs(Z)))</em> It starts at 1.0 at the origin and decreases to a minimum value of 0.0 
 as it approaches any plane which is one unit from the origin. It remains at 0.0 for all areas beyond that distance. 
 This pattern was originally created for use with <code>halo</code> or <code>media</code> but it may be used anywhere 
 any pattern may be used. 
</p>

<h4><a name="s03_05_11_04">3.5.11.4 </a>Bozo</h4>
<a name="s03_05_11_04_i1"><a name="bozo"></a><a name="s03_05_11_04_i2"><a name="bozo, keyword"></a><a name="s03_05_11_04_i3"><a name="bozo, pattern"></a><a name="s03_05_11_04_i4"><a name="s03_05_11_04_i5">
<p>
  The <code>bozo</code> pattern is a very smooth, random noise function that is traditionally used with some 
 turbulence to create clouds. The <code> spotted</code> pattern is identical to <code>bozo</code> but in early versions 
 of POV-Ray spotted did not allow turbulence to be added. Turbulence can now be added to any pattern so these are 
 redundant but both are retained for backwards compatibility. The <code>bumps</code> pattern is also identical to <code>bozo</code> 
 when used anywhere except in a <code> normal</code> statement. When used as a normal pattern, <code>bumps</code> uses 
 a slightly different method to perturb the normal with a similar noise function. 
</p>

<p>
  The <code>bozo</code> noise function has the following properties: 
</p>

<p>
  1. It is defined over 3D space i.e., it takes x, y, and z and returns the noise value there. 
</p>

<p>
  2. If two points are far apart, the noise values at those points are relatively random. 
</p>

<p>
  3. If two points are close together, the noise values at those points are close to each other. 
</p>

<p>
  You can visualize this as having a large room and a thermometer that ranges from 0.0 to 1.0. Each point in the room 
 has a temperature. Points that are far apart have relatively random temperatures. Points that are close together have 
 close temperatures. The temperature changes smoothly but randomly as we move through the room. 
</p>

<p>
  Now let's place an object into this room along with an artist. The artist measures the temperature at each point on 
 the object and paints that point a different color depending on the temperature. What do we get? A POV-Ray bozo 
 texture! 
</p>

<p>
  The <code>bozo</code> pattern has a default color_map built in that results in a green, blue, red and white pattern 
 with sharp transitions. 
</p>

<p class="Note">
  <strong>Note:</strong> The appearance of the bozo pattern depends on the noise_generator used. The 
 default type is 2. This may be changed using the <code>noise_generator</code> keyword (See section &quot;Pattern 
 Modifiers / <a href="#l148">Noise_generator</a>&quot;). 
</p>

<h4><a name="s03_05_11_05">3.5.11.5 </a>Brick</h4>
<a name="s03_05_11_05_i1"><a name="brick"></a><a name="s03_05_11_05_i2"><a name="brick, keyword"></a><a name="s03_05_11_05_i3"><a name="brick, pattern"></a><a name="s03_05_11_05_i4"><a name="s03_05_11_05_i5"><a name="s03_05_11_05_i6"><a name="brick_size, brick"></a><a name="s03_05_11_05_i7"><a name="s03_05_11_05_i8"><a name="mortar, brick"></a><a name="s03_05_11_05_i9">
<p>
  The <code>brick</code> pattern generates a pattern of bricks. The bricks are offset by half a brick length on every 
 other row in the x- and z-directions. A layer of mortar surrounds each brick. The syntax is given by 
</p>

<pre>
 pigment {
   brick COLOR_1, COLOR_2
   [brick_size &lt;Size&gt;] [mortar Size]
 }
</pre>

<p>
  where <em>COLOR_1</em> is the color of the mortar and <em>COLOR_2</em> is the color of the brick itself. If no 
 colors are specified a default deep red and dark gray are used. The default size of the brick and mortar together is 
 &lt;8, 3, 4.5&gt; units. The default thickness of the mortar is 0.5 units. These values may be changed using the 
 optional <code> brick_size</code> and <code>mortar</code> pattern modifiers. You may also use pigment statements in 
 place of the colors. For example: 
</p>

<pre>
  pigment {
    brick pigment{Jade}, pigment{Black_Marble}
  }
</pre>

<p>
  This example uses normals: 
</p>

<pre>
  normal { brick 0.5 }
</pre>

<p>
  The float value is an optional bump size. You may also use full normal statements. For example: 
</p>

<pre>
  normal {
    brick normal{bumps 0.2}, normal{granite 0.3}
  }
</pre>

<p>
  When used with textures, the syntax is 
</p>

<pre>
  texture {
    brick texture{T_Gold_1A}, texture{Stone12}
  }
</pre>

<p>
  This is a block pattern which cannot use wave types, <code> color_map</code>, or <code>slope_map</code> modifiers. 
</p>

<p>
  The <code>brick</code> pattern has a default color_map built in that results in red bricks and grey mortar. 
</p>

<h4><a name="s03_05_11_06">3.5.11.6 </a>Bumps</h4>
<a name="s03_05_11_06_i1"><a name="bumps"></a><a name="s03_05_11_06_i2"><a name="bumps, keyword"></a><a name="s03_05_11_06_i3"><a name="bumps, pattern"></a><a name="s03_05_11_06_i4"><a name="s03_05_11_06_i5">
<p>
  The <code>bumps</code> pattern was originally designed only to be used as a normal pattern. It uses a very smooth, 
 random noise function that creates the look of rolling hills when scaled large or a bumpy orange peel when scaled 
 small. Usually the bumps are about 1 unit apart. 
</p>

<p>
  When used as a normal pattern, this pattern uses a specialized normal perturbation function. This means that the 
 pattern cannot be used with <code> normal_map</code>, <code> slope_map</code> or wave type modifiers in a <code> normal</code> 
 statement. 
</p>

<p>
  When used as a pigment pattern or texture pattern, the <code>bumps</code> pattern is identical to <code>bozo</code> 
 or <code>spotted</code> and is similar to normal bumps but is not identical as are most normals when compared to 
 pigments. 
</p>

<p class="Note">
  <strong>Note:</strong> The appearance of the bumps pattern depends on the noise_generator used. The 
 default type is 2. This may be changed using the <code>noise_generator</code> keyword (See section &quot;Pattern 
 Modifiers / <a href="#l148">Noise_generator</a>&quot;). 
</p>

<h4><a name="s03_05_11_07">3.5.11.7 </a>Cells</h4>
<a name="s03_05_11_07_i1"><a name="cells"></a><a name="s03_05_11_07_i2"><a name="cells, keyword"></a><a name="s03_05_11_07_i3"><a name="cells, pattern"></a><a name="s03_05_11_07_i4"><a name="s03_05_11_07_i5">
<p>
  The <code>cells</code> pattern fills 3d space with unit cubes. Each cube gets a random value from 0 to 1. 
</p>

<p>
  <code>cells</code> is not very suitable as a normal as it has no smooth transitions of one grey value to another. 
</p>

<h4><a name="s03_05_11_08">3.5.11.8 </a>Checker</h4>
<a name="s03_05_11_08_i1"><a name="checker"></a><a name="s03_05_11_08_i2"><a name="checker, keyword"></a><a name="s03_05_11_08_i3"><a name="checker, pattern"></a><a name="s03_05_11_08_i4"><a name="s03_05_11_08_i5">
<p>
  The <code>checker</code> pattern produces a checkered pattern consisting of alternating squares of two colors. The 
 syntax is: 
</p>

<pre>
  pigment { checker [COLOR_1 [, COLOR_2]] [PATTERN_MODIFIERS...] }
</pre>

<p>
  If no colors are specified then default blue and green colors are used. 
</p>

<p>
  The checker pattern is actually a series of cubes that are one unit in size. Imagine a bunch of 1 inch cubes made 
 from two different colors of modeling clay. Now imagine arranging the cubes in an alternating check pattern and 
 stacking them in layer after layer so that the colors still alternate in every direction. Eventually you would have a 
 larger cube. The pattern of checks on each side is what the POV-Ray checker pattern produces when applied to a box 
 object. Finally imagine cutting away at the cube until it is carved into a smooth sphere or any other shape. This is 
 what the checker pattern would look like on an object of any kind. 
</p>

<p>
  You may also use pigment statements in place of the colors. For example: 
</p>

<pre>
  pigment { checker pigment{Jade}, pigment{Black_Marble} }
</pre>

<p>
  This example uses normals: 
</p>

<pre>
  normal { checker 0.5 }
</pre>

<p>
  The float value is an optional bump size. You may also use full normal statements. For example: 
</p>

<pre>
  normal {
    checker normal{gradient x scale .2},
            normal{gradient y scale .2}
  }
</pre>

<p>
  When used with textures, the syntax is 
</p>

<pre>
  texture { checker texture{T_Wood_3A},texture{Stone12} }
</pre>

<p>
  The <code>checker</code> pattern has a default color_map built in that results in blue and green tiles. 
</p>

<p>
  This use of checker as a texture pattern replaces the special tiles texture in previous versions of POV-Ray. You 
 may still use <code> tiles</code> but it may be phased out in future versions so checker textures are best. 
</p>

<p>
  This is a block pattern which cannot use wave types, <code> color_map</code>, or <code>slope_map</code> modifiers. 
</p>

<h4><a name="s03_05_11_09">3.5.11.9 </a>Crackle Patterns</h4>
<a name="s03_05_11_09_i1"><a name="crackle"></a><a name="s03_05_11_09_i2"><a name="crackle, keyword"></a><a name="s03_05_11_09_i3"><a name="crackle, pattern"></a><a name="s03_05_11_09_i4"><a name="s03_05_11_09_i5"><a name="s03_05_11_09_i6"><a name="form, crackle"></a><a name="s03_05_11_09_i7"><a name="s03_05_11_09_i8"><a name="metric, crackle"></a><a name="s03_05_11_09_i9"><a name="s03_05_11_09_i10"><a name="offset, crackle"></a><a name="s03_05_11_09_i11"><a name="s03_05_11_09_i12"><a name="solid, crackle"></a><a name="s03_05_11_09_i13"><a name="s03_05_11_09_i14"><a name="form"></a><a name="s03_05_11_09_i15"><a name="metric"></a><a name="s03_05_11_09_i16"><a name="solid"></a>
<p>
  The <code>crackle</code> pattern is a set of random tiled multifaceted cells. 
</p>

<p>
  There is a choice between different types: 
</p>

<p>
  <strong>Standard Crackle</strong> <br>Mathematically, the set crackle(p)=0 is a 3D Voronoi diagram of a field of 
 semi random points and crackle(p) &lt; 0 is the distance from the set along the shortest path (a Voronoi diagram is 
 the locus of points equidistant from their two nearest neighbors from a set of disjoint points, like the membranes in 
 suds are to the centers of the bubbles). 
</p>

<p>
  With a large scale and no turbulence it makes a pretty good stone wall or floor. <br>With a small scale and no 
 turbulence it makes a pretty good crackle ceramic glaze. <br>Using high turbulence it makes a good marble that avoids 
 the problem of apparent parallel layers in traditional marble. 
</p>

<p>
  <strong>Form</strong> 
</p>

<pre>
  pigment {
    crackle form &lt;FORM_VECTOR&gt;
    [PIGMENT_ITEMS ...]
  }
  normal {
    crackle [Bump_Size]
    form &lt;FORM_VECTOR&gt;
    [NORMAL_ITEMS ...]
  }
</pre>

<p>
  Form determines the linear combination of distances used to create the pattern. Form is a vector. <br>The first 
 component determines the multiple of the distance to the closest point to be used in determining the value of the 
 pattern at a particular point. <br>The second component determines the coefficient applied to the second-closest 
 distance. <br>The third component corresponds to the third-closest distance. 
</p>

<p>
  The standard form is &lt;-1,1,0&gt; (also the default), corresponding to the difference in the distances to the 
 closest and second-closest points in the cell array. Another commonly-used form is &lt;1,0,0&gt;, corresponding to the 
 distance to the closest point, which produces a pattern that looks roughly like a random collection of intersecting 
 spheres or cells. <br>Other forms can create very interesting effects, but it is best to keep the sum of the 
 coefficients low. <br>If the final computed value is too low or too high, the resultant pigment will be saturated with 
 the color at the low or high end of the <code>color_map</code>. In this case, try multiplying the form vector by a 
 constant. 
</p>

<p>
  <strong>Metric</strong> 
</p>

<pre>
  pigment {
    crackle metric METRIC_VALUE
    [PIGMENT_ITEMS ...]
  }
  normal {
    crackle [Bump_Size]
    metric METRIC_VALUE
    [NORMAL_ITEMS ...]
  }
</pre>

<p>
  Changing the metric changes the function used to determine which cell center is closer, for purposes of determining 
 which cell a particular point falls in. The standard Euclidean distance function has a metric of 2. Changing the 
 metric value changes the boundaries of the cells. A metric value of 3, for example, causes the boundaries to curve, 
 while a very large metric constrains the boundaries to a very small set of possible orientations. <br>The default for 
 metric is 2, as used by the standard crackle texture. <br>Metrics other than 1 or 2 can lead to substantially longer 
 render times, as the method used to calculate such metrics is not as efficient. 
</p>

<p>
  <strong>Offset</strong> 
</p>

<pre>
  pigment {
    crackle offset OFFSET_VALUE
    [PIGMENT_ITEMS ...]
  }
  normal {
    crackle [Bump_Size]
    offset OFFSET_VALUE
    [NORMAL_ITEMS ...]
  }
</pre>

<p>
  The offset is used to displace the pattern from the standard xyz space along a fourth dimension. <br>It can be used 
 to round off the &quot;pointy&quot; parts of a cellular normal texture or procedural heightfield by keeping the 
 distances from becoming zero. <br>It can also be used to move the calculated values into a specific range if the 
 result is saturated at one end of the color_map. <br>The default offset is zero. 
</p>

<p>
  <strong>Solid</strong> 
</p>

<pre>
  pigment {
    crackle solid
    [PIGMENT_ITEMS ...]
  }
  normal {
    crackle [Bump_Size]
    solid
    [NORMAL_ITEMS ...]
  }
</pre>

<p>
  Causes the same value to be generated for every point within a specific cell. This has practical applications in 
 making easy stained-glass windows or flagstones. There is no provision for mortar, but mortar may be created by 
 layering or texture-mapping a standard crackle texture with a solid one. <br>The default for this parameter is off. 
</p>

<h4><a name="s03_05_11_10">3.5.11.10 </a>Cylindrical</h4>
<a name="s03_05_11_10_i1"><a name="cylindrical"></a><a name="s03_05_11_10_i2"><a name="cylindrical, keyword"></a><a name="s03_05_11_10_i3"><a name="cylindrical, pattern"></a><a name="s03_05_11_10_i4"><a name="s03_05_11_10_i5">
<p>
  The <code>cylindrical</code> pattern creates a one unit radius cylinder along the Y axis. It is computed by: <em> 
 value = 1.0-min(1, sqrt(X^2 + Z^2))</em> It starts at 1.0 at the origin and decreases to a minimum value of 0.0 as it 
 approaches a distance of 1 unit from the Y axis. It remains at 0.0 for all areas beyond that distance. This pattern 
 was originally created for use with <code>halo</code> or <code>media</code> but it may be used anywhere any pattern 
 may be used. 
</p>

<h4><a name="s03_05_11_11">3.5.11.11 </a>Density_File</h4>
<a name="s03_05_11_11_i1"><a name="density_file"></a><a name="s03_05_11_11_i2"><a name="density_file, keyword"></a><a name="s03_05_11_11_i3"><a name="density_file, pattern"></a><a name="s03_05_11_11_i4"><a name="s03_05_11_11_i5"><a name="s03_05_11_11_i6"><a name="df3, density_file"></a><a name="s03_05_11_11_i7"><a name="s03_05_11_11_i8"><a name="interpolate, density_file"></a><a name="s03_05_11_11_i9"><a name="s03_05_11_11_i10"><a name="df3"></a>
<p>
  The <code>density_file</code> pattern is a 3-D bitmap pattern that occupies a unit cube from location &lt;0,0,0&gt; 
 to &lt;1,1,1&gt;. The data file is a raw binary file format created for POV-Ray called <code> df3</code> format. The 
 syntax provides for the possibility of implementing other formats in the future. This pattern was originally created 
 for use with <code> halo</code> or <code>media</code> but it may be used anywhere any pattern may be used. The syntax 
 is: 
</p>

<pre>
    pigment
    {
        density_file df3 &quot;filename.df3&quot;
        [interpolate Type] [PIGMENT_MODIFIERS...]
    }
</pre>

<p>
  where <em><code>&quot;filename.df3&quot;</code></em> is a file name of the data file. 
</p>

<p>
  As a normal pattern, the syntax is 
</p>

<pre>
    normal
    {
        density_file df3 &quot;filename.df3&quot; [, Bump_Size]
        [interpolate Type]
        [NORMAL_MODIFIERS...]
    }
</pre>

<p>
  The optional float <em><code>Bump_Size</code></em> should follow the file name and any other modifiers follow that. 
</p>

<p>
  The density pattern occupies the unit cube regardless of the dimensions in voxels. It remains at 0.0 for all areas 
 beyond the unit cube. The data in the range of 0 to 255, in case of 8 bit resolution, are scaled into a float value in 
 the range 0.0 to 1.0. 
</p>

<p>
  The <code>interpolate</code> keyword may be specified to add interpolation of the data. The default value of zero 
 specifies no interpolation. A value of one specifies tri-linear interpolation, a value of two specifies tri-cubic 
 interpolation 
</p>

<p>
  See the sample scenes for data file <code>include\spiral.df3</code>,and the scenes which use it: <code>scenes\textures\patterns\densfile.pov</code>, 
 <code> scenes\interior\media\galaxy.pov</code> for examples. 
</p>

<h5><a name="s03_05_11_11_01">3.5.11.11.1 </a>df3 file format</h5>

<p>
  
</p>

<dl>
 
 <dt>
   Header: 
 <dd>
   The <code>df3</code> format consists of a 6 byte header of three 16-bit integers with high order byte first. 
  These three values give the x,y,z size of the data in pixels (or more appropriately called <em>voxels </em>). 
 <dt>
   Data: 
 <dd>
   The header is followed by x*y*z unsigned integer bytes of data with a resolution of 8, 16 or 32 bit. The data are 
  written with high order byte first (big-endian). The resolution of the data is determined by the size of the 
  df3-file. That is, if the file is twice (minus header, of course) as long as an 8 bit file then it is assumed to 
  contain 16 bit ints and if it is four times as long 32 bit ints. 
</dl>

<h4><a name="s03_05_11_12">3.5.11.12 </a>Dents</h4>
<a name="s03_05_11_12_i1"><a name="dents"></a><a name="s03_05_11_12_i2"><a name="dents, keyword"></a><a name="s03_05_11_12_i3"><a name="dents, pattern"></a><a name="s03_05_11_12_i4"><a name="s03_05_11_12_i5">
<p>
  The <code>dents</code> pattern was originally designed only to be used as a normal pattern. It is especially 
 interesting when used with metallic textures. It gives impressions into the metal surface that look like dents have 
 been beaten into the surface with a hammer. Usually the dents are about 1 unit apart. 
</p>

<p>
  When used as a normal pattern, this pattern uses a specialized normal perturbation function. This means that the 
 pattern cannot be used with <code> normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code> normal</code> 
 statement. 
</p>

<p>
  When used as a pigment pattern or texture pattern, the <code>dents</code> pattern is similar to normal dents but is 
 not identical as are most normals when compared to pigments. 
</p>

<h4><a name="s03_05_11_13">3.5.11.13 </a>Facets</h4>
<a name="s03_05_11_13_i1"><a name="coords"></a><a name="s03_05_11_13_i2"><a name="size"></a><a name="s03_05_11_13_i3"><a name="facets"></a><a name="s03_05_11_13_i4"><a name="facets, keyword"></a><a name="s03_05_11_13_i5"><a name="facets, pattern"></a><a name="s03_05_11_13_i6"><a name="s03_05_11_13_i7"><a name="s03_05_11_13_i8"><a name="coords, facets"></a><a name="s03_05_11_13_i9"><a name="s03_05_11_13_i10"><a name="size, facets"></a><a name="s03_05_11_13_i11">
<pre>
  normal {
    facets [coords SCALE_VALUE | size FACTOR]
    [NORMAL_ITEMS...]
  }
</pre>

<p>
  The <code>facets</code> pattern is designed to be used as a normal, it is not suitable for use as a pigment: it 
 will cause an error. <br> There are two forms of the facets pattern. One is most suited for use with rounded surfaces, 
 and one is most suited for use with flat surfaces. 
</p>

<p>
  If <code>coords</code> is specified, the facets pattern creates facets with a size on the same order as the 
 specified SCALE_VALUE. This version of facets is most suited for use with flat surfaces, but will also work with 
 curved surfaces. The boundaries of the facets coincide with the boundaries of the cells in the standard crackle 
 pattern. The coords version of this pattern may be quite similar to a crackle normal pattern with solid specified. 
</p>

<p>
  If <code>size</code> is specified, the facets texture uses a different function that creates facets only on curved 
 surfaces. The FACTOR determines how many facets are created, with smaller values creating more facets, but it is not 
 directly related to any real-world measurement. The same factor will create the same pattern of facets on a sphere of 
 any size. <br>This pattern creates facets by snapping normal vectors to the closest vectors in a perturbed grid of 
 normal vectors. Because of this, if a surface has normal vectors that do not vary along one or more axes, there will 
 be no facet boundaries along those axes. 
</p>

<h4><a name="s03_05_11_14">3.5.11.14 </a>Fractal Patterns</h4>

<p>
  Fractal patterns supported in POV-Ray: 
</p>

<ul>
 
 <li>
   The Mandelbrot set with exponents up to 33.(The formula for these is: <code>z(n+1) = z(n)^p + c</code>, where <code>p</code> 
  is the correspondent exponent.) 
 </li>

 <li>
   The equivalent Julia sets. 
 </li>

 <li>
   The magnet1 and magnet2 fractals (which are derived from some magnetic renormalization transformations; see the 
  fractint help for more details). <br>Both 'Mandelbrot' and 'Julia' versions of them are supported. 
 </li>

</ul>

<p>
  For the Mandelbrot and Julia sets, higher exponents will be slower for two reasons: 
</p>

<ol>
 
 <li>
   For the exponents 2,3 and 4 an optimized algorithm is used. Higher exponents use a generic algorithm for raising 
  a complex number to an integer exponent, and this is a bit slower than an optimized version for a certain exponent. 
 </li>

 <li>
   The higher the exponent, the slower it will be. This is because the amount of operations needed to raise a 
  complex number to an integer exponent is directly proportional to the exponent. This means that exponent 10 will be 
  (very) roughly twice as slow as exponent 5. 
 </li>

</ol>
<a name="s03_05_11_14_i1"><a name="mandel"></a><a name="s03_05_11_14_i2"><a name="mandel, keyword"></a><a name="s03_05_11_14_i3"><a name="mandel, pattern"></a><a name="s03_05_11_14_i4"><a name="s03_05_11_14_i5"><a name="s03_05_11_14_i6"><a name="julia"></a><a name="s03_05_11_14_i7"><a name="julia, keyword"></a><a name="s03_05_11_14_i8"><a name="julia, pattern"></a><a name="s03_05_11_14_i9"><a name="s03_05_11_14_i10"><a name="s03_05_11_14_i11"><a name="magnet"></a><a name="s03_05_11_14_i12"><a name="magnet, keyword"></a><a name="s03_05_11_14_i13"><a name="magnet, pattern"></a><a name="s03_05_11_14_i14"><a name="s03_05_11_14_i15"><a name="s03_05_11_14_i16"><a name="exponent, mandel"></a><a name="s03_05_11_14_i17"><a name="exponent, julia"></a><a name="s03_05_11_14_i18"><a name="exterior, mandel"></a><a name="s03_05_11_14_i19"><a name="exterior, julia"></a><a name="s03_05_11_14_i20"><a name="exterior, magnet"></a><a name="s03_05_11_14_i21"><a name="interior, mandel"></a><a name="s03_05_11_14_i22"><a name="interior, julia"></a><a name="s03_05_11_14_i23"><a name="interior, magnet"></a><a name="s03_05_11_14_i24"><a name="s03_05_11_14_i25"><a name="s03_05_11_14_i26"><a name="s03_05_11_14_i27"><a name="exterior"></a>
<p>
  Syntax: 
</p>

<pre>
MANDELBROT:
  mandel ITERATIONS [, BUMP_SIZE]
  [exponent EXPONENT]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]
  
JULIA:
  julia COMPLEX, ITERATIONS [, BUMP_SIZE]
  [exponent EXPONENT]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]

MAGNET MANDEL:
  magnet MAGNET_TYPE mandel ITERATIONS [, BUMP_SIZE]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]

MAGNET JULIA:
  magnet MAGNET_TYPE julia COMPLEX, ITERATIONS [, BUMP_SIZE]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]
</pre>

<p>
  Where: 
</p>

<p>
  <code>ITERATIONS</code> is the number of times to iterate the algorithm. 
</p>

<p>
  <code>COMPLEX</code> is a 2D vector denoting a complex number. 
</p>

<p>
  <code>MAGNET_TYPE</code> is either 1 or 2. 
</p>

<p>
  <code>exponent</code> is an integer between 2 and 33. If not given, the default is 2. 
</p>

<p>
  <code>interior</code> and <code>exterior</code> specify special coloring algorithms. You can specify one of them or 
 both at the same time. They only work with the fractal patterns. <br><code>EXTERIOR_TYPE</code> and <code>INTERIOR_TYPE</code> 
 are integer values between 0 and 6 (inclusive). When not specified, the default value of INTERIOR_TYPE is 0 and for 
 EXTERIOR_TYPE 1. <br><code>FACTOR</code> is a float. The return value of the pattern is multiplied by <code>FACTOR</code> 
 before returning it. This can be used to scale the value range of the pattern when using interior and exterior 
 coloring (this is often needed to get the desired effect). The default value of FACTOR is 1. 
</p>

<p>
  The different values of EXTERIOR_TYPE and INTERIOR_TYPE have the following meaning: 
</p>

<ul>
 
 <li>
   0 : Returns just 1 
 </li>

 <li>
   1 : For exterior: The number of iterations until bailout divided by ITERATIONS. <br>&nbsp;&nbsp;&nbsp;&nbsp;Note: 
  this is not scaled by FACTOR (since it is internally scaled by 1/ITERATIONS instead). <br>&nbsp;&nbsp;&nbsp;&nbsp;For 
  interior: The absolute value of the smallest point in the orbit of the calculated point 
 </li>

 <li>
   2 : Real part of the last point in the orbit 
 </li>

 <li>
   3 : Imaginary part of the last point in the orbit 
 </li>

 <li>
   4 : Squared real part of the last point in the orbit 
 </li>

 <li>
   5 : Squared imaginary part of the last point in the orbit 
 </li>

 <li>
   6 : Absolute value of the last point in the orbit 
 </li>

</ul>

<p>
  Example: 
</p>

<pre>
  box {
    &lt;-2, -2, 0&gt;, &lt;2, 2, 0.1&gt;
    pigment {
      julia &lt;0.353, 0.288&gt;, 30
      interior 1, 1
      color_map { 
	    [0 rgb 0]
        [0.2 rgb x]
        [0.4 rgb x+y]
        [1 rgb 1]
        [1 rgb 0]
      }
    }
  }
</pre>

<h4><a name="s03_05_11_15">3.5.11.15 </a>Function as pattern</h4>
<a name="s03_05_11_15_i1"><a name="s03_05_11_15_i2"><a name="function, pattern"></a><a name="s03_05_11_15_i3">
<p>
  Allows you to use a function { } block as pattern. 
</p>

<pre>
   pigment {
      function { USER_DEFINED_FUNCTIONS }
      [PIGMENT_MODIFIERS...]
   }
</pre>

<p>
  Declaring a function:<br> By default a function takes three parameters (x,y,z) and you do not have to explicitly 
 specify the parameter names when declaring it. When using the identifier, the parameters must be specified. 
</p>

<pre>
    #declare Foo = function { x + y + z}
    pigment {
      function { Foo(x, y, z) }
        [PIGMENT_MODIFIERS...]
    }
</pre>

<p>
  On the other hand, if you need more or less than three parameters when declaring a function, you also have to 
 explicitly specify the parameter names. 
</p>

<pre>
    #declare Foo = function(x,y,z,t) { x + y + z + t}
    pigment {
      function { Foo(x, y, z, 4) }
        [PIGMENT_MODIFIERS...]
    }
</pre>

<p>
  Using function in a normal: 
</p>

<pre>
    #declare Foo = function { x + y + z}
    normal {
      function { Foo(x, y, z) } [Bump_Size]
      [MODIFIERS...]
    }
</pre>

<h5><a name="s03_05_11_15_01">3.5.11.15.1 </a>What can be used</h5>

<p>
  All float expressions and operators (see section <a href="#l149">&quot;User-Defined Functions&quot;</a>) which are 
 legal in POV-Ray. Of special interest here is the <code>pattern</code> option, that makes it possible to use patterns 
 as functions 
</p>

<pre>
 #declare FOO = function {
    pattern {
      checker
    }
  }
</pre>

<p>
  User defined functions (like equations). 
</p>

<p>
  Since pigments can be declared as functions, they can also be used in functions. They must be declared first. When 
 using the identifier, you have to specify which component of the color vector should be used. To do this, the dot 
 notation is used: Function(x,y,z).red 
</p>

<pre>
   #declare FOO = function {pigment { checker } }
   pigment {
      function { FOO(x,y,z).green }
      [PIGMENT_MODIFIERS...]
   }
</pre>

<p>
  POV-Ray has a large amount of pre-defined functions. These are mainly algebraic surfaces but there is also a mesh 
 function and noise3d function. See section <a href="#l150">&quot;Internal Functions&quot;</a> for a complete list and 
 some explanation on the parameters to use. These internal functions can be included through the functions.inc include 
 file. 
</p>

<pre> 
   #include &quot;functions.inc&quot;
   #declare FOO = function {pigment { checker } }
   pigment {
      function { FOO(x,y,z).green &amp; f_noise3d(x*2, y*3,z)}
      [PIGMENT_MODIFIERS...]
   }
</pre>

<h4><a name="s03_05_11_16">3.5.11.16 </a>Function Image</h4>
<a name="s03_05_11_16_i1"><a name="function, internal bitmap"></a><a name="s03_05_11_16_i2"><a name="function image, pattern"></a><a name="s03_05_11_16_i3">
<p>
  Syntax :<code>function Width, Height { FUNCTION_BODY }</code> 
</p>

<p>
  Not a real pattern, but listed here for convenience. This keyword defines a new 'internal' bitmap image type. The 
 pixels of the image are derived from the Function_Body, with Function_Body either being a regular function, a pattern 
 function or a pigment function. In case of a pigment function the output image will be in color, in case of a pattern 
 or regular function the output image will be grayscale. All variants of grayscale pigment functions are available 
 using the regular function syntax, too. In either case the image will use 16 bit per component 
</p>

<p class="Note">
  <strong>Note:</strong> functions are evaluated on the x-y plane. This is different from the pattern 
 image type for the reason that it makes using uv functions easier. 
</p>

<p>
  Width and Height specify the resolution of the resulting 'internal' bitmap image. The image is taken from the 
 square region <code>&lt;0,0,0&gt;, &lt;1,1,0&gt;</code> 
</p>

<p>
  The <code>function</code> statement can be used wherever an image specifier like <code>tga</code> or <code>png</code> 
 may be used. Some uses include creating heightfields from procedural textures or wrapping a slice of a 3d texture or 
 function around a cylinder or extrude it along an axis. 
</p>

<p>
  Examples: 
</p>

<pre>
   plane { 
      y, -1 
      pigment { 
         image_map { 
            function 10,10 { 
               pigment { checker 1,0 scale .5  }
            }
         }
         rotate x*90
      } 
   }
</pre>

<pre>
   height_field {
      function 200,200 {
         pattern {
            bozo
         }
      }
      translate -0.5
      scale 10
      pigment {rgb 1}
   }
</pre>

<p class="Note">
  <strong>Note:</strong> that for height fields and other situations where color is not needed it is 
 easier to use <code>function n,n {pattern{...}}</code> than <code>function n,n {pigment{...}}</code>. The pattern 
 functions are returning a scalar, not a color vector, thus a pattern is grayscale. 
</p>

<h4><a name="s03_05_11_17">3.5.11.17 </a>Gradient</h4>
<a name="s03_05_11_17_i1"><a name="gradient"></a><a name="s03_05_11_17_i2"><a name="gradient, keyword"></a><a name="s03_05_11_17_i3"><a name="gradient, pattern"></a><a name="s03_05_11_17_i4"><a name="s03_05_11_17_i5">
<p>
  One of the simplest patterns is the <code>gradient</code> pattern. It is specified as 
</p>

<pre>
    pigment {
        gradient &lt;Orientation&gt;
        [PIGMENT_MODIFIERS...]
    }
</pre>

<p>
  where <em><code>&lt;Orientation&gt;</code></em> is a vector pointing in the direction that the colors blend. For 
 example 
</p>

<pre>
   pigment { gradient x } // bands of color vary as you move
                          // along the &quot;x&quot; direction.
</pre>

<p>
  produces a series of smooth bands of color that look like layers of colors next to each other. Points at x=0 are 
 the first color in the color map. As the x location increases it smoothly turns to the last color at x=1. Then it 
 starts over with the first again and gradually turns into the last color at x=2. In POV-Ray versions older than 3.5 
 the pattern reverses for negative values of x. As per POV-Ray 3.5 this is not the case anymore [1]. Using <code>gradient 
 y</code> or <code>gradient z</code> makes the colors blend along the y- or z-axis. Any vector may be used but x, y and 
 z are most common. 
</p>

<p>
  As a normal pattern, gradient generates a saw-tooth or ramped wave appearance. The syntax is 
</p>

<pre>
    normal {
        gradient &lt;Orientation&gt; [, Bump_Size]
        [NORMAL_MODIFIERS...]
    }
</pre>

<p>
  where the vector <em><code>&lt;Orientation&gt;</code></em> is a required parameter but the float <em><code>Bump_Size</code></em> 
 which follows is optional. 
</p>

<p class="Note">
  <strong>Note:</strong> the comma is required especially if <em>Bump_Size</em> is negative. 
</p>

<p>
  [1] If only the range -1 to 1 was used of the old gradient, for example in a <code>sky_sphere</code>, it can be 
 replaced by the <code>planar</code> or <code>marble</code> pattern and revert the color_map. Also rotate the pattern 
 for other orientations than <code>y</code>. A more general solution is to use <code>function{abs(x)}</code> as a 
 pattern instead of <code>gradient x</code> and similar for <code>gradient y</code> and <code>gradient z</code>. 
</p>

<h4><a name="s03_05_11_18">3.5.11.18 </a>Granite</h4>
<a name="s03_05_11_18_i1"><a name="granite"></a><a name="s03_05_11_18_i2"><a name="granite, keyword"></a><a name="s03_05_11_18_i3"><a name="granite, pattern"></a><a name="s03_05_11_18_i4"><a name="s03_05_11_18_i5">
<p>
  The <code>granite</code> pattern uses a simple 1/f fractal noise function to give a good granite pattern. This 
 pattern is used with creative color maps in <code>stones.inc</code> to create some gorgeous layered stone textures. 
</p>

<p>
  As a normal pattern it creates an extremely bumpy surface that looks like a gravel driveway or rough stone. 
</p>

<p class="Note">
  <strong>Note:</strong> The appearance of the granite pattern depends on the noise_generator used. The 
 default type is 2. This may be changed using the <code>noise_generator</code> keyword (See section &quot;Pattern 
 Modifiers / <a href="#l148">Noise_generator</a>&quot;). 
</p>

<h4><a name="s03_05_11_19">3.5.11.19 </a>Hexagon</h4>
<a name="s03_05_11_19_i1"><a name="hexagon"></a><a name="s03_05_11_19_i2"><a name="hexagon, keyword"></a><a name="s03_05_11_19_i3"><a name="hexagon, pattern"></a><a name="s03_05_11_19_i4"><a name="s03_05_11_19_i5">
<p>
  The <code>hexagon</code> pattern is a block pattern that generates a repeating pattern of hexagons in the 
 x-z-plane. In this instance imagine tall rods that are hexagonal in shape and are parallel to the y-axis and grouped 
 in bundles like shown in the example image. Three separate colors should be specified as follows: 
</p>

<pre>
    pigment {
        hexagon [COLOR_1 [, COLOR_2 [, COLOR_3]]]
        [PATTERN_MODIFIERS...]
    }
</pre>

<p>
  <br><center><img alt="The hexagon pattern." src="images/reference/hexpat.png"></center> 
</p>

<p>
  The three colors will repeat the hexagonal pattern with hexagon <em> COLOR_1</em> centered at the origin, <em>COLOR_2</em> 
 in the +z-direction and <em>COLOR_3</em> to either side. Each side of the hexagon is one unit long. The hexagonal rods 
 of color extend infinitely in the +y- and -y-directions. If no colors are specified then default blue, green and red 
 colors are used. 
</p>

<p>
  You may also use pigment statements in place of the colors. For example: 
</p>

<pre>
  pigment {
    hexagon 
    pigment { Jade },
    pigment { White_Marble },
    pigment { Black_Marble }
  }
</pre>

<p>
  This example uses normals: 
</p>

<pre>
  normal { hexagon 0.5 }
</pre>

<p>
  The float value is an optional bump size. You may also use full normal statements. For example: 
</p>

<pre>
  normal {
    hexagon
      normal { gradient x scale .2 },
      normal { gradient y scale .2 },
      normal { bumps scale .2 }
  }
</pre>

<p>
  When used with textures, the syntax is... 
</p>

<pre>
  texture {
    hexagon
      texture { T_Gold_3A },
      texture { T_Wood_3A },
      texture { Stone12 }
  }
</pre>

<p>
  The <code>hexagon</code> pattern has a default color_map built in that results in red, blue and green tiles. 
</p>

<p>
  This is a block pattern which cannot use wave types, <code> color_map</code>, or <code>slope_map</code> modifiers. 
</p>

<h4><a name="s03_05_11_20">3.5.11.20 </a>Image Pattern</h4>

<p>
  Instead of placing the color of the image on the object like an image_map an image_pattern specifies an entire 
 texture item (color, pigment, normal or texture) based on the gray value at that point. <br>This gray-value is checked 
 against a list and the corresponding item is then used for the texture at that particular point. For values between 
 listed items, an averaged texture is calculated. <br>It takes a standard image specification and has one option, <code>use_alpha</code> 
 which works similar to <code>use_color</code> or <code>use_index</code>.<a name="s03_05_11_20_i1"><a name="image_pattern"></a><a name="s03_05_11_20_i2"><a name="image_pattern, keyword"></a><a name="s03_05_11_20_i3"><a name="image_pattern, pattern"></a><a name="s03_05_11_20_i4"><a name="s03_05_11_20_i5"><a name="s03_05_11_20_i6"><a name="map_type, image_pattern"></a><a name="s03_05_11_20_i7"><a name="s03_05_11_20_i8"><a name="once, image_pattern"></a><a name="s03_05_11_20_i9"><a name="s03_05_11_20_i10"><a name="interpolate, image_pattern"></a><a name="s03_05_11_20_i11"><a name="s03_05_11_20_i12"><a name="use_alpha, image_pattern"></a><a name="s03_05_11_20_i13"><a name="s03_05_11_20_i14"><a name="use_alpha"></a> 
 
</p>

<p>
  Syntax: 
</p>

<pre>
PIGMENT:
  pigment {
    IMAGE_PATTERN
    color_map { COLOR_MAP_BODY } |
    colour_map { COLOR_MAP_BODY } | 
    pigment_map { PIGMENT_MAP_BODY }
  }

NORMAL:
  normal {
    IMAGE_PATTERN [Bump_Size]
    normal_map { NORMAL_MAP_BODY }
  }

TEXTURE:
  texture {
    IMAGE_PATTERN
    texture_map { TEXTURE_MAP_BODY }
  }

IMAGE_PATTERN
    image_pattern {
      BITMAP_TYPE &quot;bitmap.ext&quot;
      [IMAGE_MAP_MODS...]
    }
IMAGE_MAP_MOD:
    map_type Type | once | interpolate Type | use_alpha
ITEM_MAP_BODY:
    ITEM_MAP_IDENTIFIER | ITEM_MAP_ENTRY...
ITEM_MAP_ENTRY:
    [ GRAY_VALUE  ITEM_MAP_ENTRY... ]
</pre>

<p>
  It is also useful for creating texture &quot;masks&quot;, like the following: 
</p>

<pre>
 texture {
   image_pattern { tga &quot;image.tga&quot; use_alpha }
   texture_map {
     [0 Mytex ]
     [1 pigment { transmit 1 } ]
   }
 }
</pre>

<p class="Note">
  <strong>Note:</strong> This pattern uses an image to get the gray values from. If you want exactly the 
 same possibilities but need to get gray values from a pigment, you can use the <a href="s_125.html#s03_05_11_25">pigment_pattern</a>. 
 
</p>

<h4><a name="s03_05_11_21">3.5.11.21 </a>Leopard</h4>
<a name="s03_05_11_21_i1"><a name="leopard"></a><a name="s03_05_11_21_i2"><a name="leopard, keyword"></a><a name="s03_05_11_21_i3"><a name="leopard, pattern"></a><a name="s03_05_11_21_i4"><a name="s03_05_11_21_i5">
<p>
  Leopard creates regular geometric pattern of circular spots. The formula used is: <em> value = 
 Sqr((sin(x)+sin(y)+sin(z))/3)</em> 
</p>

<h4><a name="s03_05_11_22">3.5.11.22 </a>Marble</h4>
<a name="s03_05_11_22_i1"><a name="marble"></a><a name="s03_05_11_22_i2"><a name="marble, keyword"></a><a name="s03_05_11_22_i3"><a name="marble, pattern"></a><a name="s03_05_11_22_i4"><a name="s03_05_11_22_i5">
<p>
  The <code>marble</code> pattern is very similar to the <code>gradient x</code> pattern. The gradient pattern uses a 
 default <code>ramp_wave</code> wave type which means it uses colors from the color map from 0.0 up to 1.0 at location 
 x=1 but then jumps back to the first color for x &gt; 1 and repeats the pattern again and again. However the <code>marble</code> 
 pattern uses the <code>triangle_wave</code> wave type in which it uses the color map from 0 to 1 but then it reverses 
 the map and blends from 1 back to zero. For example: 
</p>

<pre>
  pigment {
    gradient x
    color_map {
      [0.0  color Yellow]
      [1.0  color Cyan]
    }
  }
</pre>

<p>
  This blends from yellow to cyan and then it abruptly changes back to yellow and repeats. However replacing <code>gradient 
 x</code> with <code> marble</code> smoothly blends from yellow to cyan as the x coordinate goes from 0.0 to 0.5 and 
 then smoothly blends back from cyan to yellow by x=1.0. 
</p>

<p>
  Earlier versions of POV-Ray did not allow you to change wave types. Now that wave types can be changed for most any 
 pattern, the distinction between <code>marble</code> and <code>gradient x</code> is only a matter of default wave 
 types. 
</p>

<p>
  When used with turbulence and an appropriate color map, this pattern looks like veins of color of real marble, jade 
 or other types of stone. By default, marble has no turbulence. 
</p>

<p>
  The <code>marble</code> pattern has a default color_map built in that results in a red, black and white pattern 
 with smooth and sharp transitions. 
</p>

<h4><a name="s03_05_11_23">3.5.11.23 </a>Object Pattern</h4>
<a name="s03_05_11_23_i1"><a name="object"></a><a name="s03_05_11_23_i2"><a name="object, keyword"></a><a name="s03_05_11_23_i3"><a name="object, pattern"></a><a name="s03_05_11_23_i4"><a name="s03_05_11_23_i5">
<p>
  The <code>object</code> pattern takes an object as input. It generates a, two item, color list pattern. Whether a 
 point is assigned to one item or the other depends on whether it is inside the specified object or not. 
</p>

<p>
  Object's used in the <code>object</code> pattern cannot have a texture and must be solid - these are the same 
 limitations as for <code>bounded_by</code> and <code>clipped_by</code>. 
</p>

<p>
  Syntax: 
</p>

<pre>
 object {
   OBJECT_IDENTIFIER | OBJECT {}
   LIST_ITEM_A, LIST_ITEM_B
 }
</pre>

<p>
  Where OBJ_IDENTIFIER is the target object (which must be declared), or use the full object syntax. LIST_ITEM_A and 
 LIST_ITEM_B are the colors, pigments, or whatever the pattern is controlling. LIST_ITEM_A is used for all points 
 outside the object, and LIST_ITEM_B is used for all points inside the object. 
</p>

<p>
  Example: 
</p>

<pre>
 pigment {
    object {
       myTextObject 
       color White 
       color Red
    }
    turbulence 0.15
 }
</pre>

<p>
  <strong>Note:</strong> This is a block pattern which cannot use wave types, color_map, or slope_map modifiers. 
</p>

<h4><a name="s03_05_11_24">3.5.11.24 </a>Onion</h4>
<a name="s03_05_11_24_i1"><a name="onion"></a><a name="s03_05_11_24_i2"><a name="onion, keyword"></a><a name="s03_05_11_24_i3"><a name="onion, pattern"></a><a name="s03_05_11_24_i4"><a name="s03_05_11_24_i5">
<p>
  The <code>onion</code> is a pattern of concentric spheres like the layers of an onion. <em> Value = 
 mod(sqrt(Sqr(X)+Sqr(Y)+Sqr(Z)), 1.0)</em> Each layer is one unit thick. 
</p>

<h4><a name="s03_05_11_25">3.5.11.25 </a>Pigment Pattern</h4>
<a name="s03_05_11_25_i1"><a name="pigment_pattern"></a><a name="s03_05_11_25_i2"><a name="pigment_pattern, keyword"></a><a name="s03_05_11_25_i3"><a name="pigment_pattern, pattern"></a><a name="s03_05_11_25_i4"><a name="s03_05_11_25_i5">
<p>
  Use any pigment as a pattern. Instead of using the pattern directly on the object, a pigment_pattern converts the 
 pigment to gray-scale first. For each point, the gray-value is checked against a list and the corresponding item is 
 then used for the texture at that particular point. For values between listed items, an averaged texture is 
 calculated. <br>Texture items can be color, pigment, normal or texture and are specified in a color_map, pigment_map, 
 normal_map or texture_map. <br>It takes a standard pigment specification. 
</p>

<p>
  Syntax: 
</p>

<pre>
PIGMENT:
  pigment {
    pigment_pattern { PIGMENT_BODY }
    color_map { COLOR_MAP_BODY } |
    colour_map { COLOR_MAP_BODY } | 
    pigment_map { PIGMENT_MAP_BODY }
  }

NORMAL:
  normal {
    pigment_pattern { PIGMENT_BODY } [Bump_Size]
    normal_map { NORMAL_MAP_BODY }
  }

TEXTURE:
  texture {
    pigment_pattern { PIGMENT_BODY }
    texture_map { TEXTURE_MAP_BODY }
  }

ITEM_MAP_BODY:
    ITEM_MAP_IDENTIFIER | ITEM_MAP_ENTRY...
ITEM_MAP_ENTRY:
    [ GRAY_VALUE  ITEM_MAP_ENTRY... ]
</pre>

<p>
  This pattern is also useful when parent and children patterns need to be transformed independently from each other. 
 Transforming the pigment_pattern will not affect the child textures. When any of the child textures should be 
 transformed, apply it to the specific MAP_ENTRY. 
</p>

<p>
  This can be used with any pigments, ranging from a simple checker to very complicated nested pigments. For example: 
</p>

<pre>
 pigment {
   pigment_pattern {
     checker White, Black
     scale 2
     turbulence .5
   }
   pigment_map {
     [ 0, checker Red, Green scale .5 ]
     [ 1, checker Blue, Yellow scale .2 ]
   }
 }
</pre>

<p class="Note">
  <strong>Note:</strong> This pattern uses a pigment to get the gray values from. If you want to get the 
 pattern from an image, you should use the <a href="s_125.html#s03_05_11_20">image_pattern</a>. 
</p>

<h4><a name="s03_05_11_26">3.5.11.26 </a>Planar</h4>
<a name="s03_05_11_26_i1"><a name="planar"></a><a name="s03_05_11_26_i2"><a name="planar, keyword"></a><a name="s03_05_11_26_i3"><a name="planar, pattern"></a><a name="s03_05_11_26_i4"><a name="s03_05_11_26_i5">
<p>
  The <code>planar</code> pattern creates a horizontal stripe plus or minus one unit above and below the X-Z plane. 
 It is computed by: <em> value =1.0- min(1, abs(Y))</em> It starts at 1.0 at the origin and decreases to a minimum 
 value of 0.0 as the Y values approaches a distance of 1 unit from the X-Z plane. It remains at 0.0 for all areas 
 beyond that distance. This pattern was originally created for use with <code>halo</code> or <code> media</code> but it 
 may be used anywhere any pattern may be used. 
</p>

<h4><a name="s03_05_11_27">3.5.11.27 </a>Quilted</h4>
<a name="s03_05_11_27_i1"><a name="quilted"></a><a name="s03_05_11_27_i2"><a name="quilted, keyword"></a><a name="s03_05_11_27_i3"><a name="quilted, pattern"></a><a name="s03_05_11_27_i4"><a name="s03_05_11_27_i5"><a name="s03_05_11_27_i6"><a name="control0, quilted"></a><a name="s03_05_11_27_i7"><a name="s03_05_11_27_i8"><a name="control1, quilted"></a><a name="s03_05_11_27_i9">
<p>
  The <code>quilted</code> pattern was originally designed only to be used as a normal pattern. The quilted pattern 
 is so named because it can create a pattern somewhat like a quilt or a tiled surface. The squares are actually 3-D 
 cubes that are 1 unit in size. 
</p>

<p>
  When used as a normal pattern, this pattern uses a specialized normal perturbation function. This means that the 
 pattern cannot be used with <code> normal_map</code>, <code> slope_map</code> or wave type modifiers in a <code> normal</code> 
 statement. 
</p>

<p>
  When used as a pigment pattern or texture pattern, the <code>quilted</code> pattern is similar to normal quilted 
 but is not identical as are most normals when compared to pigments. 
</p>

<p>
  The two parameters <code>control0</code> and <code> control1</code> are used to adjust the curvature of the <em> 
 seam</em> or <em> gouge</em> area between the <code>quilts</code>. 
</p>

<p>
  The syntax is: 
</p>

<pre>
    pigment { quilted [QUILTED_MODIFIERS...] }
QUILTED_MODIFIERS:
  control0 Value_0 | control1 Value_1 | PIGMENT_MODIFIERS
</pre>

<p>
  The values should generally be kept to around the 0.0 to 1.0 range. The default value is 1.0 if none is specified. 
 Think of this gouge between the tiles in cross-section as a sloped line. 
</p>

<p>
  <br><center><img alt="Quilted pattern with c0=0 and different values for c1." src="images/reference/quiltpt1.png"></center> 
 
</p>

<p>
  <br><center><img alt="Quilted pattern with c0=0.33 and different values for c1." src="images/reference/quiltpt2.png"></center> 
 
</p>

<p>
  <br><center><img alt="Quilted pattern with c0=0.67 and different values for c1." src="images/reference/quiltpt3.png"></center> 
 
</p>

<p>
  <br><center><img alt="Quilted pattern with c0=1 and different values for c1." src="images/reference/quiltpt4.png"></center> 
 
</p>

<p>
  This straight slope can be made to curve by adjusting the two control values. The control values adjust the slope 
 at the top and bottom of the curve. A control values of 0 at both ends will give a linear slope, as shown above, 
 yielding a hard edge. A control value of 1 at both ends will give an &quot;s&quot; shaped curve, resulting in a 
 softer, more rounded edge. 
</p>

<p>
  The syntax for use as a normal is: 
</p>

<pre>
  normal { 
    quilted [Bump_Size]
    [QUILTED_MODIFIERS...] 
  }
QUILTED_MODIFIERS:
  control0 Value_0 | control1 Value_1 | PIGMENT_MODIFIERS
</pre>

<h4><a name="s03_05_11_28">3.5.11.28 </a>Radial</h4>
<a name="s03_05_11_28_i1"><a name="radial"></a><a name="s03_05_11_28_i2"><a name="radial, keyword"></a><a name="s03_05_11_28_i3"><a name="radial, pattern"></a><a name="s03_05_11_28_i4"><a name="s03_05_11_28_i5"><a name="s03_05_11_28_i6"><a name="frequency, radial"></a><a name="s03_05_11_28_i7">
<p>
  The <code>radial</code> pattern is a radial blend that wraps around the +y-axis. The color for value 0.0 starts at 
 the +x-direction and wraps the color map around from east to west with 0.25 in the -z-direction, 0.5 in -x, 0.75 at +z 
 and back to 1.0 at +x. Typically the pattern is used with a <code> frequency</code> modifier to create multiple bands 
 that radiate from the y-axis. For example: 
</p>

<pre>
  pigment {
    radial color_map{[0.5 Black][0.5 White]}
    frequency 10
  }
</pre>

<p>
  creates 10 white bands and 10 black bands radiating from the y axis. 
</p>

<p>
  The <code>radial</code> pattern has a default color_map built in that results in a yellow, magenta and cyan pattern 
 with smooth transitions. 
</p>

<h4><a name="s03_05_11_29">3.5.11.29 </a>Ripples</h4>
<a name="s03_05_11_29_i1"><a name="ripples"></a><a name="s03_05_11_29_i2"><a name="ripples, keyword"></a><a name="s03_05_11_29_i3"><a name="ripples, pattern"></a><a name="s03_05_11_29_i4"><a name="s03_05_11_29_i5">
<p>
  The <code>ripples</code> pattern was originally designed only to be used as a normal pattern. It makes the surface 
 look like ripples of water. The ripples radiate from 10 random locations inside the unit cube area &lt;0,0,0&gt; to 
 &lt;1,1,1&gt;. Scale the pattern to make the centers closer or farther apart. 
</p>

<p>
  Usually the ripples from any given center are about 1 unit apart. The <code> frequency</code> keyword changes the 
 spacing between ripples. The <code> phase</code> keyword can be used to move the ripples outwards for realistic 
 animation. 
</p>

<p>
  The number of ripple centers can be changed with the global parameter global_settings{number_of_waves Count } 
</p>

<p>
  somewhere in the scene. This affects the entire scene. You cannot change the number of wave centers on individual 
 patterns. See section &quot;Number_Of_Waves&quot; for details. 
</p>

<p>
  When used as a normal pattern, this pattern uses a specialized normal perturbation function. This means that the 
 pattern cannot be used with <code> normal_map</code>, <code> slope_map</code> or wave type modifiers in a <code> normal</code> 
 statement. 
</p>

<p>
  When used as a pigment pattern or texture pattern, the <code>ripples</code> pattern is similar to normal ripples 
 but is not identical as are most normals when compared to pigments. 
</p>

<h4><a name="s03_05_11_30">3.5.11.30 </a>Slope</h4>
<a name="s03_05_11_30_i1"><a name="altitude"></a><a name="s03_05_11_30_i2"><a name="slope"></a><a name="s03_05_11_30_i3"><a name="slope, keyword"></a><a name="s03_05_11_30_i4"><a name="slope, pattern"></a><a name="s03_05_11_30_i5"><a name="s03_05_11_30_i6"><a name="s03_05_11_30_i7"><a name="altitude, slope"></a><a name="s03_05_11_30_i8">
<p>
  The <code>slope</code> pattern uses the normal of a surface to calculate the slope at a given point. It then 
 creates the pattern value dependent on the slope and optionally the altitude. It can be used for pigments, normals and 
 textures, but not for media densities. For pigments the syntax is: 
</p>

<pre>
  pigment {
    slope {
      &lt;Direction&gt; [, Lo_slope, Hi_slope ]
      [ altitude &lt;Altitude&gt; [, Lo_alt, Hi_alt ]]
    }
    [PIGMENT_MODIFIERS...]
  }
</pre>

<p>
  The slope value at a given point is dependent on the angle between the <code>&lt;Direction&gt;</code> vector and 
 the normal of the surface at that point. For example: <br>- When the surface normal points in the opposite direction 
 of the <code>&lt;Direction&gt;</code> vector (180 degrees), the slope is 0.0. <br>- When the surface normal is 
 perpendicular to the <code>&lt;Direction&gt;</code> vector (90 degrees), the slope is 0.5. <br>- When the surface 
 normal is parallel to the <code>&lt;Direction&gt;</code> vector (0 degrees), the slope is 1.0. 
</p>

<p>
  When using the simplest variant of the syntax: 
</p>

<pre>
  slope { &lt;Direction&gt; }
</pre>

<p>
  the pattern value for a given point is the same as the slope value. <code>&lt;Direction&gt;</code> is a 
 3-dimensional vector and will usually be <code>&lt;0,-1,0&gt;</code> for landscapes, but any direction can be used. 
</p>

<p>
  By specifying <code>Lo_slope</code> and <code>Hi_slope</code> you get more control: 
</p>

<pre>
  slope { &lt;Direction&gt;, Lo_slope, Hi_slope }
</pre>

<p>
  <code>Lo_slope</code> and <code>Hi_slope</code> specifies which range of slopes are used, so you can control which 
 slope values return which pattern values. <code>Lo_slope</code> is the slope value that returns 0.0 and <code>Hi_slope</code> 
 is the slope value that returns 1.0. 
</p>

<p>
  For example, if you have a height_field and <code>&lt;Direction&gt;</code> is set to <code>&lt;0,-1,0&gt;</code>, 
 then the slope values would only range from 0.0 to 0.5 because height_fields cannot have overhangs. If you do not 
 specify <code>Lo_slope</code> and <code>Hi_slope</code>, you should keep in mind that the texture for the flat 
 (horizontal) areas must be set at 0.0 and the texture for the steep (vertical) areas at 0.5 when designing the 
 texture_map. The part from 0.5 up to 1.0 is not used then. But, by setting <code>Lo_slope</code> and <code>Hi_slope</code> 
 to 0.0 and 0.5 respectively, the slope range will be stretched over the entire map, and the texture_map can then be 
 defined from 0.0 to 1.0. 
</p>

<p>
  By adding an optional <code>&lt;Altitude&gt;</code> vector: 
</p>

<pre>
  slope {
    &lt;Direction&gt;
    altitude &lt;Altitude&gt;
  }
</pre>

<p>
  the pattern will be influenced not only by the slope but also by a special gradient. <code>&lt;Altitude&gt;</code> 
 is a 3-dimensional vector that specifies the direction of the gradient. When <code>&lt;Altitude&gt;</code> is 
 specified, the pattern value is a weighted average of the slope value and the gradient value. The weights are the 
 lengths of the vectors <code>&lt;Direction&gt;</code> and <code>&lt;Altitude&gt;</code>. So if <code>&lt;Direction&gt;</code> 
 is much longer than <code>&lt;Altitude&gt;</code> it means that the slope has greater effect on the results than the 
 gradient. If on the other hand <code>&lt;Altitude&gt;</code> is longer, it means that the gradient has more effect on 
 the results than the slope. 
</p>

<p>
  When adding the <code>&lt;Altitude&gt;</code> vector, the default gradient is defined from 0 to 1 units along the 
 specified axis. This is fine when your object is defined within this range, otherwise a correction is needed. This can 
 be done with the optional <code>Lo_alt</code> and <code>Hi_alt</code> parameters: 
</p>

<pre>
  slope {
    &lt;Direction&gt;
    altitude &lt;Altitude&gt;, Lo_alt, Hi_alt
  }
</pre>

<p>
  They define the range of the gradient along the axis defined by the &lt;Altitude&gt; vector. 
</p>

<p>
  For example, with an <code>&lt;Altitude&gt;</code> vector set to y and an object going from -3 to 2 on the y axis, 
 the <code>Lo_alt</code> and <code>Hi_alt</code> parameters should be set to -3 and 2 respectively. 
</p>

<p class="Note">
  <strong>Note:</strong> 
</p>

<ul>
 
 <li>
   You may use the turbulence keyword inside slope pattern definitions but it may cause unexpected results. 
  Turbulence is a 3-dimensional distortion of a pattern. Since slope is only defined on surfaces of objects, a 
  3-dimensional turbulence is not applicable to the slope component. However, if you are using altitude, the altitude 
  component of the pattern will be affected by turbulence. 
 </li>

 <li>
   If your object is larger than the range of altitude you have specified, you may experience unexpected 
  discontinuities. In that case it is best to adjust the <code>Lo_alt</code> and <code>Hi_alt</code> values so they fit 
  to your object. 
 </li>

 <li>
   The slope pattern does not work for the sky_sphere, because the sky_sphere is a background feature and does not 
  have a surface. similarly, it does not work for media densities. 
 </li>

</ul>

<h4><a name="s03_05_11_31">3.5.11.31 </a>Spherical</h4>
<a name="s03_05_11_31_i1"><a name="spherical"></a><a name="s03_05_11_31_i2"><a name="spherical, keyword"></a><a name="s03_05_11_31_i3"><a name="spherical, pattern"></a><a name="s03_05_11_31_i4"><a name="s03_05_11_31_i5">
<p>
  The <code>spherical</code> pattern creates a one unit radius sphere, with its center at the origin. It is computed 
 by: <em> value = 1.0-min(1, sqrt(X^2 + Y^2 + Z^2))</em> It starts at 1.0 at the origin and decreases to a minimum 
 value of 0.0 as it approaches a distance of 1 unit from the origin in any direction. It remains at 0.0 for all areas 
 beyond that distance. This pattern was originally created for use with <code>halo</code> or <code>media</code> but it 
 may be used anywhere any pattern may be used. 
</p>

<h4><a name="s03_05_11_32">3.5.11.32 </a>Spiral1</h4>
<a name="s03_05_11_32_i1"><a name="spiral1"></a><a name="s03_05_11_32_i2"><a name="spiral1, keyword"></a><a name="s03_05_11_32_i3"><a name="spiral1, pattern"></a><a name="s03_05_11_32_i4"><a name="s03_05_11_32_i5"><a name="s03_05_11_32_i6"><a name="spiral"></a>
<p>
  The <code>spiral1</code> pattern creates a spiral that winds around the z-axis similar to a screw. When viewed 
 sliced in the x-y plane, it looks like the spiral arms of a galaxy. Its syntax is: 
</p>

<pre>
    pigment
    {
        spiral1 Number_of_Arms
        [PIGMENT_MODIFIERS...]
    }
</pre>

<p>
  The <em><code>Number_of_Arms</code></em> value determines how may arms are winding around the z-axis. 
</p>

<p>
  As a normal pattern, the syntax is 
</p>

<pre>
    normal
    {
        spiral1 Number_of_Arms [, Bump_Size]
        [NORMAL_MODIFIERS...]
    }
</pre>

<p>
  where the <code>Number_of_Arms</code> value is a required parameter but the float <em><code>Bump_Size</code></em> 
 which follows is optional. 
</p>

<p class="Note">
  <strong>Note:</strong> the comma is required especially if <em>Bump_Size</em> is negative. 
</p>

<p>
  The pattern uses the <code>triangle_wave</code> wave type by default but may use any wave type. 
</p>

<h4><a name="s03_05_11_33">3.5.11.33 </a>Spiral2</h4>
<a name="s03_05_11_33_i1"><a name="spiral2"></a><a name="s03_05_11_33_i2"><a name="spiral2, keyword"></a><a name="s03_05_11_33_i3"><a name="spiral2, pattern"></a><a name="s03_05_11_33_i4"><a name="s03_05_11_33_i5">
<p>
  The <code>spiral2</code> pattern creates a double spiral that winds around the z-axis similar to <code>spiral1</code> 
 except that it has two overlapping spirals which twist in opposite directions. The result sometimes looks like a 
 basket weave or perhaps the skin of pineapple. The center of a sunflower also has a similar double spiral pattern. Its 
 syntax is: 
</p>

<pre>
    pigment
    {
        spiral2 Number_of_Arms
        [PIGMENT_MODIFIERS...]
    }
</pre>

<p>
  The <em><code>Number_of_Arms</code></em> value determines how may arms are winding around the z-axis. As a normal 
 pattern, the syntax is 
</p>

<pre>
    normal
    {
        spiral2 Number_of_Arms [, Bump_Size]
        [NORMAL_MODIFIERS...]
    }
</pre>

<p>
  where the <code>Number_of_Arms</code> value is a required parameter but the float <em><code>Bump_Size</code></em> 
 which follows is optional. 
</p>

<p class="Note">
  <strong>Note:</strong> the comma is required especially if <em>Bump_Size</em> is negative. The pattern 
 uses the <code>triangle_wave</code> wave type by default but may use any wave type. 
</p>

<h4><a name="s03_05_11_34">3.5.11.34 </a>Spotted</h4>
<a name="s03_05_11_34_i1"><a name="spotted"></a><a name="s03_05_11_34_i2"><a name="spotted, keyword"></a><a name="s03_05_11_34_i3"><a name="spotted, pattern"></a><a name="s03_05_11_34_i4"><a name="s03_05_11_34_i5">
<p>
  The <code>spotted</code> pattern is identical to the <code>bozo</code> pattern. Early versions of POV-Ray did not 
 allow turbulence to be used with spotted. Now that any pattern can use turbulence there is no difference between <code>bozo</code> 
 and <code>spotted</code>. See section &quot;Bozo&quot; for details. 
</p>

<h4><a name="s03_05_11_35">3.5.11.35 </a>Waves</h4>
<a name="s03_05_11_35_i1"><a name="waves"></a><a name="s03_05_11_35_i2"><a name="waves, keyword"></a><a name="s03_05_11_35_i3"><a name="waves, pattern"></a><a name="s03_05_11_35_i4"><a name="s03_05_11_35_i5">
<p>
  The <code>waves</code> pattern was originally designed only to be used as a normal pattern. It makes the surface 
 look like waves on water. The <code> waves</code> pattern looks similar to the <code>ripples</code> pattern except the 
 features are rounder and broader. The effect is to make waves that look more like deep ocean waves. The waves radiate 
 from 10 random locations inside the unit cube area &lt;0,0,0&gt; to &lt;1,1,1&gt;. Scale the pattern to make the 
 centers closer or farther apart. 
</p>

<p>
  Usually the waves from any given center are about 1 unit apart. The <code> frequency</code> keyword changes the 
 spacing between waves. The <code> phase</code> keyword can be used to move the waves outwards for realistic animation. 
</p>

<p>
  The number of wave centers can be changed with the global parameter 
</p>

<pre>
 global_settings { number_of_waves Count }
</pre>

<p>
  somewhere in the scene. This affects the entire scene. You cannot change the number of wave centers on individual 
 patterns. See section &quot;Number_Of_Waves&quot; for details. 
</p>

<p>
  When used as a normal pattern, this pattern uses a specialized normal perturbation function. This means that the 
 pattern cannot be used with <code> normal_map</code>, <code> slope_map</code> or wave type modifiers in a <code> normal</code> 
 statement. 
</p>

<p>
  When used as a pigment pattern or texture pattern, the <code>waves</code> pattern is similar to normal waves but is 
 not identical as are most normals when compared to pigments. 
</p>

<h4><a name="s03_05_11_36">3.5.11.36 </a>Wood</h4>
<a name="s03_05_11_36_i1"><a name="wood"></a><a name="s03_05_11_36_i2"><a name="wood, keyword"></a><a name="s03_05_11_36_i3"><a name="wood, pattern"></a><a name="s03_05_11_36_i4"><a name="s03_05_11_36_i5">
<p>
  The <code>wood</code> pattern consists of concentric cylinders centered on the z-axis. When appropriately colored, 
 the bands look like the growth rings and veins in real wood. Small amounts of turbulence should be added to make it 
 look more realistic. By default, wood has no turbulence. 
</p>

<p>
  Unlike most patterns, the <code>wood</code> pattern uses the <code> triangle_wave</code> wave type by default. This 
 means that like marble, wood uses color map values 0.0 to 1.0 then repeats the colors in reverse order from 1.0 to 
 0.0. However you may use any wave type. 
</p>

<p>
  The <code>wood</code> pattern has a default color_map built in that results in a light and dark brown pattern with 
 sharp transitions. 
</p>

<h4><a name="s03_05_11_37">3.5.11.37 </a>Wrinkles</h4>
<a name="s03_05_11_37_i1"><a name="wrinkles"></a><a name="s03_05_11_37_i2"><a name="wrinkles, keyword"></a><a name="s03_05_11_37_i3"><a name="wrinkles, pattern"></a><a name="s03_05_11_37_i4"><a name="s03_05_11_37_i5">
<p>
  The <code>wrinkles</code> pattern was originally designed only to be used as a normal pattern. It uses a 1/f noise 
 pattern similar to granite but the features in wrinkles are sharper. The pattern can be used to simulate wrinkled 
 cellophane or foil. It also makes an excellent stucco texture. 
</p>

<p>
  When used as a normal pattern, this pattern uses a specialized normal perturbation function. This means that the 
 pattern cannot be used with <code> normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code> normal</code> 
 statement. 
</p>

<p>
  When used as a pigment pattern or texture pattern, the <code>wrinkles</code> pattern is similar to normal wrinkles 
 but is not identical as are most normals when compared to pigments. 
</p>

<p class="Note">
  <strong>Note:</strong> The appearance of the wrinkles pattern depends on the noise_generator used. The 
 default type is 2. This may be changed using the <code>noise_generator</code> keyword (See section &quot;Pattern 
 Modifiers / <a href="#l148">Noise_generator</a>&quot;). 
</p>

<p>
 <a name="l146">
<small><strong>More about &quot;Pigment&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_115.html#s03_05_01">3.5.1 Pigment</a> in 3.5 Textures
  </small>

  <li><small>
   <a href="s_162.html#s03_08_10_04">3.8.10.4 Pigment</a> in 3.8.10 Texture
  </small>

  <li><small>
   <a href="s_69.html#s02_03_04_01">2.3.4.1 Pigments</a> in 2.3.4 Advanced Texture Options
  </small>

 </ul>

</p>

<p>
 <a name="l147">
<small><strong>More about &quot;Normal&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_116.html#s03_05_02">3.5.2 Normal</a> in 3.5 Textures
  </small>

  <li><small>
   <a href="s_162.html#s03_08_10_05">3.8.10.5 Normal</a> in 3.8.10 Texture
  </small>

  <li><small>
   <a href="s_69.html#s02_03_04_02">2.3.4.2 Normals</a> in 2.3.4 Advanced Texture Options
  </small>

 </ul>

</p>

<p>
 <a name="l148">
<small><strong>More about &quot;Noise_generator&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_102.html#s03_03_03_10">3.3.3.10 Noise_generator</a> in 3.3.3 Global Settings
  </small>

  <li><small>
   <a href="s_126.html#s03_05_12">3.5.12 Pattern Modifiers</a> in 3.5 Textures
  </small>

  <li><small>
   <a href="s_126.html#s03_05_12_04">3.5.12.4 Noise Generators</a> in 3.5.12 Pattern Modifiers
  </small>

 </ul>

</p>

<p>
 <a name="l149">
<small><strong>More about &quot;&quot;User-Defined Functions&quot;&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_155.html#s03_08_03_04">3.8.3.4 User defined Functions</a> in 3.8.3 Language Basics
  </small>

  <li><small>
   <a href="s_97.html#s03_02_01_06">3.2.1.6 User-Defined Functions</a> in 3.2.1 Language Basics
  </small>

 </ul>

</p>

<p>
 <a name="l150">
<small><strong>More about &quot;&quot;Internal Functions&quot;&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_138.html#s03_07_07_02">3.7.7.2 Internal Functions</a> in 3.7.7 functions.inc
  </small>

  <li><small>
   <a href="s_68.html#s02_03_03_03_05">2.3.3.3.5 Internal functions</a> in 2.3.3.3 Isosurface Object
  </small>

 </ul>

</p>
 <br> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_124.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_124.html">3.5.10 Cutaway Textures</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong>3.5.11 Patterns</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_126.html">3.5.12 Pattern Modifiers</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_126.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 </body> </html>