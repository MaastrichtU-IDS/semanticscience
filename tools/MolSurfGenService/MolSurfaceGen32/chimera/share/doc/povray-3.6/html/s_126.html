
<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2003-2004  -->
<html> 
<head>
  
<!--  NOTE: In order to users to help find information about POV-Ray using  -->
 
<!--  web search engines, we ask you to *not* let them index documentation  -->
 
<!--  mirrors because effectively, when searching, users will get hundreds  -->
 
<!--  of results containing the same information! For this reason, the two  -->
 
<!--  meta tags below disable archiving and indexing of this page by all  -->
 
<!--  search engines that support these meta tags.  -->
 
 <meta content="noarchive" name="robots">
   
 <meta content="noindex" name="robots">
   
 <meta content="no-cache" http-equiv="Pragma">
   
 <meta content="0" http-equiv="expires">
   
<title>3.5.12 Pattern Modifiers</title>
 <link href="povray35.css" rel="stylesheet" type="text/css"> 
</head>
 <body> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_125.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_125.html">3.5.11 Patterns</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong class="NavBar">POV-Ray 3.6 for UNIX documentation</strong><br> <strong>3.5.12 
   Pattern Modifiers</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_127.html">3.6 Interior &amp; Media &amp; Photons</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_127.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 
<h3><a name="s03_05_12">3.5.12 </a>Pattern Modifiers</h3>
<a name="s03_05_12_i1"><a name="noise_generator"></a><a name="s03_05_12_i2"><a name="noise_generator, pattern modifier"></a><a name="s03_05_12_i3"><a name="s03_05_12_i4"><a name="turbulence"></a><a name="s03_05_12_i5"><a name="turbulence, pattern modifier"></a><a name="s03_05_12_i6"><a name="s03_05_12_i7"><a name="octaves"></a><a name="s03_05_12_i8"><a name="octaves, pattern modifier"></a><a name="s03_05_12_i9"><a name="s03_05_12_i10"><a name="omega"></a><a name="s03_05_12_i11"><a name="omega, pattern modifier"></a><a name="s03_05_12_i12"><a name="s03_05_12_i13"><a name="lambda"></a><a name="s03_05_12_i14"><a name="lambda, pattern modifier"></a><a name="s03_05_12_i15"><a name="s03_05_12_i16"><a name="frequency"></a><a name="s03_05_12_i17"><a name="frequency, pattern modifier"></a><a name="s03_05_12_i18"><a name="s03_05_12_i19"><a name="phase"></a><a name="s03_05_12_i20"><a name="phase, pattern modifier"></a><a name="s03_05_12_i21"><a name="s03_05_12_i22"><a name="ramp_wave"></a><a name="s03_05_12_i23"><a name="ramp_wave, pattern modifier"></a><a name="s03_05_12_i24"><a name="s03_05_12_i25"><a name="triangle_wave"></a><a name="s03_05_12_i26"><a name="triangle_wave, pattern modifier"></a><a name="s03_05_12_i27"><a name="s03_05_12_i28"><a name="sine_wave"></a><a name="s03_05_12_i29"><a name="sine_wave, pattern modifier"></a><a name="s03_05_12_i30"><a name="s03_05_12_i31"><a name="scallop_wave"></a><a name="s03_05_12_i32"><a name="scallop_wave, pattern modifier"></a><a name="s03_05_12_i33"><a name="s03_05_12_i34"><a name="cubic_wave"></a><a name="s03_05_12_i35"><a name="cubic_wave, pattern modifier"></a><a name="s03_05_12_i36"><a name="s03_05_12_i37"><a name="poly_wave"></a><a name="s03_05_12_i38"><a name="poly_wave, pattern modifier"></a><a name="s03_05_12_i39"><a name="s03_05_12_i40"><a name="agate_turb"></a><a name="s03_05_12_i41"><a name="agate_turb, pattern modifier"></a><a name="s03_05_12_i42"><a name="s03_05_12_i43"><a name="brick_size"></a><a name="s03_05_12_i44"><a name="brick_size, pattern modifier"></a><a name="s03_05_12_i45"><a name="s03_05_12_i46"><a name="mortar"></a><a name="s03_05_12_i47"><a name="mortar, pattern modifier"></a><a name="s03_05_12_i48"><a name="s03_05_12_i49"><a name="interpolate"></a><a name="s03_05_12_i50"><a name="interpolate, pattern modifier"></a><a name="s03_05_12_i51"><a name="s03_05_12_i52"><a name="control0"></a><a name="s03_05_12_i53"><a name="control0, pattern modifier"></a><a name="s03_05_12_i54"><a name="s03_05_12_i55"><a name="control1"></a><a name="s03_05_12_i56"><a name="control1, pattern modifier"></a><a name="s03_05_12_i57"><a name="s03_05_12_i58"><a name="warp"></a><a name="s03_05_12_i59"><a name="warp, pattern modifier"></a><a name="s03_05_12_i60">
<p>
  Pattern modifiers are statements or parameters which modify how a pattern is evaluated or tells what to do with the 
 pattern. The complete syntax is: 
</p>

<pre>
PATTERN_MODIFIER:
    BLEND_MAP_MODIFIER | AGATE_MODIFIER | DENSITY_FILE_MODIFIER |
    QUILTED_MODIFIER | BRICK_MODIFIER | SLOPE_MODIFIER |
    noise_generator Number| turbulence &lt;Amount&gt; |
    octaves Count | omega Amount | lambda Amount |
    warp { [WARP_ITEMS...] } | TRANSFORMATION
BLEND_MAP_MODIFIER:
    frequency Amount | phase Amount | ramp_wave | triangle_wave |
    sine_wave | scallop_wave | cubic_wave | poly_wave [Exponent]
AGATE_MODIFIER:
    agate_turb Value
BRICK_MODIFIER:
    brick_size Size | mortar Size 
DENSITY_FILE_MODIFIER:
    interpolate Type
SLOPE_MODIFIERS:
	&lt;Altitude&gt; 
	&lt;Lo_slope,Hi_slope&gt;
    &lt;Lo_alt,	Hi_alt&gt;
QUILTED_MODIFIER:
    control0 Value | control1 Value
PIGMENT_MODIFIER:
    PATTERN_MODIFIER | COLOR_LIST | PIGMENT_LIST |
    color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } |
    pigment_map{ PIGMENT_MAP_BODY } | quick_color COLOR |
    quick_colour COLOR
COLOR NORMAL_MODIFIER:
    PATTERN_MODIFIER | NORMAL_LIST |
    normal_map { NORMAL_MAP_BODY } | slope_map{ SLOPE_MAP_BODY } |
    bump_size Amount
TEXTURE_PATTERN_MODIFIER:
    PATTERN_MODIFIER | TEXTURE_LIST |
    texture_map{ TEXTURE_MAP_BODY }
DENSITY_MODIFIER:
    PATTERN_MODIFIER | DENSITY_LIST | COLOR_LIST |
    color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } |
    density_map { DENSITY_MAP_BODY }
</pre>

<p>
  Default values for pattern modifiers: <a name="s03_05_12_i61"> 
</p>

<pre>
dist_exp        : 0
falloff         : 2.0
frequency       : 1.0
lambda          : 2.0
major_radius    : 1
map_type        : 0
noise_generator : 2
octaves         : 6
omega           : 0.5  
orientation     : &lt;0,0,1&gt;
phase           : 0.0
poly_wave       : 1.0
strength        : 1.0
turbulence      : &lt;0,0,0&gt;
</pre>

<p>
  The modifiers <em>PIGMENT_LIST</em>, <code>quick_color</code>, and <code> pigment_map</code> apply only to 
 pigments. See section &quot;<a href="#l151">Pigment</a>&quot; for details on these pigment-specific pattern modifiers. 
</p>

<p>
  The modifiers <em> COLOR_LIST</em> and <code>color_map</code> apply only to pigments and densities. See sections 
 &quot;<a href="#l151">Pigment</a>&quot; and &quot;<a href="s_129.html#s03_06_02_03">Density</a>&quot; for details on 
 these pigment-specific pattern modifiers. 
</p>

<p>
  The modifiers <em> NORMAL_LIST</em>, <code>bump_size</code>, <code> slope_map</code> and <code> normal_map</code> 
 apply only to normals. See section &quot;<a href="#l152">Normal</a>&quot; for details on these normal-specific pattern 
 modifiers. 
</p>

<p>
  The <em>TEXTURE_LIST</em> and <code>texture_map</code> modifiers can only be used with patterned textures. See 
 section &quot;<a href="s_119.html#s03_05_05_01">Texture Maps</a>&quot; for details. 
</p>

<p>
  The <em> DENSITY_LIST</em> and <code> density_map</code> modifiers only work with <code>media{density{..}}</code> 
 statements. See &quot;<a href="s_129.html#s03_06_02_03">Density</a>&quot; for details. 
</p>

<p>
  The <code>agate_turb</code> modifier can only be used with the <code> agate</code> pattern. See &quot;<a href="s_125.html#s03_05_11_01">Agate</a>&quot; 
 for details. 
</p>

<p>
  The <code> brick_size</code> and <code>mortar</code> modifiers can only be used with the <code> brick</code> 
 pattern. See &quot;<a href="s_125.html#s03_05_11_05">Brick</a>&quot; for details. 
</p>

<p>
  The <code> control0</code> and <code>control1</code> modifiers can only be used with the <code>quilted</code> 
 pattern. See &quot;<a href="s_125.html#s03_05_11_27">Quilted</a>&quot; for details. 
</p>

<p>
  The <code> interpolate</code> modifier can only be used with the <code> density_file</code> pattern. See &quot;<a href="s_125.html#s03_05_11_11">Density_File</a>&quot; 
 for details. 
</p>

<p>
  The general purpose pattern modifiers in the following sections can be used with <code>pigment</code>, <code>normal</code>, 
 <code>texture</code>, or <code> density</code> patterns. 
</p>

<h4><a name="s03_05_12_01">3.5.12.1 </a>Transforming Patterns</h4>

<p>
  The most common pattern modifiers are the transformation modifiers <code> translate</code>, <code>rotate</code>, <code>scale</code>, 
 <code> transform</code>, and <code>matrix</code>. For details on these commands see section &quot;<a href="#l153">Transformations</a>&quot;. 
 
</p>

<p>
  These modifiers may be placed inside pigment, normal, texture, and density statements to change the position, size 
 and orientation of the patterns. 
</p>

<p>
  Transformations are performed in the order in which you specify them. However in general the order of 
 transformations relative to other pattern modifiers such as <code> turbulence</code>, <code> color_map</code> and 
 other maps is not important. For example scaling before or after turbulence makes no difference. The turbulence is 
 done first, then the scaling regardless of which is specified first. However the order in which transformations are 
 performed relative to <code>warp</code> statements is important. See &quot;Warps&quot; for details. 
</p>

<h4><a name="s03_05_12_02">3.5.12.2 </a>Frequency and Phase</h4>
<a name="s03_05_12_02_i1"><a name="s03_05_12_02_i2">
<p>
  The <code>frequency</code> and <code>phase</code> modifiers act as a type of scale and translate modifiers for 
 various blend maps. They only have effect when blend maps are used. Blend maps are <code> color_map</code>, <code>pigment_map</code>, 
 <code>normal_map</code>, <code> slope_map</code>, <code>density_map</code>, and <code>texture_map</code>. This 
 discussion uses a color map as an example but the same principles apply to the other blend map types. 
</p>

<p>
  The <code>frequency</code> keyword adjusts the number of times that a color map repeats over one cycle of a 
 pattern. For example <code> gradient</code> covers color map values 0 to 1 over the range from x=0 to x=1. By adding <code>frequency 
 2.0</code> the color map repeats twice over that same range. The same effect can be achieved using <code>scale 0.5*x</code> 
 so the frequency keyword is not that useful for patterns like gradient. 
</p>

<p>
  However the radial pattern wraps the color map around the +y-axis once. If you wanted two copies of the map (or 3 
 or 10 or 100) you would have to build a bigger map. Adding <code> frequency 2.0</code> causes the color map to be used 
 twice per revolution. Try this: 
</p>

<pre>
  pigment {
    radial
    color_map{[0.5 color Red][0.5 color White]}
    frequency 6
  }
</pre>

<p>
  The result is six sets of red and white radial stripes evenly spaced around the object. 
</p>

<p>
  The float after <code>frequency</code> can be any value. Values greater than 1.0 causes more than one copy of the 
 map to be used. Values from 0.0 to 1.0 cause a fraction of the map to be used. Negative values reverses the map. 
</p>

<p>
  The <code>phase</code> value causes the map entries to be shifted so that the map starts and ends at a different 
 place. In the example above if you render successive frames at <code>phase 0</code> then <code>phase 0.1</code>, <code>phase 
 0.2</code>, etc. you could create an animation that rotates the stripes. The same effect can be easily achieved by 
 rotating the <code> radial</code> pigment using <code> rotate y*Angle</code> but there are other uses where phase can 
 be handy. 
</p>

<p>
  Sometimes you create a great looking gradient or wood color map but you want the grain slightly adjusted in or out. 
 You could re-order the color map entries but that is a pain. A phase adjustment will shift everything but keep the 
 same scale. Try animating a <code>mandel</code> pigment for a color palette rotation effect. 
</p>

<p>
  These values work by applying the following formula 
</p>

<p>
  <em> New_Value = fmod ( Old_Value * Frequency + Phase, 1.0 ). </em> 
</p>

<p>
  The <code>frequency</code> and <code>phase</code> modifiers have no effect on block patterns <code> checker</code>, <code>brick</code>, 
 and <code> hexagon</code> nor do they effect <code>image_map</code>, <code> bump_map</code> or <code> material_map</code>. 
 They also have no effect in normal statements when used with <code>bumps</code>, <code>dents</code>, <code>quilted</code> 
 or <code> wrinkles</code> because these normal patterns cannot use <code> normal_map</code> or <code>slope_map</code>. 
</p>

<p>
  They can be used with normal patterns <code>ripples</code> and <code> waves</code> even though these two patterns 
 cannot use <code> normal_map</code> or <code>slope_map</code> either. When used with <code> ripples</code> or <code>waves</code>, 
 <code> frequency</code> adjusts the space between features and <code>phase</code> can be adjusted from 0.0 to 1.0 to 
 cause the ripples or waves to move relative to their center for animating the features. 
</p>

<h4><a name="s03_05_12_03">3.5.12.3 </a>Waveforms</h4>
<a name="s03_05_12_03_i1">
<p>
  POV-Ray allows you to apply various wave forms to the pattern function before applying it to a blend map. Blend 
 maps are <code>color_map</code>, <code>pigment_map</code>, <code>normal_map</code>, <code>slope_map</code>, <code>density_map</code>, 
 and <code>texture_map</code>. 
</p>

<p>
  Most of the patterns which use a blend map, use the entries in the map in order from 0.0 to 1.0. The effect can 
 most easily be seen when these patterns are used as normal patterns with no maps. Patterns such as <code> gradient</code> 
 or <code> onion</code> generate a groove or slot that looks like a ramp that drops off sharply. This is called a <code>ramp_wave</code> 
 wave type and it is the default wave type for most patterns. However the <code>wood</code> and <code> marble</code> 
 patterns use the map from 0.0 to 1.0 and then reverses it and runs it from 1.0 to 0.0. The result is a wave form which 
 slopes upwards to a peak, then slopes down again in a <code> triangle_wave</code>. In earlier versions of POV-Ray 
 there was no way to change the wave types. You could simulate a triangle wave on a ramp wave pattern by duplicating 
 the map entries in reverse, however there was no way to use a ramp wave on wood or marble. 
</p>

<p>
  Now any pattern that takes a map can have the default wave type overridden. For example: 
</p>

<pre>
  pigment { wood color_map { MyMap } ramp_wave }
</pre>
<a name="s03_05_12_03_i2"><a name="s03_05_12_03_i3"><a name="s03_05_12_03_i4"><a name="s03_05_12_03_i5">
<p>
  Also available are <code>sine_wave</code>, <code>scallop_wave</code>, <code>cubic_wave</code> and <code>poly_wave</code> 
 types. These types are of most use in normal patterns as a type of built-in slope map. The <code> sine_wave</code> 
 takes the zig-zag of a ramp wave and turns it into a gentle rolling wave with smooth transitions. The <code>scallop_wave</code> 
 uses the absolute value of the sine wave which looks like corduroy when scaled small or like a stack of cylinders when 
 scaled larger. The <code> cubic_wave</code> is a gentle cubic curve from 0.0 to 1.0 with zero slope at the start and 
 end. The <code>poly_wave</code> is an exponential function. It is followed by an optional float value which specifies 
 exponent. For example <code>poly_wave 2</code> starts low and climbs rapidly at the end while <code>poly_wave 0.5</code> 
 climbs rapidly at first and levels off at the end. If no float value is specified, the default is 1.0 which produces a 
 linear function identical to <code>ramp_wave</code>. 
</p>

<p>
  Although any of these wave types can be used for pigments, normals, textures, or density the effect of many of the 
 wave types are not as noticeable on pigments, textures, or density as they are for normals. 
</p>

<p>
  Wave type modifiers have no effect on block patterns <code> checker</code>, <code>brick</code>, <code>object</code> 
 and <code>hexagon</code> nor do they effect <code> image_map</code>, <code>bump_map</code> or <code> material_map</code>. 
 They also have no effect in normal statements when used with <code>bumps</code>, <code>dents</code>, <code>quilted</code>, 
 <code> ripples</code>, <code> waves</code>, or <code>wrinkles</code> because these normal patterns cannot use <code>normal_map</code> 
 or <code> slope_map</code>. 
</p>

<h4><a name="s03_05_12_04">3.5.12.4 </a>Noise Generators</h4>
<a name="s03_05_12_04_i1"><a name="noise generator, pattern modifier"></a>
<p>
  There are three noise generators implemented. Changing the <code>noise_generator</code> will change the appearance 
 of noise based patterns, like bozo and granite. 
</p>

<ul>
 
 <li>
   <code>noise_generator 1</code> the noise that was used in POV_Ray 3.1 
 </li>

 <li>
   <code>noise_generator 2</code> 'range corrected' version of the old noise, it does not show the plateaus seen 
  with <code>noise_generator 1</code> 
 </li>

 <li>
   <code>noise_generator 3</code> generates Perlin noise 
 </li>

</ul>

<p>
  The default is <code>noise_generator 2</code> 
</p>

<p class="Note">
  <strong>Note:</strong> The noise_generator can also be set in <code>global_settings</code> 
</p>

<h4><a name="s03_05_12_05">3.5.12.5 </a>Turbulence</h4>

<p>
  The <code>turbulence</code> pattern modifier is still supported for compatibility issues, but it is better nowadays 
 to use the <code><a href="#l154">warp {turbulence}</a></code> feature, which does not have turbulence's limitation in 
 transformation order (turbulence is always applied first, before any scale, translate or rotate, whatever the order 
 you specify). For a detailed discussion see <a href="s_126.html#s03_05_12_06_03">'Turbulence versus Turbulence Warp'</a> 
 
</p>

<p>
  The old-style turbulence is handled slightly differently when used with the agate, marble, spiral1, spiral2, and 
 wood textures. 
</p>

<h4><a name="s03_05_12_06">3.5.12.6 </a>Warps</h4>
<a name="s03_05_12_06_i1"><a name="warp, keyword"></a><a name="s03_05_12_06_i2"><a name="warp, pattern modifier"></a><a name="s03_05_12_06_i3"><a name="s03_05_12_06_i4"><a name="s03_05_12_06_i5"><a name="repeat, warp"></a><a name="s03_05_12_06_i6"><a name="s03_05_12_06_i7"><a name="black_hole, warp"></a><a name="s03_05_12_06_i8"><a name="s03_05_12_06_i9"><a name="turbulence, warp"></a><a name="s03_05_12_06_i10"><a name="s03_05_12_06_i11"><a name="cylindrical, warp"></a><a name="s03_05_12_06_i12"><a name="s03_05_12_06_i13"><a name="dist_exp, warp"></a><a name="s03_05_12_06_i14"><a name="s03_05_12_06_i15"><a name="spherical, warp"></a><a name="s03_05_12_06_i16"><a name="s03_05_12_06_i17"><a name="toroidal, warp"></a><a name="s03_05_12_06_i18"><a name="s03_05_12_06_i19"><a name="orientation, warp"></a><a name="s03_05_12_06_i20"><a name="s03_05_12_06_i21"><a name="planar, warp"></a><a name="s03_05_12_06_i22"><a name="s03_05_12_06_i23"><a name="offset, warp"></a><a name="s03_05_12_06_i24"><a name="s03_05_12_06_i25"><a name="flip, warp"></a><a name="s03_05_12_06_i26"><a name="s03_05_12_06_i27"><a name="strength, warp"></a><a name="s03_05_12_06_i28"><a name="s03_05_12_06_i29"><a name="falloff, warp"></a><a name="s03_05_12_06_i30"><a name="s03_05_12_06_i31"><a name="inverse, warp"></a><a name="s03_05_12_06_i32"><a name="s03_05_12_06_i33"><a name="octaves, warp"></a><a name="s03_05_12_06_i34"><a name="s03_05_12_06_i35"><a name="omega, warp"></a><a name="s03_05_12_06_i36"><a name="s03_05_12_06_i37"><a name="lambda, warp"></a><a name="s03_05_12_06_i38">
<p>
  The <code>warp</code> statement is a pattern modifier that is similar to turbulence. Turbulence works by taking the 
 pattern evaluation point and pushing it about in a series of random steps. However warps push the point in very 
 well-defined, non-random, geometric ways. The <code>warp</code> statement also overcomes some limitations of 
 traditional turbulence and transformations by giving the user more control over the order in which turbulence, 
 transformation and warp modifiers are applied to the pattern. 
</p>

<p>
  Currently there are seven types of warps but the syntax was designed to allow future expansion. The turbulence warp 
 provides an alternative way to specify turbulence. The others modify the pattern in geometric ways. 
</p>

<p>
  The syntax for using a <code>warp</code> statement is: 
</p>

<pre>
WARP:
    warp { WARP_ITEM }
WARP_ITEM:
    repeat &lt;Direction&gt; [REPEAT_ITEMS...] |
    black_hole &lt;Location&gt;, Radius [BLACK_HOLE_ITEMS...] | 
    turbulence &lt;Amount&gt; [TURB_ITEMS...]
    cylindrical  [ orientation VECTOR | dist_exp FLOAT ]
    spherical  [ orientation VECTOR | dist_exp FLOAT ]
    toroidal  [ orientation VECTOR | dist_exp FLOAT |
                major_radius FLOAT ]
    planar [ VECTOR , FLOAT ]
REPEAT_ITEMS:
    offset &lt;Amount&gt; | 
    flip &lt;Axis&gt;
BLACK_HOLE_ITEMS:
    strength Strength | falloff Amount | inverse |
    repeat &lt;Repeat&gt; | turbulence &lt;Amount&gt;
TURB_ITEMS:
    octaves Count | omega Amount | lambda Amount
</pre>

<p>
  You may have as many separate warp statements as you like in each pattern. The placement of warp statements 
 relative to other modifiers such as <code> color_map</code> or <code>turbulence</code> is not important. However 
 placement of warp statements relative to each other and to transformations is significant. Multiple warps and 
 transformations are evaluated in the order in which you specify them. For example if you translate, then warp or warp, 
 then translate, the results can be different. 
</p>

<h5><a name="s03_05_12_06_01">3.5.12.6.1 </a>Black Hole Warp</h5>
<a name="s03_05_12_06_01_i1"><a name="black_hole"></a><a name="s03_05_12_06_01_i2"><a name="s03_05_12_06_01_i3"><a name="strength, black_hole warp"></a><a name="s03_05_12_06_01_i4"><a name="s03_05_12_06_01_i5">
<p>
  A <code>black_hole</code> warp is so named because of its similarity to real black holes. Just like the real thing, 
 you cannot actually see a black hole. The only way to detect its presence is by the effect it has on things that 
 surround it. 
</p>

<p>
  Take, for example, a wood grain. Using POV-Ray's normal turbulence and other texture modifier functions, you can 
 get a nice, random appearance to the grain. But in its randomness it is regular - it is regularly random! Adding a 
 black hole allows you to create a localized disturbance in a wood grain in either one or multiple locations. The black 
 hole can have the effect of either <em>sucking</em> the surrounding texture into itself (like the real thing) or <em>pushing</em> 
 it away. In the latter case, applied to a wood grain, it would look to the viewer as if there were a knothole in the 
 wood. In this text we use a wood grain regularly as an example, because it is ideally suitable to explaining black 
 holes. However, black holes may in fact be used with any texture or pattern. The effect that the black hole has on the 
 texture can be specified. By default, it <em>sucks</em> with the strength calculated exponentially (inverse-square). 
 You can change this if you like. 
</p>

<p>
  Black holes may be used anywhere a warp is permitted. The syntax is: 
</p>

<pre>
BLACK_HOLE_WARP:
    warp
    {
        black_hole &lt;Location&gt;, Radius
        [BLACK_HOLE_ITEMS...]
    }
BLACK_HOLE_ITEMS:
    strength Strength | falloff Amount | inverse | type Type | 
    repeat &lt;Repeat&gt; | turbulence &lt;Amount&gt;
</pre>

<p>
  The minimal requirement is the <code>black_hole</code> keyword followed by a vector <em><code>&lt;Location&gt;</code></em> 
 followed by a comma and a float <em><code>Radius</code></em>. Black holes effect all points within the spherical 
 region around the location and within the radius. This is optionally followed by any number of other keywords which 
 control how the texture is warped. 
</p>

<p>
  The <code>falloff</code> keyword may be used with a float value to specify the power by which the effect of the 
 black hole falls off. The default is two. The force of the black hole at any given point, before applying the <code>strength</code> 
 modifier, is as follows. 
</p>

<p>
  First, convert the distance from the point to the center to a proportion (0 to 1) that the point is from the edge 
 of the black hole. A point on the perimeter of the black hole will be 0.0; a point at the center will be 1.0; a point 
 exactly halfway will be 0.5, and so forth. Mentally you can consider this to be a closeness factor. A closeness of 1.0 
 is as close as you can get to the center (i.e. at the center), a closeness of 0.0 is as far away as you can get from 
 the center and still be inside the black hole and a closeness of 0.5 means the point is exactly halfway between the 
 two. 
</p>

<p>
  Call this value c. Raise c to the power specified in <code>falloff</code>. By default Falloff is 2, so this is c^2 
 or c squared. The resulting value is the force of the black hole at that exact location and is used, after applying 
 the <code>strength</code> scaling factor as described below, to determine how much the point is perturbed in space. 
 For example, if c is 0.5 the force is 0.5^2 or 0.25. If c is 0.25 the force is 0.125. But if c is exactly 1.0 the 
 force is 1.0. Recall that as c gets smaller the point is farther from the center of the black hole. Using the default 
 power of 2, you can see that as c reduces, the force reduces exponentially in an inverse-square relationship. Put in 
 plain English, it means that the force is much stronger (by a power of two) towards the center than it is at the 
 outside. 
</p>

<p>
  By increasing <code>falloff</code>, you can increase the magnitude of the falloff. A large value will mean points 
 towards the perimeter will hardly be affected at all and points towards the center will be affected strongly. A value 
 of 1.0 for <code>falloff</code> will mean that the effect is linear. A point that is exactly halfway to the center of 
 the black hole will be affected by a force of exactly 0.5. A value of <code>falloff</code> of less than one but 
 greater than zero means that as you get closer to the outside, the force increases rather than decreases. This can 
 have some uses but there is a side effect. Recall that the effect of a black hole ceases outside its perimeter. This 
 means that points just within the perimeter will be affected strongly and those just outside not at all. This would 
 lead to a visible border, shaped as a sphere. A value for <code> falloff</code> of 0 would mean that the force would 
 be 1.0 for all points within the black hole, since any number larger 0 raised to the power of 0 is 1.0. 
</p>

<p>
  The <code>strength</code> keyword may be specified with a float value to give you a bit more control over how much 
 a point is perturbed by the black hole. Basically, the force of the black hole (as determined above) is multiplied by 
 the value of <code>strength</code>, which defaults to 1.0. If you set strength to 0.5, for example, all points within 
 the black hole will be moved by only half as much as they would have been. If you set it to 2.0 they will be moved 
 twice as much. 
</p>

<p>
  There is a rider to the latter example, though - the movement is clipped to a maximum of the original distance from 
 the center. That is to say, a point that is 0.75 units from the center may only be moved by a maximum of 0.75 units 
 either towards the center or away from it, regardless of the value of <code> strength</code>. The result of this 
 clipping is that you will have an exclusion area near the center of the black hole where all points whose final force 
 value exceeded or equaled 1.0 were moved by a fixed amount. 
</p>

<p>
  If the <code>inverse</code> keyword is specified then the points <em> pushed</em> away from the center instead of 
 being pulled in. 
</p>

<p>
  The <code>repeat</code> keyword followed by a vector, allows you to simulate the effect of many black holes without 
 having to explicitly declare them. Repeat is a vector that tells POV-Ray to use this black hole at multiple locations. 
 Using <code>repeat</code> logically divides your scene up into cubes, the first being located at &lt;0,0,0&gt; and 
 going to <em><code> &lt;Repeat&gt;</code></em>. Suppose your repeat vector was &lt;1,5,2&gt;. The first cube would be 
 from &lt;0,0,0&gt; to &lt; 1,5,2&gt;. This cube repeats, so there would be one at &lt; -1,-5,-2&gt;, &lt;1,5,2&gt;, 
 &lt;2,10,4&gt; and so forth in all directions, ad infinitum. 
</p>

<p>
  When you use <code>repeat</code>, the center of the black hole does not specify an absolute location in your scene 
 but an offset into each block. It is only possible to use positive offsets. Negative values will produce undefined 
 results. 
</p>

<p>
  Suppose your center was &lt;0.5,1,0.25&gt; and the repeat vector is &lt;2,2,2&gt;. This gives us a block at &lt; 
 0,0,0&gt; and &lt;2,2,2&gt;, etc. The centers of the black hole's for these blocks would be &lt;0,0,0&gt; + &lt; 
 0.5,1.0,0.25&gt;, i. e. &lt;0.5,1.0,0.25&gt;, and &lt; 2,2,2&gt; + &lt;0.5,1.0,0.25&gt;, i. e. &lt; 2,5,3.0,2.25&gt;. 
</p>

<p>
  Due to the way repeats are calculated internally, there is a restriction on the values you specify for the repeat 
 vector. Basically, each black hole must be totally enclosed within each block (or cube), with no part crossing into a 
 neighboring one. This means that, for each of the x, y and z dimensions, the offset of the center may not be less than 
 the radius, and the repeat value for that dimension must be &gt;=the center plus the radius since any other values 
 would allow the black hole to cross a boundary. Put another way, for each of x, y and z 
</p>

<p>
  Radius &lt;= Offset or Center &lt;= Repeat - Radius. 
</p>

<p>
  If the repeat vector in any dimension is too small to fit this criteria, it will be increased and a warning message 
 issued. If the center is less than the radius it will also be moved but no message will be issued. 
</p>

<p>
  Note that none of the above should be read to mean that you cannot overlap black holes. You most certainly can and 
 in fact this can produce some most useful effects. The restriction only applies to elements of the <code> same</code> 
 black hole which is repeating. You can declare a second black hole that also repeats and its elements can quite 
 happily overlap the first and causing the appropriate interactions. It is legal for the repeat value for any dimension 
 to be 0, meaning that POV-Ray will not repeat the black hole in that direction. 
</p>

<p>
  The <code>turbulence</code> can only be used in a black hole with <code> repeat</code>. It allows an element of 
 randomness to be inserted into the way the black holes repeat, to cause a more natural look. A good example would be 
 an array of knotholes in wood - it would look rather artificial if each knothole were an exact distance from the 
 previous. 
</p>

<p>
  The <code> turbulence</code> vector is a measurement that is added to each individual black hole in an array, after 
 each axis of the vector is multiplied by a different random amount ranging from 0 to 1. The resulting actual position 
 of the black hole's center for that particular repeat element is random (but consistent, so renders will be 
 repeatable) and somewhere within the above coordinates. There is a rider on the use of turbulence, which basically is 
 the same as that of the repeat vector. You cannot specify a value which would cause a black hole to potentially cross 
 outside of its particular block. 
</p>

<p>
  In summary: For each of x, y and z the offset of the center must be &gt;=radius and the value of the repeat must be 
 &gt;= center + radius + turbulence. The exception being that repeat may be 0 for any dimension, which means do not 
 repeat in that direction. 
</p>

<p>
  Some examples are given by 
</p>

<pre>
  warp {
    black_hole &lt;0, 0, 0&gt;, 0.5
  }
  warp {
    black_hole &lt;0.15, 0.125, 0&gt;, 0.5
    falloff 7
    strength 1.0
    repeat &lt;1.25, 1.25, 0&gt;
    turbulence &lt;0.25, 0.25, 0&gt;
    inverse
  }
  warp {
    black_hole &lt;0, 0, 0&gt;, 1.0
    falloff 2
    strength 2
    inverse
  }
</pre>

<h5><a name="s03_05_12_06_02">3.5.12.6.2 </a>Repeat Warp</h5>
<a name="s03_05_12_06_02_i1"><a name="repeat"></a>
<p>
  The <code>repeat</code> warp causes a section of the pattern to be repeated over and over. It takes a slice out of 
 the pattern and makes multiple copies of it side-by-side. The warp has many uses but was originally designed to make 
 it easy to model wood veneer textures. Veneer is made by taking very thin slices from a log and placing them 
 side-by-side on some other backing material. You see side-by-side nearly identical ring patterns but each will be a 
 slice perhaps 1/32th of an inch deeper. 
</p>

<p>
  The syntax for a repeat warp is 
</p>

<pre>
REPEAT_WARP:
    warp { repeat &lt;Direction&gt; [REPEAT_ITEMS...] }
REPEAT_ITEMS:
    offset &lt;Amount&gt; | flip &lt;Axis&gt;
</pre>

<p>
  The <code>repeat</code> vector specifies the direction in which the pattern repeats and the width of the repeated 
 area. This vector must lie entirely along an axis. In other words, two of its three components must be 0. For example 
</p>

<pre>
  pigment {
    wood
    warp { repeat 2*x }
  }
</pre>
<a name="s03_05_12_06_02_i2"><a name="offset"></a><a name="s03_05_12_06_02_i3"><a name="offset, repeat warp"></a>
<p>
  which means that from x=0 to x=2 you get whatever the pattern usually is. But from x=2 to x=4 you get the same 
 thing exactly shifted two units over in the x-direction. To evaluate it you simply take the x-coordinate modulo 2. 
 Unfortunately you get exact duplicates which is not very realistic. The optional <code>offset</code> vector tells how 
 much to translate the pattern each time it repeats. For example 
</p>

<pre>
  pigment {
    wood
    warp {repeat x*2  offset z*0.05}
  }
</pre>

<p>
  means that we slice the first copy from x=0 to x=2 at z=0 but at x=2 to x=4 we offset to z=0.05. In the 4 to 6 
 interval we slice at z=0.10. At the n-th copy we slice at 0.05 n z. Thus each copy is slightly different. There are no 
 restrictions on the offset vector. 
</p>

<p>
  <a name="s03_05_12_06_02_i4"><a name="flip"></a> Finally the <code>flip</code> vector causes the pattern to be 
 flipped or mirrored every other copy of the pattern. The first copy of the pattern in the positive direction from the 
 axis is not flipped. The next farther is, the next is not, etc. The flip vector is a three component x, y, z vector 
 but each component is treated as a boolean value that tells if you should or should not flip along a given axis. For 
 example 
</p>

<pre>
  pigment {
    wood
    warp {repeat 2*x  flip &lt;1,1,0&gt;}
  }
</pre>

<p>
  means that every other copy of the pattern will be mirrored about the x- and y- axis but not the z-axis. A non-zero 
 value means flip and zero means do not flip about that axis. The magnitude of the values in the flip vector does not 
 matter. 
</p>

<h5><a name="s03_05_12_06_03">3.5.12.6.3 </a>Turbulence versus Turbulence Warp</h5>
<a name="s03_05_12_06_03_i1">
<p>
  The POV-Ray language contains an ambiguity and limitation on the way you specify <code>turbulence</code> and 
 transformations such as <code> translate</code>, <code>rotate</code>, <code>scale</code>, <code> matrix</code>, and <code>transform</code> 
 transforms. Usually the turbulence is done first. Then all translate, rotate, scale, matrix, and transform operations 
 are always done after turbulence regardless of the order in which you specify them. For example this 
</p>

<pre>
 pigment {
   wood
   scale .5
   turbulence .2
 }
</pre>

<p>
  works exactly the same as 
</p>

<pre>
 pigment {
   wood
   turbulence .2
   scale .5
 }
</pre>

<p>
  The turbulence is always first. A better example of this limitation is with uneven turbulence and rotations. 
</p>

<pre>
  pigment {
    wood
    turbulence 0.5*y
    rotate z*60
  }
  // as compared to
  pigment {
   wood
   rotate z*60
   turbulence 0.5*y
  }
</pre>

<p>
  The results will be the same either way even though you would think it should look different. 
</p>

<p>
  We cannot change this basic behavior in POV-Ray now because lots of scenes would potentially render differently if 
 suddenly the order transformation vs. turbulence mattered when in the past, it did not. 
</p>

<p>
  However, by specifying our turbulence inside warp statement you tell POV-Ray that the order in which turbulence, 
 transformations and other warps are applied is significant. Here is an example of a turbulence warp. 
</p>

<pre>
  warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
</pre>

<p>
  The significance is that this 
</p>

<pre>
 pigment {
   wood
   translate &lt;1,2,3&gt; rotate x*45 scale 2
   warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
 }
</pre>

<p>
  produces <em>different results</em> than this... 
</p>

<pre>
 pigment {
   wood
   warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
   translate &lt;1,2,3&gt; rotate x*45 scale 2
 }
</pre>

<p>
  You may specify turbulence without using a warp statement. However you cannot control the order in which they are 
 evaluated unless you put them in a warp. 
</p>

<p>
  The evaluation rules are as follows: 
</p>

<ol>
 
 <li>
   First any turbulence not inside a warp statement is applied regardless of the order in which it appears relative 
  to warps or transformations. 
 </li>

 <li>
   Next each warp statement, translate, rotate, scale or matrix one-by-one, is applied in the order the user 
  specifies. If you want turbulence done in a specific order, you simply specify it inside a warp in the proper place. 
 </li>

</ol>

<h5><a name="s03_05_12_06_04">3.5.12.6.4 </a>Turbulence Warp</h5>

<p>
  Inside the <code>warp</code> statement, the keyword <code>turbulence</code> followed by a float or vector may be 
 used to stir up any <code>pigment</code>, <code>normal</code> or <code>density</code>. A number of optional parameters 
 may be used with turbulence to control how it is computed. The syntax is: 
</p>

<pre>
TURBULENCE_ITEM:
    turbulence &lt;Amount&gt; | octaves Count |
    omega Amount | lambda Amount
</pre>

<p>
  Typical turbulence values range from the default 0.0, which is no turbulence, to 1.0 or more, which is very 
 turbulent. If a vector is specified different amounts of turbulence are applied in the x-, y- and z-direction. For 
 example 
</p>

<pre>
  turbulence &lt;1.0, 0.6, 0.1&gt;
</pre>

<p>
  has much turbulence in the x-direction, a moderate amount in the y-direction and a small amount in the z-direction. 
</p>

<p>
  Turbulence uses a random noise function called <em>DNoise</em>. This is similar to the noise used in the <code>bozo</code> 
 pattern except that instead of giving a single value it gives a direction. You can think of it as the direction that 
 the wind is blowing at that spot. Points close together generate almost the same value but points far apart are 
 randomly different. 
</p>

<p>
  Turbulence uses <em>DNoise</em> to push a point around in several steps called <code>octaves</code>. We locate the 
 point we want to evaluate, then push it around a bit using turbulence to get to a different point then look up the 
 color or pattern of the new point. 
</p>

<p>
  It says in effect <em> &quot;Do not give me the color at this spot... take a few random steps in different 
 directions and give me that color&quot;</em>. Each step is typically half as long as the one before. For example: 
</p>

<p>
  <img alt="Turbulence random walk." src="images/reference/turbrand.png"> 
</p>

<p>
  The magnitude of these steps is controlled by the turbulence value. There are three additional parameters which 
 control how turbulence is computed. They are <code>octaves</code>, <code>lambda</code> and <code> omega</code>. Each 
 is optional. Each is followed by a single float value. Each has no effect when there is no turbulence. <h6>Octaves</h6><a name="s03_05_12_06_04_i1"> 
 
</p>

<p>
  The <code>octaves</code> keyword may be followed by an integer value to control the number of steps of turbulence 
 that are computed. Legal values range from 1 to &lt;10. The default value of 6 is a fairly high value; you will not 
 see much change by setting it to a higher value because the extra steps are too small. Float values are truncated to 
 integer. Smaller numbers of octaves give a gentler, wavy turbulence and computes faster. Higher octaves create more 
 jagged or fuzzy turbulence and takes longer to compute.<h6>Lambda</h6><a name="s03_05_12_06_04_i2"> 
 
</p>

<p>
  The <code>lambda</code> parameter controls how statistically different the random move of an octave is compared to 
 its previous octave. The default value is 2.0 which is quite random. Values close to lambda 1.0 will straighten out 
 the randomness of the path in the diagram above. The zig-zag steps in the calculation are in nearly the same 
 direction. Higher values can look more <em>swirly</em> under some circumstances.<h6>Omega</h6><a name="s03_05_12_06_04_i3"> 
 
</p>

<p>
  The <code>omega</code> value controls how large each successive octave step is compared to the previous value. Each 
 successive octave of turbulence is multiplied by the omega value. The default <code>omega 0.5</code> means that each 
 octave is 1/2 the size of the previous one. Higher omega values mean that 2nd, 3rd, 4th and up octaves contribute more 
 turbulence giving a sharper, <em>crinkly</em> look while smaller omegas give a fuzzy kind of turbulence that gets 
 blurry in places. 
</p>

<h5><a name="s03_05_12_06_05">3.5.12.6.5 </a>Mapping using warps</h5>
<a name="s03_05_12_06_05_i1"><a name="toroidal"></a><a name="s03_05_12_06_05_i2"><a name="orientation"></a><a name="s03_05_12_06_05_i3"><a name="dist_exp"></a><a name="s03_05_12_06_05_i4"><a name="major_radius"></a><a name="s03_05_12_06_05_i5"><a name="s03_05_12_06_05_i6"><a name="s03_05_12_06_05_i7"><a name="s03_05_12_06_05_i8"><a name="s03_05_12_06_05_i9"><a name="s03_05_12_06_05_i10"><a name="s03_05_12_06_05_i11"><a name="s03_05_12_06_05_i12">
<p>
  Syntax: 
</p>

<pre>
  CYLINDRICAL_WARP:
    warp { cylindrical [CYLINDRICAL_ITEMS...]}
  CYLINDRICAL_ITEMS:  
    orientation VECTOR | dist_exp FLOAT
  SPHERICAL_WARP:
    warp { spherical [SPHERICAL_ITEMS...]}
  SPHERICAL_ITEMS:  
    orientation VECTOR | dist_exp FLOAT
  TOROIDAL_WARP:
    warp { toroidal [TOROIDAL_ITEMS...]}
  TOROIDAL_ITEMS:  
    orientation VECTOR | dist_exp FLOAT | major_radius FLOAT
  PLANAR_WARP:
    warp { planar [ VECTOR , FLOAT ]}
  </pre>

<p>
  With the <code>cylindrical, spherical</code> and <code>toroidal</code> warps you can wrap checkers, bricks and 
 other patterns around cylinders, spheres, toruses and other objects. In essence, these warps use the same mapping as 
 the image maps use. 
</p>

<p>
  However it does 3D mapping and some concession had to be made on depth. This is controllable by <code>dist_exp</code> 
 (distance exponent). In the default of 0, imagine a box &lt;0,0&gt; to &lt;1,1&gt; (actually it is &lt;0,0&gt;, &lt;<code>dist^dist_exp,dist^dist_exp</code>&gt;) 
 stretching to infinity along the orientation vector. The warp takes its points from that box. 
</p>

<p>
  For a sphere <code>distance</code> is distance from origin, cylinder is distance from y-axis, torus is distance 
 from major radius. (or distance is minor radius if you prefer to look at it that way) 
</p>

<p>
  Defaults: <code> orientation &lt;0,0,1&gt;<br> dist_exp 0<br> major_radius 1<br> </code> 
</p>

<p>
  Examples: 
</p>

<pre>
   torus {
     1, 0.5
     pigment {
       hexagon
       scale 0.1
       warp {
         toroidal 
         orientation y 
         dist_exp 1 
         major_radius 1
       }
     }
   }
   sphere {
     0,1
     pigment {
       hexagon
       scale &lt;0.5/pi,0.25/pi,1&gt;*0.1
       warp {
         spherical
         orientation y 
         dist_exp 1 
       }
     }
   }
   cylinder {
     -y, y, 1
     pigment {
       hexagon
       scale &lt;0.5/pi, 1, 1&gt;*0.1
       warp {
         cylindrical 
         orientation y 
         dist_exp 1 
       }
     }
   }
</pre>

<p>
  The <code>planar</code> warp was made to make a pattern act like an image_map, of infinite size and can be useful 
 in combination with other mapping-warps. By default the pigment in the XY-plane is extruded along the Z-axis. The 
 pigment can be taken from an other plane, by specifying the optional vector (normal of the plane) and float (distance 
 along the normal). The result, again, is extruded along the Z-axis. 
</p>

<h4><a name="s03_05_12_07">3.5.12.7 </a>Bitmap Modifiers</h4>

<p>
  A bitmap modifier is a modifier used inside an <code>image_map</code>, <code>bump_map</code> or <code>material_map</code> 
 to specify how the 2-D bitmap is to be applied to the 3-D surface. Several bitmap modifiers apply to specific kinds of 
 maps and they are covered in the appropriate sections. The bitmap modifiers discussed in the following sections are 
 applicable to all three types of bitmaps. 
</p>

<h5><a name="s03_05_12_07_01">3.5.12.7.1 </a>The once Option</h5>
<a name="s03_05_12_07_01_i1"><a name="once"></a>
<p>
  Normally there are an infinite number of repeating image maps, bump maps or material maps created over every unit 
 square of the x-y-plane like tiles. By adding the <code>once</code> keyword after a file name you can eliminate all 
 other copies of the map except the one at (0,0) to (1,1). In image maps, areas outside this unit square are treated as 
 fully transparent. In bump maps, areas outside this unit square are left flat with no normal modification. In material 
 maps, areas outside this unit square are textured with the first texture of the texture list. 
</p>

<p>
  For example: 
</p>

<pre>
  image_map {
    gif &quot;mypic.gif&quot;
    once
  }
</pre>

<h5><a name="s03_05_12_07_02">3.5.12.7.2 </a>The map_type Option</h5>
<a name="s03_05_12_07_02_i1"><a name="map_type"></a>
<p>
  The default projection of the image onto the x-y-plane is called a <em> planar map type</em>. This option may be 
 changed by adding the <code> map_type</code> keyword followed by an integer number specifying the way to wrap the 
 image around the object. 
</p>

<p>
  A <code>map_type 0</code> gives the default planar mapping already described. 
</p>

<p>
  A <code>map_type 1</code> gives a spherical mapping. It assumes that the object is a sphere of any size sitting at 
 the origin. The y-axis is the north/south pole of the spherical mapping. The top and bottom edges of the image just 
 touch the pole regardless of any scaling. The left edge of the image begins at the positive x-axis and wraps the image 
 around the sphere from west to east in a -y-rotation. The image covers the sphere exactly once. The <code> once</code> 
 keyword has no meaning for this mapping type. 
</p>

<p>
  With <code> map_type 2</code> you get a cylindrical mapping. It assumes that a cylinder of any diameter lies along 
 the y-axis. The image wraps around the cylinder just like the spherical map but the image remains one unit tall from 
 y=0 to y=1. This band of color is repeated at all heights unless the <code> once</code> keyword is applied. 
</p>

<p>
  Finally <code>map_type 5</code> is a torus or donut shaped mapping. It assumes that a torus of major radius one 
 sits at the origin in the x-z-plane. The image is wrapped around similar to spherical or cylindrical maps. However the 
 top and bottom edges of the map wrap over and under the torus where they meet each other on the inner rim. 
</p>

<p>
  Types 3 and 4 are still under development. 
</p>

<p class="Note">
  <strong>Note:</strong> that the <code> map_type</code> option may also be applied to <code> bump_map</code> 
 and <code>material_map</code> statements. 
</p>

<p>
  For example: 
</p>

<pre>
  sphere{&lt;0,0,0&gt;,1
    pigment{
      image_map {
        gif &quot;world.gif&quot;
        map_type 1
      }
    }
  }
</pre>

<h5><a name="s03_05_12_07_03">3.5.12.7.3 </a>The interpolate Option</h5>
<a name="s03_05_12_07_03_i1">
<p>
  Adding the <code>interpolate</code> keyword can smooth the jagged look of a bitmap. When POV-Ray checks a color for 
 an image map or a bump amount for a bump map, it often checks a point that is not directly on top of one pixel but 
 sort of between several differently colored pixels. Interpolations return an in-between value so that the steps 
 between the pixels in the map will look smoother. 
</p>

<p>
  Although <code>interpolate</code> is legal in material maps, the color index is interpolated before the texture is 
 chosen. It does not interpolate the final color as you might hope it would. In general, interpolation of material maps 
 serves no useful purpose but this may be fixed in future versions. 
</p>

<p>
  There are currently two types of interpolation: <code> interpolate 2</code> gives bilinear interpolation while <code>interpolate 
 4</code> gives normalized distance. For example: 
</p>

<pre>
  image_map {
    gif &quot;mypic.gif&quot;
    interpolate 2
  }
</pre>

<p>
  Default is no interpolation. Normalized distance is the slightly faster of the two, bilinear does a better job of 
 picking the between color. Normally bilinear is used. 
</p>

<p>
  If your map looks jaggy, try using interpolation instead of going to a higher resolution image. The results can be 
 very good. 
</p>

<p>
 <a name="l151">
<small><strong>More about &quot;Pigment&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_115.html#s03_05_01">3.5.1 Pigment</a> in 3.5 Textures
  </small>

  <li><small>
   <a href="s_162.html#s03_08_10_04">3.8.10.4 Pigment</a> in 3.8.10 Texture
  </small>

  <li><small>
   <a href="s_69.html#s02_03_04_01">2.3.4.1 Pigments</a> in 2.3.4 Advanced Texture Options
  </small>

 </ul>

</p>

<p>
 <a name="l152">
<small><strong>More about &quot;Normal&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_116.html#s03_05_02">3.5.2 Normal</a> in 3.5 Textures
  </small>

  <li><small>
   <a href="s_162.html#s03_08_10_05">3.8.10.5 Normal</a> in 3.8.10 Texture
  </small>

  <li><small>
   <a href="s_69.html#s02_03_04_02">2.3.4.2 Normals</a> in 2.3.4 Advanced Texture Options
  </small>

 </ul>

</p>

<p>
 <a name="l153">
<small><strong>More about &quot;Transformations&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_157.html#s03_08_05">3.8.5 Transformations</a> in 3.8 Quick Reference
  </small>

  <li><small>
   <a href="s_63.html#s02_02_07_01">2.2.7.1 Transformations</a> in 2.2.7 POV-Ray Coordinate System
  </small>

 </ul>

</p>

<p>
 <a name="l154">
<small><strong>More about &quot;warp {turbulence}&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_126.html#s03_05_12_06">3.5.12.6 Warps</a> in 3.5.12 Pattern Modifiers
  </small>

  <li><small>
   <a href="s_126.html#s03_05_12_06_04">3.5.12.6.4 Turbulence Warp</a> in 3.5.12.6 Warps
  </small>

 </ul>

</p>
 <br> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_125.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_125.html">3.5.11 Patterns</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong>3.5.12 Pattern Modifiers</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_127.html">3.6 Interior &amp; Media &amp; Photons</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_127.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 </body> </html>