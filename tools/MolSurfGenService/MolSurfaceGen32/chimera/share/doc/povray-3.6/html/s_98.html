
<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2003-2004  -->
<html> 
<head>
  
<!--  NOTE: In order to users to help find information about POV-Ray using  -->
 
<!--  web search engines, we ask you to *not* let them index documentation  -->
 
<!--  mirrors because effectively, when searching, users will get hundreds  -->
 
<!--  of results containing the same information! For this reason, the two  -->
 
<!--  meta tags below disable archiving and indexing of this page by all  -->
 
<!--  search engines that support these meta tags.  -->
 
 <meta content="noarchive" name="robots">
   
 <meta content="noindex" name="robots">
   
 <meta content="no-cache" http-equiv="Pragma">
   
 <meta content="0" http-equiv="expires">
   
<title>3.2.2 Language Directives</title>
 <link href="povray35.css" rel="stylesheet" type="text/css"> 
</head>
 <body> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_97.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_97.html">3.2.1 Language Basics</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong class="NavBar">POV-Ray 3.6 for UNIX documentation</strong><br> <strong>3.2.2 
   Language Directives</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_99.html">3.3 Scene Settings</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_99.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 
<h3><a name="s03_02_02">3.2.2 </a>Language Directives</h3>
<a name="s03_02_02_i1"><a name="s03_02_02_i2">
<p>
  The POV Scene Language contains several statements called <em>language directives</em> which tell the file parser 
 how to do its job. These directives can appear in almost any place in the scene file - even in the middle of some 
 other statements. They are used to include other text files in the stream of commands, to declare identifiers, to 
 define macros, conditional, or looped parsing and to control other important aspects of scene file processing. 
</p>

<p>
  Each directive begins with the hash character <code>#</code> (often called a number sign or pound sign). It is 
 followed by a keyword and optionally other parameters. 
</p>

<p>
  In versions of POV-Ray prior to 3.0, the use of this <code>#</code> character was optional. Language directives 
 could only be used between objects, camera or light_source statements and could not appear within those statements. 
 The exception was the <code> #include</code> which could appear anywhere. Now that all language directives can be used 
 almost anywhere, the <code>#</code> character is mandatory. The following keywords introduce language directives. 
</p>

<table summary="All language directives">
 
 <tr valign="top">
  
  <td width="33%">
    <code> <a href="s_98.html#s03_02_02_06_03">#break</a><br> <a href="s_98.html#s03_02_02_06_03">#case</a><br> 
   <a href="s_98.html#s03_02_02_07_01">#debug</a><br> <a href="s_98.html#s03_02_02_02_01">#declare</a><br> <a href="s_98.html#s03_02_02_04">#default</a><br> 
   <a href="s_98.html#s03_02_02_06_01">#else</a><br> <a href="s_98.html#s03_02_02_06_01">#end</a><br> <a href="s_98.html#s03_02_02_07_01">#error</a><br> 
   <a href="s_98.html#s03_02_02_03_02">#fclose</a><br> </code> 
  </td>

  <td width="33%">
    <code> <a href="s_98.html#s03_02_02_03_01">#fopen</a><br> <a href="s_98.html#s03_02_02_06_01">#if</a><br> 
   <a href="s_98.html#s03_02_02_06_02">#ifdef</a><br> <a href="s_98.html#s03_02_02_06_02">#ifndef</a><br> <a href="s_98.html#s03_02_02_01">#include</a><br> 
   <a href="s_98.html#s03_02_02_02">#local</a><br> <a href="#l120">#macro</a><br> <a href="s_98.html#s03_02_02_06_03">#range</a><br> 
   <a href="s_98.html#s03_02_02_03_03">#read</a><br> </code> 
  </td>

  <td width="33%">
    <code> <a href="s_98.html#s03_02_02_07_01">#render</a><br> <a href="s_98.html#s03_02_02_07_01">#statistics</a><br> 
   <a href="s_98.html#s03_02_02_06_03">#switch</a><br> <a href="s_98.html#s03_02_02_02_04">#undef</a><br> <a href="s_98.html#s03_02_02_05">#version</a><br> 
   <a href="s_98.html#s03_02_02_07_01">#warning</a><br> <a href="s_98.html#s03_02_02_06_04">#while</a><br> <a href="s_98.html#s03_02_02_03_04">#write</a><br> 
   </code> 
  </td>

 </tr>

</table>

<p>
  Earlier versions of POV-Ray considered the keyword <code>#max_intersections</code> and the keyword <code>#max_trace_level</code> 
 to be language directives but they have been moved to the <code>global_settings</code> statement and should be placed 
 there without the <code>#</code> sign. Their use as a directive still works but it generates a warning and may be 
 discontinued in the future. 
</p>

<h4><a name="s03_02_02_01">3.2.2.1 </a>Include Files and the #include Directive</h4>
<a name="s03_02_02_01_i1"><a name="#include"></a><a name="s03_02_02_01_i2"><a name="include"></a><a name="s03_02_02_01_i3"><a name="Directives, language, #include"></a>
<p>
  The language allows include files to be specified by placing the line 
</p>

<pre>
 #include &quot;filename.inc&quot;
</pre>

<p>
  at any point in the input file. The filename may be specified by any valid string expression but it usually is a 
 literal string enclosed in double quotes. It may be up to 40 characters long (or your computer's limit), including the 
 two double-quote characters. 
</p>

<p>
  The include file is read in as if it were inserted at that point in the file. Using include is almost the same as 
 cutting and pasting the entire contents of this file into your scene. 
</p>

<p>
  Include files may be nested. You may have at most 10 nested include files. There is no limit on un-nested include 
 files. 
</p>

<p>
  Generally, include files have data for scenes but are not scenes in themselves. By convention scene files end in <code>.pov</code> 
 and include files end with <code>.inc</code>. 
</p>

<p>
  It is legal to specify drive and directory information in the file specification however it is discouraged because 
 it makes scene files less portable between various platforms. Use of full lower case is also recommended but not 
 required. 
</p>

<p class="Note">
  <strong>Note:</strong> if you ever intend to distribute any source files you make for POV-Ray, 
 remember that some operating systems have case-sensitive file names). 
</p>

<p>
  It is typical to put standard include files in a special sub-directory. POV-Ray can only read files in the current 
 directory or one referenced by the <code>Library_Path</code> option or <code>+L</code> switch. See section &quot;<a href="s_95.html#s03_01_02_05_04">Library 
 Paths</a>&quot;. 
</p>

<p>
  You may use the <code><a href="s_98.html#s03_02_02_02">#local</a></code> directive to declare identifiers which are 
 temporary in duration and local to the include file in scope. For details see &quot;<a href="s_98.html#s03_02_02_02_02">#declare 
 vs. #local</a>&quot;. 
</p>

<h4><a name="s03_02_02_02">3.2.2.2 </a>The #declare and #local Directives</h4>
<a name="s03_02_02_02_i1"><a name="s03_02_02_02_i2"><a name="s03_02_02_02_i3"><a name="#local"></a><a name="s03_02_02_02_i4"><a name="local"></a>
<p>
  Identifiers may be declared and later referenced to make scene files more readable and to parameterize scenes so 
 that changing a single declaration changes many values. There are several built-in identifiers which POV-Ray declares 
 for you. See section &quot;Float Expressions: <a href="s_97.html#s03_02_01_03_06">Built-in Variables</a>&quot; and 
 &quot;<a href="s_97.html#s03_02_01_04_06">Built-in Vector Identifiers</a>&quot; for details. 
</p>

<h5><a name="s03_02_02_02_01">3.2.2.2.1 </a>Declaring identifiers</h5>
<a name="s03_02_02_02_01_i1"><a name="s03_02_02_02_01_i2"><a name="s03_02_02_02_01_i3"><a name="#declare"></a><a name="s03_02_02_02_01_i4"><a name="declare"></a>
<p>
  An identifier is declared as follows. 
</p>

<pre>
DECLARATION:
    #declare IDENTIFIER = RVALUE |
    #local IDENTIFIER = RVALUE
RVALUE:
    FLOAT; | VECTOR; | COLOR; | STRING | OBJECT | TEXTURE |
    PIGMENT | NORMAL | FINISH | INTERIOR | MEDIA | DENSITY |
    COLOR_MAP | PIGMENT_MAP | SLOPE_MAP | NORMAL_MAP |
    DENSITY_MAP | CAMERA | LIGHT_SOURCE | FOG | RAINBOW |
    SKY_SPHERE | TRANSFORM
</pre>

<p>
  Where <em>IDENTIFIER</em> is the name of the identifier up to 40 characters long and <em>RVALUE</em> is any of the 
 listed items. They are called that because they are values that can appear to the <em>right</em> of the equals sign. 
 The syntax for each is in the corresponding section of this language reference. Here are some examples. 
</p>

<pre>
 #declare Rows = 5;
 #declare Count = Count+1;
 #local  Here = &lt;1,2,3&gt;;
 #declare White = rgb &lt;1,1,1&gt;;
 #declare Cyan = color blue 1.0 green 1.0;
 #declare Font_Name = &quot;ariel.ttf&quot;
 #declare Rod = cylinder {-5*x,5*x,1}
 #declare Ring = torus {5,1}
 #local  Checks = pigment { checker White, Cyan }
 object{ Rod scale y*5 }     // not &quot;cylinder { Rod }&quot;
 object {
  Ring
  pigment { Checks scale 0.5 }
  transform Skew
 }
</pre>

<p class="Note">
  <strong>Note:</strong> that there should be a semi-colon after the expression in all float, vector and 
 color identifier declarations. This semi-colon is introduced in POV-Ray version 3.1. If omitted, it generates a 
 warning and some macros may not work properly. Semicolons after other declarations are optional. 
</p>

<p>
  Declarations, like most language directives, can appear almost anywhere in the file - even within other statements. 
 For example: 
</p>

<pre>
 #declare Here=&lt;1,2,3&gt;;
 #declare Count=0;         // initialize Count
 union {
  object { Rod translate Here*Count }
  #declare Count=Count+1;     // re-declare inside union
  object { Rod translate Here*Count }
  #declare Count=Count+1;     // re-declare inside union
  object { Rod translate Here*Count }
 }
</pre>

<p>
  As this example shows, you can re-declare an identifier and may use previously declared values in that 
 re-declaration. 
</p>

<p class="Note">
  <strong>Note:</strong> object identifiers use the generic wrapper statement <code> object{</code> ... <code>}</code>. 
 You do not need to know what kind of object it is. 
</p>

<p>
  Declarations may be nested inside each other within limits. In the example in the previous section you could 
 declare the entire union as a object. However for technical reasons there are instances where you may not use any 
 language directive inside the declaration of floats, vectors or color expressions. Although these limits have been 
 loosened somewhat since POV-Ray 3.1, they still exist. 
</p>

<p>
  Identifiers declared within <code><a href="#l120">#macro</a></code> ... <code><a href="s_98.html#s03_02_02_06_01">#end</a></code> 
 blocks are not created at the time the macro is defined. They are only created at the time the macro is actually 
 invoked. Like all other items inside such a #macro definition, they are ignored when the macro is defined. 
</p>

<h5><a name="s03_02_02_02_02">3.2.2.2.2 </a>#declare vs. #local</h5>
<a name="s03_02_02_02_02_i1">
<p>
  Identifiers may be declared either global using <code><a href="s_98.html#s03_02_02_02_01">#declare</a></code> or 
 local using the <code><a href="s_98.html#s03_02_02_02">#local</a></code> directive. 
</p>

<p>
  Those created by the <code>#declare</code> directive are permanent in duration and global in scope. Once created, 
 they are available throughout the scene and they are not released until all parsing is complete or until they are 
 specifically released using <code>#undef</code>. See &quot;<a href="s_98.html#s03_02_02_02_04">Destroying Identifiers</a>&quot;. 
 
</p>

<p>
  Those created by the <code>#local</code> directive are temporary in duration and local in scope. They temporarily 
 override any identifiers with the same name. See &quot;<a href="s_98.html#s03_02_02_02_03">Identifier Name Collisions</a>&quot;. 
 
</p>

<p>
  If <code>#local</code> is used inside a <code> #macro</code> then the identifier is local to that macro. When the 
 macro is invoked and the <code>#local</code> directive is parsed, the identifier is created. It persists until the <code>#end</code> 
 directive of the macro is reached. At the <code>#end</code> directive, the identifier is destroyed. Subsequent 
 invocations of the macro create totally new identifiers. 
</p>

<p>
  Use of <code>#local</code> within an include file but not in a macro, also creates a temporary identifier that is 
 local to that include file. When the include file is included and the <code>#local</code> directive is parsed, the 
 identifier is created. It persists until the end of the include file is reached. At the end of file the identifier is 
 destroyed. Subsequent inclusions of the file create totally new identifiers. 
</p>

<p>
  Use of <code>#local</code> in the main scene file (not in an include file and not in a macro) is identical to <code>#declare</code>. 
 For clarity sake you should not use <code>#local</code> in a main file except in a macro. 
</p>

<p>
  There is currently no way to create permanent, yet local identifiers in POV-Ray. 
</p>

<p>
  Local identifiers may be specifically released early using <code><a href="s_98.html#s03_02_02_02_04">#undef</a></code> 
 but in general there is no need to do so. See &quot;<a href="s_98.html#s03_02_02_02_04">Destroying Identifiers</a>&quot;. 
 
</p>

<h5><a name="s03_02_02_02_03">3.2.2.2.3 </a>Identifier Name Collisions</h5>
<a name="s03_02_02_02_03_i1">
<p>
  Local identifiers may have the same names as previously declared identifiers. In this instance, the most recent, 
 most local identifier takes precedence. Upon entering an include file or invoking a macro, a new symbol table is 
 created. When referencing identifiers, the most recently created symbol table is searched first, then the next most 
 recent and so on back to the global table of the main scene file. As each macro or include file is exited, its table 
 and identifiers are destroyed. Parameters passed by value reside in the same symbol table as the one used for 
 identifiers local to the macro. 
</p>

<p>
  The rules for duplicate identifiers may seem complicated when multiple-nested includes and macros are involved, but 
 in actual practice the results are generally what you intended. 
</p>

<p>
  Consider this example: You have a main scene file called <code>myscene.pov</code> and it contains 
</p>

<pre>
 #declare A = 123;
 #declare B = rgb&lt;1,2,3&gt;;
 #declare C = 0;
 #include &quot;myinc.inc&quot;
</pre>

<p>
  Inside the include file you invoke a macro called <code>MyMacro(J,K,L)</code>. It is not important where <code> 
 MyMacro</code> is defined as long as it is defined before it is invoked. In this example, it is important that the 
 macro is invoked from within <code> myinc.inc</code>. 
</p>

<p>
  The identifiers <code>A</code>, <code>B</code>, and <code> C</code> are generally available at all levels. If 
 either <code> myinc.inc</code> or <code> MyMacro</code> contain a line such as <code> #declare C=C+1;</code> then the 
 value <code>C</code> is changed everywhere as you might expect. 
</p>

<p>
  Now suppose inside <code>myinc.inc</code> you do... 
</p>

<pre>
 #local A = 546;
</pre>

<p>
  The main version of <code>A</code> is hidden and a new <code>A</code> is created. This new <code>A</code> is also 
 available inside <code> MyMacro</code> because <code>MyMacro</code> is nested inside <code> myinc.inc</code>. Once you 
 exit <code>myinc.inc</code>, the local <code> A</code> is destroyed and the original <code>A</code> with its value of <code>123</code> 
 is now in effect. Once you have created the local <code> A</code> inside <code>myinc.inc</code>, there is no way to 
 reference the original global <code>A</code> unless you <code>#undef A</code> or exit the include file. Using <code>#undef</code> 
 always undefines the most local version of an identifier. 
</p>

<p>
  Similarly if <code>MyMacro</code> contained... 
</p>

<pre>
 #local B = box{0,1}
</pre>

<p>
  then a new identifier <code>B</code> is created local to the macro only. The original value of <code>B</code> 
 remains hidden but is restored when the macro is finished. The local <code>B</code> need not have the same type as the 
 original. 
</p>

<p>
  The complication comes when trying to assign a new value to an identifier at one level that was declared local at 
 an earlier level. Suppose inside <code> myinc.inc</code> you do... 
</p>

<pre>
 #local D = 789;
</pre>

<p>
  If you are inside <code>myinc.inc</code> and you want to increment <code> D</code> by one, you might try to do... 
</p>

<pre>
 #local D = D + 1;
</pre>

<p>
  but if you try to do that inside <code>MyMacro</code> you will create a new <code>D</code> which is local to <code>MyMacro</code> 
 and not the <code> D</code> which is external to <code>MyMacro</code> but local to <code> myinc.inc</code>. Therefore 
 you've said &quot;create a <code> MyMacro D</code> from the value of <code>myinc.inc</code>'s <code> D</code> plus 
 one&quot;. That's probably not what you wanted. Instead you should do... 
</p>

<pre>
 #declare D = D + 1;
</pre>

<p>
  You might think this creates a new <code>D</code> that is global but it actually increments the myinc.inc version 
 of <code>D</code>. Confusing isn't it? Here are the rules: 
</p>

<ol>
 
 <li>
   When referencing an identifier, you always get the most recent, most local version. By &quot;referencing&quot; we 
  mean using the value of the identifier in a POV-Ray statement or using it on the right of an equals sign in either a <code>#declare</code> 
  or <code> #local</code>. 
 </li>

 <li>
   When declaring an identifier using the <code>#local</code> keyword, the identifier which is created or has a new 
  value assigned, is ALWAYS created at the current nesting level of macros or include files. 
 </li>

 <li>
   When declaring a NEW, NON-EXISTANT identifier using <code>#declare</code>, it is created as fully global. It is 
  put in the symbol table of the main scene file. 
 </li>

 <li>
   When ASSIGNING A VALUE TO AN EXISTING identifier using <code>#declare</code>, it assigns it to the most recent, 
  most local version at the time. 
 </li>

</ol>

<p>
  In summary, <code>#local</code> always means &quot;the current level&quot;, and <code>#declare</code> means 
 &quot;global&quot; for new identifiers and &quot;most recent&quot; for existing identifiers. 
</p>

<h5><a name="s03_02_02_02_04">3.2.2.2.4 </a>Destroying Identifiers with #undef</h5>
<a name="s03_02_02_02_04_i1"><a name="s03_02_02_02_04_i2"><a name="s03_02_02_02_04_i3"><a name="s03_02_02_02_04_i4"><a name="#undef"></a><a name="s03_02_02_02_04_i5"><a name="undef"></a>
<p>
  Identifiers created with <code>#declare</code> will generally persist until parsing is complete. Identifiers 
 created with <code>#local</code> will persist until the end of the macro or include file in which they were created. 
 You may however un-define an identifier using the <code> #undef</code> directive. For example: 
</p>

<pre>
 #undef MyValue
</pre>

<p>
  If multiple local nested versions of the identifier exist, the most local most recent version is deleted and any 
 identically named identifiers which were created at higher levels will still exist. 
</p>

<p>
  See also <a href="s_98.html#s03_02_02_06_02">&quot;The #ifdef and #ifndef Directives&quot;</a>. 
</p>

<h4><a name="s03_02_02_03">3.2.2.3 </a>File I/O Directives</h4>
<a name="s03_02_02_03_i1">
<p>
  You may open, read, write, append, and close plain ASCII text files while parsing POV-Ray scenes. This feature is 
 primarily intended to help pass information between frames of an animation. Values such as an object's position can be 
 written while parsing the current frame and read back during the next frame. Clever use of this feature could allow a 
 POV-Ray scene to generate its own include files or write self-modifying scripts. We trust that users will come up with 
 other interesting uses for this feature. 
</p>

<p class="Note">
  <strong>Note:</strong> some platform versions of POV-Ray (e.g. Windows) provide means to restrict the 
 ability of scene files to read &amp; write files. 
</p>

<h5><a name="s03_02_02_03_01">3.2.2.3.1 </a>The #fopen Directive</h5>
<a name="s03_02_02_03_01_i1"><a name="#fopen"></a><a name="s03_02_02_03_01_i2"><a name="fopen"></a><a name="s03_02_02_03_01_i3"><a name="append"></a><a name="s03_02_02_03_01_i4">
<p>
  Users may open a text file using the <code>#fopen</code> directive. The syntax is as follows: 
</p>

<pre>
FOPEN_DIRECTIVE:
    #fopen IDENTIFIER &quot;filename&quot; OPEN_TYPE
OPEN_TYPE:
    read | write | append
</pre>

<p>
  Where <em>IDENTIFIER</em> is an undefined identifier used to reference this file as a file handle, <em>&quot;filename&quot;</em> 
 is any string literal or string expression which specifies the file name. Files opened with the <code>read</code> are 
 open for read only. Those opened with <code> write</code> create a new file with the specified name and it overwrites 
 any existing file with that name. Those opened with <code>append</code> opens a file for writing but appends the text 
 to the end of any existing file. 
</p>

<p>
  The file handle identifier created by <code>#fopen</code> is always global and remains in effect (and the file 
 remains open) until the scene parsing is complete or until you <code>#fclose</code> the file. You may use <code> #ifdef</code> 
 <em>FILE_HANDLE_IDENTIFIER</em> to see if a file is open. 
</p>

<h5><a name="s03_02_02_03_02">3.2.2.3.2 </a>The #fclose Directive</h5>
<a name="s03_02_02_03_02_i1"><a name="#fclose"></a><a name="s03_02_02_03_02_i2"><a name="fclose"></a><a name="s03_02_02_03_02_i3">
<p>
  Files opened with the <code>#fopen</code> directive are automatically closed when scene parsing completes however 
 you may close a file using the <code>#fclose</code> directive. The syntax is as follows: 
</p>

<pre>
FCLOSE_DIRECTIVE:
    #fclose FILE_HANDLE_IDENTIFIER
</pre>

<p>
  Where <em>FILE_HANDLE_IDENTIFIER</em> is previously opened file opened with the <code>#fopen</code> directive. See 
 &quot;<a href="s_98.html#s03_02_02_03_01">The #fopen Directive</a>&quot;. 
</p>

<h5><a name="s03_02_02_03_03">3.2.2.3.3 </a>The #read Directive</h5>
<a name="s03_02_02_03_03_i1"><a name="#read"></a><a name="s03_02_02_03_03_i2"><a name="read"></a><a name="s03_02_02_03_03_i3">
<p>
  You may read string, float or vector values from a plain ASCII text file directly into POV-Ray variables using the 
 #read directive. The file must first be opened in &quot;read&quot; mode using the #fopen directive. The syntax for 
 #read is as follows: 
</p>

<pre>
READ_DIRECTIVE:
  #read (FILE_HANDLE_IDENTIFIER, DATA_IDENTIFIER[,DATA_IDENTIFIER]..)
DATA_IDENTIFIER:
  UNDECLARED_IDENTIFIER | FLOAT_IDENTIFIER | VECTOR_IDENTIFIER | 
  STRING_IDENTIFIER
</pre>

<p>
  Where <em>FILE_HANDLE_IDENTIFIER</em> is the previously opened file. It is followed by one or more <em>DATA_IDENTIFIER</em>s 
 separated by commas. The parentheses around the identifier list are required. A <em> DATA_IDENTIFIER</em> is any 
 undeclared identifier or any previously declared string identifier, float identifier, or vector identifier. Undefined 
 identifiers will be turned into global identifiers of the type determined by the data which is read. Previously 
 defined identifiers remain at whatever global/local status they had when originally created. Type checking is 
 performed to insure that the proper type data is read into these identifiers. 
</p>

<p>
  The format of the data to be read must be a series of valid string literals, float literals, or vector literals 
 separated by commas. Expressions or identifiers are not permitted in the data file however unary minus signs and 
 exponential notation are permitted on float values. 
</p>

<p>
  If you attempt to read past end-of-file, the file is automatically closed and the <em> FILE_HANDLE_IDENTIFIER</em> 
 is deleted from the symbol table. This means that the boolean function <code> defined(</code><em>IDENTIFIER</em><code>)</code> 
 can be used to detect end-of-file. For example: 
</p>

<pre>
  #fopen MyFile &quot;mydata.txt&quot; read
  #while (defined(MyFile))
    #read (MyFile,Var1,Var2,Var3)
    ...
  #end
</pre>

<h5><a name="s03_02_02_03_04">3.2.2.3.4 </a>The #write Directive</h5>
<a name="s03_02_02_03_04_i1"><a name="#write"></a><a name="s03_02_02_03_04_i2"><a name="write"></a><a name="s03_02_02_03_04_i3">
<p>
  You may write string, float or vector values to a plain ASCII text file from POV-Ray variables using the <code>#write</code> 
 directive. The file must first be opened in either <code>write</code> or <code>append</code> mode using the <code>#fopen</code> 
 directive. The syntax for <code> #write</code> is as follows: 
</p>

<pre>
WRITE_DIRECTIVE:
    #write( FILE_HANDLE_IDENTIFIER, DATA_ITEM[,DATA_ITEM]...)
DATA_ITEM:
    FLOAT | VECTOR | STRING
</pre>

<p>
  Where <em>FILE_HANDLE_IDENTIFIER</em> is the previously opened file. It is followed by one or more <em>DATA_ITEM</em>s 
 separated by commas. The parentheses around the identifier list are required. A <em>DATA_ITEM</em> is any valid string 
 expression, float expression, or vector expression. Float expressions are evaluated and written as signed float 
 literals. If you require format control, you should use the <code>str(VALUE,L,P)</code> function to convert it to a 
 formatted string. See &quot;<a href="s_97.html#s03_02_01_07_03">String Functions</a>&quot; for details on the <code>str</code> 
 function. Vector expressions are evaluated into three signed float constants and are written with angle brackets and 
 commas in standard POV-Ray vector notation. String expressions are evaluated and written as specified. 
</p>

<p class="Note">
  <strong>Note:</strong> data read by the <code>#read</code> directive must have comma delimiters 
 between values and quotes around string data but the <code> #write</code> directive does not automatically output 
 commas or quotes. 
</p>

<p>
  For example the following <code> #read</code> directive reads a string, float and vector. 
</p>

<pre>
 #read (MyFile,MyString,MyFloat,MyVect)
</pre>

<p>
  It expects to read something like: 
</p>

<pre>
 &quot;A quote delimited string&quot;, -123.45, &lt;1,2,-3&gt;
</pre>

<p>
  The POV-Ray code to write this might be: 
</p>

<pre>
 #declare Val1 = -123.45;
 #declare Vect1 = &lt;1,2,-3&gt;;
 #write(MyFile,&quot;\&quot;A quote delimited string\&quot;,&quot;,Val1,&quot;,&quot;,Vect1,&quot;\n&quot;)
</pre>

<p>
  See &quot;<a href="s_97.html#s03_02_01_07_01">String Literals</a>&quot; and &quot;<a href="s_97.html#s03_02_01_07_01">Text 
 Formatting</a>&quot; for details on writing special characters such as quotes, newline, etc. 
</p>

<h4><a name="s03_02_02_04">3.2.2.4 </a>The #default Directive</h4>
<a name="s03_02_02_04_i1"><a name="s03_02_02_04_i2"><a name="s03_02_02_04_i3"><a name="#default"></a><a name="s03_02_02_04_i4"><a name="default"></a><a name="s03_02_02_04_i5">
<p>
  POV-Ray creates a default texture when it begins processing. You may change those defaults as described below. 
 Every time you specify a <code><a href="#l121">texture</a></code> statement, POV-Ray creates a copy of the default 
 texture. Anything you put in the texture statement overrides the default settings. If you attach a <code>pigment</code>, 
 <code>normal</code>, or <code> finish</code> to an object without any texture statement then POV-Ray checks to see if 
 a texture has already been attached. If it has a texture then the pigment, normal or finish will modify the existing 
 texture. If no texture has yet been attached to the object then the default texture is copied and the pigment, normal 
 or finish will modify that texture. 
</p>

<p>
  You may change the default texture, pigment, normal or finish using the language directive <code>#default</code> as 
 follows: 
</p>

<pre>
DEFAULT_DIRECTIVE:
    #default {DEFAULT_ITEM }
DEFAULT_ITEM:
    TEXTURE | PIGMENT | NORMAL | FINISH
</pre>

<p>
  For example: 
</p>

<pre>
 #default {
   texture {
     pigment { rgb &lt;1,0,0&gt; }
     normal { bumps 0.3 }
     finish { ambient 0.4 }
   }
 }
</pre>

<p>
  This means objects will default to red bumps and slightly high ambient finish. Also you may change just part of it 
 like this: 
</p>

<pre>
 #default {
  pigment {rgb &lt;1,0,0&gt;}
 }
</pre>

<p>
  This still changes the pigment of the default texture. At any time there is only one default texture made from the 
 default pigment, normal and finish. The example above does not make a separate default for pigments alone. 
</p>

<p class="Note">
  <strong>Note:</strong> the special textures <code>tiles</code> and <code> material_map</code> or a 
 texture with a <code>texture_map</code> may not be used as defaults. 
</p>

<p>
  You may change the defaults several times throughout a scene as you wish. Subsequent <code>#default</code> 
 statements begin with the defaults that were in effect at the time. If you wish to reset to the original POV-Ray 
 defaults then you should first save them as follows: 
</p>

<pre>
 //At top of file
 #declare Original_Default = texture {}
</pre>

<p>
  later after changing defaults you may restore it with... 
</p>

<pre>
 #default {texture {Original_Default}}
</pre>

<p>
  If you do not specify a texture for an object then the default texture is attached when the object appears in the 
 scene. It is not attached when an object is declared. For example: 
</p>

<pre>
 #declare My_Object =
  sphere{ &lt;0,0,0&gt;, 1 } // Default texture not applied
  object{ My_Object }  // Default texture added here
</pre>

<p>
  You may force a default texture to be added by using an empty texture statement as follows: 
</p>

<pre>
 #declare My_Thing =
  sphere { &lt;0,0,0&gt;, 1 texture {} } // Default texture applied
</pre>

<p>
  The original POV-Ray defaults for all items are given throughout the documentation under each appropriate section. 
</p>

<h4><a name="s03_02_02_05">3.2.2.5 </a>The #version Directive</h4>
<a name="s03_02_02_05_i1"><a name="s03_02_02_05_i2"><a name="#version"></a><a name="s03_02_02_05_i3"><a name="version"></a>
<p>
  As POV-Ray has evolved from version 1.0 through 3.6 we have made every effort to maintain some amount of backwards 
 compatibility with earlier versions. Some old or obsolete features can be handled directly without any special 
 consideration by the user. Some old or obsolete features can no longer be handled at all. However <em>some</em> old 
 features can still be used if you warn POV-Ray that this is an older scene. The <code> #version</code> directive can 
 be used to switch version compatibility to different setting several times throughout a scene file. The syntax is: 
</p>

<pre>
VERSION_DIRECTIVE: 
    #version FLOAT;
</pre>

<p class="Note">
  <strong>Note:</strong> there should be a semi-colon after the float expression in a <code>#version</code> 
 directive. This semi-colon is introduced in POV-Ray version 3.1. If omitted, it generates a warning and some macros 
 may not work properly. 
</p>

<p>
  Additionally you may use the <code> Version=</code><em>n.n</em> option or the <code>+MV</code><em>n.n</em> switch 
 to establish the <em>initial</em> setting. See &quot;<a href="s_95.html#s03_01_02_05_05">Language Version</a>&quot; 
 for details. For example one feature introduced in 2.0 that was incompatible with any 1.0 scene files is the parsing 
 of float expressions. Using <code>#version 1.0</code> turns off expression parsing as well as many warning messages so 
 that nearly all 1.0 files will still work. Naturally the default setting for this option is <code>#version 3.5</code>. 
</p>

<p class="Note">
  <strong>Note:</strong> Some obsolete or re-designed features <em>are totally unavailable in the 
 current version of POV-Ray REGARDLES OF THE VERSION SETTING.</em> Details on these features are noted throughout this 
 documentation. 
</p>

<p>
  The built-in float identifier <code>version</code> contains the current setting of the version compatibility 
 option. See &quot;Float Expressions: <a href="s_97.html#s03_02_01_03_06">Built-in Variables</a>&quot;. Together with 
 the built-in <code>version</code> identifier the <code>#version</code> directive allows you to save and restore the 
 previous values of this compatibility setting. The new <code> #local</code> identifier option is especially useful 
 here. For example suppose <code> mystuff.inc</code> is in version 1 format. At the top of the file you could put: 
</p>

<pre>
 #local Temp_Vers = version;  // Save previous value
 #version 1.0;         // Change to 1.0 mode
 ... // Version 1.0 stuff goes here...
 #version Temp_Vers;      // Restore previous version
</pre>

<p>
  Future versions of POV-Ray may not continue to maintain full backward compatibility even with the <code>#version</code> 
 directive. We strongly encourage you to phase in current version syntax as much as possible. 
</p>

<h4><a name="s03_02_02_06">3.2.2.6 </a>Conditional Directives</h4>
<a name="s03_02_02_06_i1">
<p>
  POV-Ray allows a variety of language directives to implement conditional parsing of various sections of your scene 
 file. This is especially useful in describing the motion for animations but it has other uses as well. Also available 
 is a <code><a href="s_98.html#s03_02_02_06_04">#while</a></code> loop directive. You may nest conditional directives 
 200 levels deep. 
</p>

<h5><a name="s03_02_02_06_01">3.2.2.6.1 </a>The #if...#else...#end Directives</h5>
<a name="s03_02_02_06_01_i1"><a name="if"></a><a name="s03_02_02_06_01_i2"><a name="else"></a><a name="s03_02_02_06_01_i3"><a name="end"></a><a name="s03_02_02_06_01_i4"><a name="#if"></a><a name="s03_02_02_06_01_i5"><a name="#else"></a><a name="s03_02_02_06_01_i6"><a name="#end"></a><a name="s03_02_02_06_01_i7"><a name="s03_02_02_06_01_i8"><a name="s03_02_02_06_01_i9">
<p>
  The simplest conditional directive is a traditional <code>#if</code> directive. It is of the form... 
</p>

<pre>
IF_DIRECTIVE:
    #if ( Cond ) TOKENS... [#else TOKENS...] #end
</pre>

<p>
  The <em>TOKENS</em> are any number of POV-Ray keyword, identifiers, or punctuation and <code>(</code><em> Cond</em> <code>)</code> 
 is a float expression that is interpreted as a boolean value. The parentheses are required. The <code>#end</code> 
 directive is required. A value of 0.0 is false and any non-zero value is true. 
</p>

<p class="Note">
  <strong>Note:</strong> extremely small values of about 1e-10 are considered zero in case of round off 
 errors. 
</p>

<p>
  If <em> Cond</em> is true, the first group of tokens is parsed normally and the second set is skipped. If false, 
 the first set is skipped and the second set is parsed. For example: 
</p>

<pre>
 #declare Which=1;
 #if (Which)
   box { 0, 1 }
 #else
   sphere { 0, 1 }
 #end
</pre>

<p>
  The box is parsed and the sphere is skipped. Changing the value of <code> Which</code> to <code>0</code> means the 
 box is skipped and the sphere is used. The <code>#else</code> directive and second token group is optional. For 
 example: 
</p>

<pre>
 #declare Which=1;
 #if (Which)
   box { 0, 1 }
 #end
</pre>

<p>
  Changing the value of <code>Which</code> to <code>0</code> means the box is removed. 
</p>

<p>
  At the beginning of the chapter &quot;Language Directives&quot; it was stated that &quot;These directives can 
 appear in almost any place in the scene file....&quot;. The following is an example where it will not work, it will 
 confuse the parser: 
</p>

<pre>
   #if( #if(yes) yes #end ) #end
</pre>

<h5><a name="s03_02_02_06_02">3.2.2.6.2 </a>The #ifdef and #ifndef Directives</h5>
<a name="s03_02_02_06_02_i1"><a name="ifdef"></a><a name="s03_02_02_06_02_i2"><a name="ifndef"></a><a name="s03_02_02_06_02_i3"><a name="#ifdef"></a><a name="s03_02_02_06_02_i4"><a name="#ifndef"></a><a name="s03_02_02_06_02_i5"><a name="s03_02_02_06_02_i6">
<p>
  The <code>#ifdef</code> and <code>#ifndef</code> directive are similar to the <code>#if</code> directive however 
 they are used to determine if an identifier has been previously declared. 
</p>

<pre>
IFDEF_DIRECTIVE:
    #ifdef ( IDENTIFIER ) TOKENS... [#else TOKENS...] #end
IFNDEF_DIRECTIVE:
    #ifndef ( IDENTIFIER ) TOKENS... [#else TOKENS...] #end
</pre>

<p>
  If the <em>IDENTIFIER</em> exists then the first group of tokens is parsed normally and the second set is skipped. 
 If false, the first set is skipped and the second set is parsed. This is especially useful for replacing an undefined 
 item with a default. For example: 
</p>

<pre>
  #ifdef (User_Thing)
  // This section is parsed if the
  // identifier &quot;User_Thing&quot; was
  // previously declared
  object{User_Thing} // invoke identifier
 #else
  // This section is parsed if the
  // identifier &quot;User_Thing&quot; was not
  // previously declared
  box{&lt;0,0,0&gt;,&lt;1,1,1&gt;} // use a default
 #end
  // End of conditional part
</pre>

<p>
  The <code>#ifndef</code> directive works the opposite. The first group is parsed if the identifier is <em>not</em> 
 defined. As with the <code> #if</code> directive, the <code>#else</code> clause is optional and the <code>#end</code> 
 directive is required. 
</p>

<p>
  The <code>#ifdef</code> and <code>#ifndef</code> directives can be used to determine whether a specific element of 
 an array has been assigned. 
</p>

<pre>
 #declare MyArray=array[10]
 //#declare MyArray[0]=7;
 #ifdef(MyArray[0])
    #debug &quot;first element is assigned\n&quot;
 #else 
    #debug &quot;first element is not assigned\n&quot;
 #end
</pre>

<h5><a name="s03_02_02_06_03">3.2.2.6.3 </a>The #switch, #case, #range and #break Directives</h5>
<a name="s03_02_02_06_03_i1"><a name="switch"></a><a name="s03_02_02_06_03_i2"><a name="case"></a><a name="s03_02_02_06_03_i3"><a name="range"></a><a name="s03_02_02_06_03_i4"><a name="break"></a><a name="s03_02_02_06_03_i5"><a name="#switch"></a><a name="s03_02_02_06_03_i6"><a name="#case"></a><a name="s03_02_02_06_03_i7"><a name="#range"></a><a name="s03_02_02_06_03_i8"><a name="#break"></a><a name="s03_02_02_06_03_i9"><a name="s03_02_02_06_03_i10"><a name="s03_02_02_06_03_i11"><a name="s03_02_02_06_03_i12">
<p>
  A more powerful conditional is the <code>#switch</code> directive. The syntax is as follows... 
</p>

<pre>
SWITCH_DIRECTIVE:
   #switch ( Switch_Value ) SWITCH_CLAUSE... [#else TOKENS...] #end
SWITCH_CLAUSE:
   #case( Case_Value ) TOKENS... [#break] |
   #range( Low_Value , High_Value ) TOKENS... [#break]
</pre>

<p>
  The <em>TOKENS</em> are any number of POV-Ray keyword, identifiers, or punctuation and <code>(</code><em> 
 Switch_Value</em> <code>)</code> is a float expression. The parentheses are required. The <code>#end</code> directive 
 is required. The <em>SWITCH_CLAUSE</em> comes in two varieties. In the <code>#case</code> variety, the float <em>Switch_Value</em> 
 is compared to the float <em>Case_Value</em>. If they are equal, the condition is true. 
</p>

<p class="Note">
  <strong>Note:</strong> that values whose difference is less than 1e-10 are considered equal in case of 
 round off errors. 
</p>

<p>
  In the <code>#range</code> variety, <em>Low_Value</em> and <em>High_Value</em> are floats separated by a comma and 
 enclosed in parentheses. If <em>Low_Value &lt;= Switch_Value</em> and <em> Switch_Value&lt;=High_Value</em> then the 
 condition is true. 
</p>

<p>
  In either variety, if the clause's condition is true, that clause's tokens are parsed normally and parsing 
 continues until a <code>#break</code>, <code> #else</code> or <code>#end</code> directive is reached. If the condition 
 is false, POV-Ray skips until another <code>#case</code> or <code> #range</code> is found. 
</p>

<p>
  There may be any number of <code>#case</code> or <code> #range</code> clauses in any order you want. If a clause 
 evaluates true but no <code> #break</code> is specified, the parsing will fall through to the next <code> #case</code> 
 or <code>#range</code> and that clause conditional is evaluated. Hitting <code>#break</code> while parsing a 
 successful section causes an immediate jump to the <code>#end</code> without processing subsequent sections, even if a 
 subsequent condition would also have been satisfied. 
</p>

<p>
  An optional <code>#else</code> clause may be the last clause. It is only executed if the clause before it was a 
 false clause. 
</p>

<p>
  Here is an example: 
</p>

<pre>
 #switch (VALUE)
  #case (TEST_1)
   // This section is parsed if VALUE=TEST_1
  #break //First case ends
  #case (TEST_2)
   // This section is parsed if VALUE=TEST_2
  #break //Second case ends
  #range (LOW_1,HIGH_1)
   // This section is parsed if (VALUE&gt;=LOW_1)&amp;(VALUE&lt;=HIGH_1)
  #break //Third case ends
  #range (LOW_2,HIGH_2)
   // This section is parsed if (VALUE&gt;=LOW_2)&amp;(VALUE&lt;=HIGH_2)
  #break //Fourth case ends
  #else
   // This section is parsed if no other case or
   // range is true.
 #end // End of conditional part
</pre>

<h5><a name="s03_02_02_06_04">3.2.2.6.4 </a>The #while...#end Directive</h5>
<a name="s03_02_02_06_04_i1"><a name="while"></a><a name="s03_02_02_06_04_i2"><a name="#while"></a><a name="s03_02_02_06_04_i3"><a name="s03_02_02_06_04_i4">
<p>
  The <code>#while</code> directive is a looping feature that makes it easy to place multiple objects in a pattern or 
 other uses. 
</p>

<pre>
WHILE_DIRECTIVE:
    #while ( Cond ) TOKENS... #end
</pre>

<p>
  The <em>TOKENS</em> are any number of POV-Ray keyword, identifiers, or punctuation marks which are the <em>body</em> 
 of the loop. The <code> #while</code> directive is followed by a float expression that evaluates to a boolean value. A 
 value of 0.0 is false and any non-zero value is true. 
</p>

<p class="Note">
  <strong>Note:</strong> extremely small values of about 1e-10 are considered zero in case of round off 
 errors. 
</p>

<p>
  The parentheses around the expression are required. If the condition is true parsing continues normally until an <code>#end</code> 
 directive is reached. At the end, POV-Ray loops back to the <code> #while</code> directive and the condition is 
 re-evaluated. Looping continues until the condition fails. When it fails, parsing continues after the <code> #end</code> 
 directive. 
</p>

<p class="Note">
  <strong>Note:</strong> it is possible for the condition to fail the first time and the loop is totally 
 skipped. It is up to the user to insure that something inside the loop changes so that it eventually terminates. 
</p>

<p>
  Here is a properly constructed loop example: 
</p>

<pre>
 #declare Count=0;
 #while (Count &lt; 5)
  object { MyObject translate x*3*Count }
  #declare Count=Count+1;
 #end
</pre>

<p>
  This example places five copies of <code>MyObject</code> in a row spaced three units apart in the x-direction. 
</p>

<h4><a name="s03_02_02_07">3.2.2.7 </a>User Message Directives</h4>
<a name="s03_02_02_07_i1">
<p>
  With the addition of conditional and loop directives, the POV-Ray language has the potential to be more like an 
 actual programming language. This means that it will be necessary to have some way to see what is going on when trying 
 to debug loops and conditionals. To fulfill this need we have added the ability to print text messages to the screen. 
 You have a choice of five different text streams to use including the ability to generate a fatal error if you find it 
 necessary. Limited formatting is available for strings output by this method. 
</p>

<h5><a name="s03_02_02_07_01">3.2.2.7.1 </a>Text Message Streams</h5>
<a name="s03_02_02_07_01_i1"><a name="#debug"></a><a name="s03_02_02_07_01_i2"><a name="#error"></a><a name="s03_02_02_07_01_i3"><a name="#warning"></a><a name="s03_02_02_07_01_i4"><a name="#render"></a><a name="s03_02_02_07_01_i5"><a name="#statistics"></a><a name="s03_02_02_07_01_i6"><a name="statistics"></a><a name="s03_02_02_07_01_i7"><a name="debug"></a><a name="s03_02_02_07_01_i8"><a name="error"></a><a name="s03_02_02_07_01_i9"><a name="warning"></a><a name="s03_02_02_07_01_i10"><a name="render"></a><a name="s03_02_02_07_01_i11"><a name="s03_02_02_07_01_i12"><a name="s03_02_02_07_01_i13">
<p>
  The syntax for a text message is any of the following: 
</p>

<pre>
TEXT_STREAM_DIRECTIVE:
    #debug STRING | #error STRING | #warning STRING
</pre>

<p>
  Where <em>STRING</em> is any valid string of text including string identifiers or functions which return strings. 
 For example: 
</p>

<pre>
 #switch (clock*360)
  #range (0,180)
   #debug &quot;Clock in 0 to 180 range\n&quot;
  #break
  #range (180,360)
   #debug &quot;Clock in 180 to 360 range\n&quot;
  #break
  #else
   #warning &quot;Clock outside expected range\n&quot;
   #warning concat(&quot;Value is:&quot;,str(clock*360,5,0),&quot;\n&quot;)
 #end
</pre>

<p>
  There are seven distinct <a href="s_95.html#s03_01_02_07_01">text streams</a> that POV-Ray uses for output. You may 
 output only to three of them. On some versions of POV-Ray, each stream is designated by a particular color. Text from 
 these streams are displayed whenever it is appropriate so there is often an intermixing of the text. The distinction 
 is only important if you choose to turn some of the streams off or to direct some of the streams to text files. On 
 some systems you may be able to review the streams separately in their own scroll-back buffer. See &quot;Directing 
 Text Streams to Files&quot; for details on re-directing the streams to a text file. 
</p>

<p>
  Here is a description of how POV-Ray uses each stream. You may use them for whatever purpose you want except note 
 that use of the <code>#error</code> stream causes a fatal error after the text is displayed. 
</p>

<p>
  <strong>Debug:</strong> This stream displays debugging messages. It was primarily designed for developers but this 
 and other streams may also be used by the user to display messages from within their scene files. 
</p>

<p>
  <strong>Error:</strong> This stream displays fatal error messages. After displaying this text, POV-Ray will 
 terminate. When the error is a scene parsing error, you may be shown several lines of scene text that leads up to the 
 error. 
</p>

<p>
  <strong>Warning:</strong> This stream displays warning messages during the parsing of scene files and other 
 warnings. Despite the warning, POV-Ray can continue to render the scene.<a name="s03_02_02_07_01_i14"><a name="s03_02_02_07_01_i15"><a name="s03_02_02_07_01_i16"><a name="s03_02_02_07_01_i17"><a name="s03_02_02_07_01_i18"> 
 
</p>

<p>
  The <code>#render</code> and <code>#statistsics</code> could be accessed in previous versions. Their output is now 
 redirected to the <code>#debug</code> stream. The <code>#banner</code> and <code>#status</code> streams can not be 
 accessed by the user. 
</p>

<h5><a name="s03_02_02_07_02">3.2.2.7.2 </a>Text Formatting</h5>

<p>
  Some escape sequences are available to include non-printing control characters in your text. These sequences are 
 similar to those used in string literals in the C programming language. The sequences are: 
</p>

<table summary="All character escape sequences" width="100%">
 
 <tr>
  
  <td width="25%">
    <code>&quot;\a&quot;</code> 
  </td>

  <td width="65%">
    Bell or alarm, 
  </td>

  <td width="10%">
    0x07 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\b&quot;</code> 
  </td>

  <td>
    Backspace, 
  </td>

  <td>
    0x08 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\f&quot;</code> 
  </td>

  <td>
    Form feed, 
  </td>

  <td>
    0x0C 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\n&quot;</code> 
  </td>

  <td>
    New line (line feed) 
  </td>

  <td>
    0x0A 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\r&quot;</code> 
  </td>

  <td>
    Carriage return 
  </td>

  <td>
    0x0D 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\t&quot;</code> 
  </td>

  <td>
    Horizontal tab 
  </td>

  <td>
    0x09 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\uNNNN&quot;</code> 
  </td>

  <td>
    Unicode character code NNNN 
  </td>

  <td>
    0xNNNN 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\v&quot;</code> 
  </td>

  <td>
    Vertical tab 
  </td>

  <td>
    0x0B 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\0&quot;</code> 
  </td>

  <td>
    Null 
  </td>

  <td>
    0x00 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\\&quot;</code> 
  </td>

  <td>
    Backslash 
  </td>

  <td>
    0x5C 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\'&quot;</code> 
  </td>

  <td>
    Single quote 
  </td>

  <td>
    0x27 
  </td>

 </tr>

 <tr>
  
  <td>
    <code>&quot;\&quot;&quot;</code> 
  </td>

  <td>
    Double quote 
  </td>

  <td>
    0x22 
  </td>

 </tr>

</table>

<p>
  For example: 
</p>

<pre>
 #debug &quot;This is one line.\nBut this is another&quot;\n
</pre>

<p>
  Depending on what platform you are using, they may not be fully supported for console output. However they will 
 appear in any text file if you re-direct a stream to a file. 
</p>

<h4><a name="s03_02_02_08">3.2.2.8 </a>User Defined Macros</h4>
<a name="s03_02_02_08_i1"><a name="s03_02_02_08_i2"><a name="#macro"></a><a name="s03_02_02_08_i3"><a name="macro"></a><a name="s03_02_02_08_i4">
<p>
  POV-Ray 3.1 introduced user defined macros with parameters. This feature, along with the ability to declare <code>#local</code> 
 variables, turned the POV-Ray Language into a fully functional programming language. Consequently, it is now possible 
 to write scene generation tools in POV-Ray's own language that previously required external utilities. 
</p>

<h5><a name="s03_02_02_08_01">3.2.2.8.1 </a>The #macro Directive</h5>
<a name="s03_02_02_08_01_i1"><a name="s03_02_02_08_01_i2">
<p>
  The syntax for declaring a macro is: 
</p>

<pre>
MACRO_DEFINITION:
#macro IDENTIFIER ([PARAM_IDENT] [, PARAM_IDENT]... ) TOKENS... #end
</pre>

<p>
  Where <em>IDENTIFIER</em> is the name of the macro and <em> PARAM_IDENT</em>s are a list of zero or more formal 
 parameter identifiers separated by commas and enclosed by parentheses. The parentheses are required even if no 
 parameters are specified. 
</p>

<p>
  The <em>TOKENS</em> are any number of POV-Ray keyword, identifiers, or punctuation marks which are the <em> body</em> 
 of the macro. The body of the macro may contain almost any POV-Ray syntax items you desire. It is terminated by the <code>#end</code> 
 directive. 
</p>

<p class="Note">
  <strong>Note:</strong> any conditional directives such as <code> #if</code>...<code>#end</code>, <code> 
 #while</code>...<code>#end</code>, etc. must be fully nested inside or outside the macro so that the corresponding <code>#end</code> 
 directives pair-up properly. 
</p>

<p>
  A macro must be declared before it is invoked. All macro names are global in scope and permanent in duration. You 
 may redefine a macro by another <code> #macro</code> directive with the same name. The previous definition is lost. 
 Macro names respond to <code> #ifdef</code>, <code> #ifndef</code>, and <code>#undef</code> directives. See &quot;<a href="s_98.html#s03_02_02_06_02">The 
 #ifdef and #ifndef Directives</a>&quot; and &quot;<a href="s_98.html#s03_02_02_02_04">Destroying Identifiers with 
 #undef</a>&quot;. 
</p>

<h5><a name="s03_02_02_08_02">3.2.2.8.2 </a>Invoking Macros</h5>
<a name="s03_02_02_08_02_i1">
<p>
  You invoke the macro by specifying the macro name followed by a list of zero or more actual parameters enclosed in 
 parentheses and separated by commas. The number of actual parameters must match the number of formal parameters in the 
 definition. The parentheses are required even if no parameters are specified. The syntax is: 
</p>

<pre>
MACRO_INVOCATION:
    MACRO_IDENTIFIER ( [ACTUAL_PARAM] [, ACTUAL_PARAM]... )
ACTUAL_PARAM:
    IDENTIFIER | RVALUE
</pre>

<p>
  An <em>RVALUE</em> is any value that can legally appear to the right of an equals sign in a <code>#declare</code> 
 or <code>#local</code> declaration. See &quot;<a href="s_98.html#s03_02_02_02_01">Declaring identifiers</a>&quot; for 
 information on <em> RVALUE</em>s. When the macro is invoked, a new local symbol table is created. The actual 
 parameters are assigned to formal parameter identifiers as local, temporary variables. POV-Ray jumps to the body of 
 the macro and continues parsing until the matching <code>#end</code> directive is reached. There, the local variables 
 created by the parameters are destroyed as well as any local identifiers expressly created in the body of the macro. 
 It then resumes parsing at the point where the macro was invoked. It is as though the body of the macro was cut and 
 pasted into the scene at the point where the macro was invoked. 
</p>

<p class="Note">
  <strong>Note:</strong> it is possible to invoke a macro that was declared in another file. This is 
 quite normal and in fact is how many &quot;plug-ins&quot; work (such as the popular Lens Flare macro). However, be 
 aware that calling a macro that was declared in a file different from the one that it is being called from involves 
 more overhead than calling one in the same file. 
</p>

<p>
  This is because POV-Ray does not tokenize and store its language. Calling a macro in another file therefore 
 requires that the other file be opened and closed for each call. Normally, this overhead is inconsequential; however, 
 if you are calling the macro many thousands of times, it can cause significant delays. A future version of the POV-Ray 
 language will remove this problem. 
</p>

<p>
  Here is a simple macro that creates a window frame object when you specify the inner and outer dimensions. 
</p>

<pre>
#macro Make_Frame(OuterWidth,OuterHeight,InnerWidth,
                  InnerHeight,Depth)
  #local Horz = (OuterHeight-InnerHeight)/2;
  #local Vert = (OuterWidth-InnerWidth)/2;
  difference {
    box{
	  &lt;0,0,0&gt;,&lt;OuterWidth,OuterHeight,Depth&gt;
	}
    box{
	  &lt;Vert,Horz,-0.1&gt;,
      &lt;OuterWidth-Vert,OuterHeight-Horz,Depth+0.1&gt;
	}
  }
#end
Make_Frame(8,10,7,9,1) //invoke the macro
</pre>

<p>
  In this example, the macro has five float parameters. The actual parameters (the values 8, 10, 7, 9, and 1) are 
 assigned to the five identifiers in the <code>#macro</code> formal parameter list. It is as though you had used the 
 following five lines of code. 
</p>

<pre>
 #local OuterWidth = 8;
 #local OuterHeight = 10;
 #local InnerWidth, = 7;
 #local InnerHeight = 9;
 #local Depth = 1;
</pre>

<p>
  These five identifiers are stored in the same symbol table as any other local identifier such as <code>Horz</code> 
 or <code>Vert</code> in this example. The parameters and local variables are all destroyed when the <code> #end</code> 
 statement is reached. See &quot;<a href="s_98.html#s03_02_02_02_03">Identifier Name Collisions</a>&quot; for a 
 detailed discussion of how local identifiers, parameters, and global identifiers work when a local identifier has the 
 same name as a previously declared identifier. 
</p>

<h5><a name="s03_02_02_08_03">3.2.2.8.3 </a>Are POV-Ray Macros a Function or a Macro?</h5>

<p>
  POV-Ray macros are a strange mix of macros and functions. In traditional computer programming languages, a macro 
 works entirely by token substitution. The body of the routine is inserted into the invocation point by simply copying 
 the tokens and parsing them as if they had been cut and pasted in place. Such cut-and-paste substitution is often 
 called <em>macro substitution</em> because it is what macros are all about. In this respect, POV-Ray macros are 
 exactly like traditional macros in that they use macro substitution for the body of the macro. However traditional 
 macros also use this cut-and-paste substitution strategy for parameters but POV-Ray does not. 
</p>

<p>
  Suppose you have a macro in the C programming language <code> Typical_Cmac(Param)</code> and you invoke it as <code>Typical_Cmac(else 
 A=B)</code>. Anywhere that <code>Param</code> appears in the macro body, the four tokens <code>else</code>, <code>A</code>, 
 <code>=</code>, and <code> B</code> are substituted into the program code using a cut-and-paste operation. No type 
 checking is performed because anything is legal. The ability to pass an arbitrary group of tokens via a macro 
 parameter is a powerful (and sadly often abused) feature of traditional macros. 
</p>

<p>
  After careful deliberation, we have decided against this type of parameters for our macros. The reason is that 
 POV-Ray uses commas more frequently in its syntax than do most programming languages. Suppose you create a macro that 
 is designed to operate on one vector and two floats. It might be defined <code> OurMac(V,F1,F2)</code>. If you allow 
 arbitrary strings of tokens and invoke a macro such as <code>OurMac(&lt;1,2,3&gt;,4,5)</code> then it is impossible to 
 tell if this is a vector and two floats or if its 5 parameters with the two tokens <code>&lt;</code> and <code>1</code> 
 as the first parameter. If we design the macro to accept 5 parameters then we cannot invoke it like this... <code>OurMac(MyVector,4,5)</code>. 
 
</p>

<p>
  Function parameters in traditional programming languages do not use token substitution to pass values. They create 
 temporary, local variables to store parameters that are either constant values or identifier references which are in 
 effect a pointer to a variable. POV-Ray macros use this function-like system for passing parameters to its macros. In 
 our example <code> OurMac(&lt;1,2,3&gt;,4,5)</code>, POV-Ray sees the <code>&lt;</code> and knows it must be the start 
 of a vector. It parses the whole vector expression and assigns it to the first parameter exactly as though you had 
 used the statement <code>#local V=&lt;1,2,3&gt;;</code>. 
</p>

<p>
  Although we say that POV-Ray parameters are more like traditional function parameters than macro parameters, there 
 still is one difference. Most languages require you to declare the type of each parameter in the definition before you 
 use it but POV-Ray does not. This should be no surprise because most languages require you to declare the type of any 
 identifier before you use it but POV-Ray does not. This means that if you pass the wrong type value in a POV-Ray macro 
 parameter, it may not generate an error until you reference the identifier in the macro body. No type checking is 
 performed as the parameter is passed. So in this very limited respect, POV-Ray parameters are somewhat macro-like but 
 are mostly function-like. 
</p>

<h5><a name="s03_02_02_08_04">3.2.2.8.4 </a>Returning a Value Like a Function</h5>
<a name="s03_02_02_08_04_i1">
<p>
  POV-Ray macros have a variety of uses. Like most macros, they provide a parameterized way to insert arbitrary code 
 into a scene file. However most POV-Ray macros will be used like functions or procedures in a traditional programming 
 language. Macros are designed to fill all of these roles. 
</p>

<p>
  When the body of a macro consists of statements that create an entire item such as an object, texture, etc. then 
 the macro acts like a function which returns a single value. The <code>Make_Frame</code> macro example in the section 
 &quot;<a href="s_98.html#s03_02_02_08_02">Invoking Macros</a>&quot; above is such a macro which returns a value that 
 is an object. Here are some examples of how you might invoke it. 
</p>

<pre>
 union {  //make a union of two objects
   object{ Make_Frame(8,10,7,9,1) translate  20*x}
   object{ Make_Frame(8,10,7,9,1) translate -20*x}
 }
 #declare BigFrame = object{ Make_Frame(8,10,7,9,1)}
 #declare SmallFrame = object{ Make_Frame(5,4,4,3,0.5)}
</pre>

<p>
  Because no type checking is performed on parameters and because the expression syntax for floats, vectors, and 
 colors is identical, you can create clever macros which work on all three. See the sample scene <code> MACRO3.POV</code> 
 which includes this macro to interpolate values. 
</p>

<pre>
// Define the macro.  Parameters are:
//   T:  Middle value of time
//   T1: Initial time
//   T2: Final time
//   P1: Initial position (may be float, vector or color)
//   P2: Final position (may be float, vector or color)
//   Result is a value between P1 and P2 in the same proportion
//    as T is between T1 and T2.
#macro Interpolate(T,T1,T2,P1,P2)
   (P1+(T1+T/(T2-T1))*(P2-P1))
#end
</pre>

<p>
  You might invoke it with <code>P1</code> and <code>P2</code> as floats, vectors, or colors as follows. 
</p>

<pre>
sphere{
  Interpolate(I,0,15,&lt;2,3,4&gt;,&lt;9,8,7&gt;), //center location is vector
  Interpolate(I,0,15,3.0,5.5)          //radius is float
  pigment {
    color Interpolate(I,0,15,rgb&lt;1,1,0&gt;,rgb&lt;0,1,1&gt;)
  }
}
</pre>

<p>
  As the float value <code>I</code> varies from 0 to 15, the location, radius, and color of the sphere vary 
 accordingly. 
</p>

<p>
  There is a danger in using macros as functions. In a traditional programming language function, the result to be 
 returned is actually assigned to a temporary variable and the invoking code treats it as a variable of a given type. 
 However macro substitution may result in invalid or undesired syntax. The definition of the macro <code>Interpolate</code> 
 above has an outermost set of parentheses. If those parentheses are omitted, it will not matter in the examples above, 
 but what if you do this... 
</p>

<pre>
 #declare Value = Interpolate(I,0,15,3.0,5.5)*15;
</pre>

<p>
  The end result is as if you had done... 
</p>

<pre>
 #declare Value = P1+(T1+T/(T2-T1))*(P2-P1) * 15;
</pre>

<p>
  which is syntactically legal but not mathematically correct because the <code>P1</code> term is not multiplied. The 
 parentheses in the original example solves this problem. The end result is as if you had done... 
</p>

<pre>
 #declare Value = (P1+(T1+T/(T2-T1))*(P2-P1)) * 15;
</pre>

<p>
  which is correct. 
</p>

<h5><a name="s03_02_02_08_05">3.2.2.8.5 </a>Returning Values Via Parameters</h5>
<a name="s03_02_02_08_05_i1">
<p>
  Sometimes it is necessary to have a macro return more than one value or you may simply prefer to return a value via 
 a parameter as is typical in traditional programming language procedures. POV-Ray macros are capable of returning 
 values this way. The syntax for POV-Ray macro parameters says that the actual parameter may be an <em>IDENTIFIER</em> 
 or an <em> RVALUE</em>. Values may only be returned via a parameter if the parameter is an <em> IDENTIFIER</em>. 
 Parameters that are <em>RVALUES</em> are constant values that cannot return information. An <em>RVALUE</em> is 
 anything that legally may appear to the right of an equals sign in a <code> #declare</code> or <code>#local</code> 
 directive. For example consider the following trivial macro which rotates an object about the x-axis. 
</p>

<pre>
 #macro Turn_Me(Stuff,Degrees)
   #declare Stuff = object{Stuff rotate x*Degrees}
 #end
</pre>

<p>
  This attempts to re-declare the identifier <code>Stuff</code> as the rotated version of the object. However the 
 macro might be invoked with <code> Turn_Me(box{0,1},30)</code> which uses a box object as an <em> RVALUE</em> 
 parameter. This will not work because the box is not an identifier. You can however do this 
</p>

<pre>
   #declare MyObject=box{0,1}
   Turn_Me(MyObject,30)
</pre>

<p>
  The identifier <code>MyObject</code> now contains the rotated box. 
</p>

<p>
  See &quot;<a href="s_98.html#s03_02_02_02_03">Identifier Name Collisions</a>&quot; for a detailed discussion of how 
 local identifiers, parameters, and global identifiers work when a local identifier has the same name as a previously 
 declared identifier. 
</p>

<p>
  While it is obvious that <code>MyObject</code> is an identifier and <code> box{0,1}</code> is not, it should be 
 noted that <code> Turn_Me(object{MyObject},30)</code> will not work because <code> object{MyObject}</code> is 
 considered an object statement and is not a <em> pure</em> identifier. This mistake is more likely to be made with 
 float identifiers versus float expressions. Consider these examples. 
</p>

<pre>
  #declare Value=5.0;
  MyMacro(Value)     //MyMacro can change the value of Value but...
  MyMacro(+Value)    //This version and the rest are not lone
  MyMacro(Value+0.0) // identifiers. They are float expressions
  MyMacro(Value*1.0) // which cannot be changed.
</pre>

<p>
  Although all four invocations of <code>MyMacro</code> are passed the value 5.0, only the first may modify the value 
 of the identifier. 
</p>

<p>
 <a name="l120">
<small><strong>More about &quot;#macro&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_156.html#s03_08_04_08">3.8.4.8 Macro</a> in 3.8.4 Language Directives
  </small>

  <li><small>
   <a href="s_98.html#s03_02_02_08">3.2.2.8 User Defined Macros</a> in 3.2.2 Language Directives
  </small>

 </ul>

</p>

<p>
 <a name="l121">
<small><strong>More about &quot;texture&quot;</strong></small>
</a>
 <ul>
  
  <li><small>
   <a href="s_114.html#s03_05">3.5 Textures</a> in 3 POV-Ray Reference
  </small>

  <li><small>
   <a href="s_162.html#s03_08_10">3.8.10 Texture</a> in 3.8 Quick Reference
  </small>

 </ul>

</p>
 <br> 
<table class="NavBar" width="100%">
  
 <tr>
   
  <td align="left" nowrap="" valign="middle" width="32">
    <a href="s_97.html"><img alt="previous" border="0" src="prev.png"></a> 
   
  </td>
   
  <td align="left" valign="middle" width="30%">
    <a href="s_97.html">3.2.1 Language Basics</a> 
  </td>
   
  <td align="center" valign="middle">
    <strong>3.2.2 Language Directives</strong> 
  </td>
   
  <td align="right" valign="middle" width="30%">
    <a href="s_99.html">3.3 Scene Settings</a> 
  </td>
   
  <td align="right" nowrap="" valign="middle" width="32">
    <a href="s_99.html"><img alt="next" border="0" src="next.png"></a> 
   
  </td>
   
 </tr>
  
</table>
 </body> </html>