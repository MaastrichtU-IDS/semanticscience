
===========
Numpy C-API
===========
::

  int
  PyArray_SetNumericOps(PyObject *dict)

Set internal structure with number functions that all arrays will use

::

  PyObject *
  PyArray_GetNumericOps(void )

Get dictionary showing number functions that all arrays will use

::

  int
  PyArray_INCREF(PyArrayObject *mp)

For object arrays, increment all internal references.

::

  int
  PyArray_XDECREF(PyArrayObject *mp)

Decrement all internal references for object arrays.
(or arrays with object fields)

::

  void
  PyArray_SetStringFunction(PyObject *op, int repr)

Set the array print function to be a Python function.

::

  PyArray_Descr *
  PyArray_DescrFromType(int type)

Get the PyArray_Descr structure for a type.

::

  PyObject *
  PyArray_TypeObjectFromType(int type)

Get a typeobject from a type-number -- can return NULL.

::

  char *
  PyArray_Zero(PyArrayObject *arr)

Get pointer to zero of correct type for array.

::

  char *
  PyArray_One(PyArrayObject *arr)

Get pointer to one of correct type for array

::

  PyObject *
  PyArray_CastToType(PyArrayObject *mp, PyArray_Descr *at, int fortran)

Cast an array using typecode structure.

::

  int
  PyArray_CastTo(PyArrayObject *out, PyArrayObject *mp)

Cast to an already created array.

::

  int
  PyArray_CastAnyTo(PyArrayObject *out, PyArrayObject *mp)

Cast to an already created array.  Arrays don't have to be "broadcastable"
Only requirement is they have the same number of elements.

::

  int
  PyArray_CanCastSafely(int fromtype, int totype)

Check the type coercion rules.

::

  npy_bool
  PyArray_CanCastTo(PyArray_Descr *from, PyArray_Descr *to)


::

  int
  PyArray_ObjectType(PyObject *op, int minimum_type)

Return the typecode of the array a Python object would be converted
to

::

  PyArray_Descr *
  PyArray_DescrFromObject(PyObject *op, PyArray_Descr *mintype)


::

  PyArrayObject **
  PyArray_ConvertToCommonType(PyObject *op, int *retn)


::

  PyArray_Descr *
  PyArray_DescrFromScalar(PyObject *sc)

Return descr object from array scalar.

::

  PyArray_Descr *
  PyArray_DescrFromTypeObject(PyObject *type)


::

  npy_intp
  PyArray_Size(PyObject *op)

Compute the size of an array (in number of items)

::

  PyObject *
  PyArray_Scalar(void *data, PyArray_Descr *descr, PyObject *base)

Get scalar-equivalent to a region of memory described by a descriptor.

::

  PyObject *
  PyArray_FromScalar(PyObject *scalar, PyArray_Descr *outcode)

Get 0-dim array from scalar

::

  void
  PyArray_ScalarAsCtype(PyObject *scalar, void *ctypeptr)

Convert to c-type

::

  int
  PyArray_CastScalarToCtype(PyObject *scalar, void
                            *ctypeptr, PyArray_Descr *outcode)

Cast Scalar to c-type

::

  int
  PyArray_CastScalarDirect(PyObject *scalar, PyArray_Descr
                           *indescr, void *ctypeptr, int outtype)

Cast Scalar to c-type

::

  PyObject *
  PyArray_ScalarFromObject(PyObject *object)

Get an Array Scalar From a Python Object
Returns NULL if unsuccessful but error is only
set if another error occurred. Currently only Numeric-like
object supported.

::

  PyArray_VectorUnaryFunc *
  PyArray_GetCastFunc(PyArray_Descr *descr, int type_num)

Get a cast function to cast from the input descriptor to the
output type_number (must be a registered data-type).
Returns NULL if un-successful.

::

  PyObject *
  PyArray_FromDims(int nd, int *d, int type)

Construct an empty array from dimensions and typenum

::

  PyObject *
  PyArray_FromDimsAndDataAndDescr(int nd, int *d, PyArray_Descr
                                  *descr, char *data)

Like FromDimsAndData but uses the Descr structure instead of typecode
as input.

::

  PyObject *
  PyArray_FromAny(PyObject *op, PyArray_Descr *newtype, int
                  min_depth, int max_depth, int flags, PyObject
                  *context)


::

  PyObject *
  PyArray_EnsureArray(PyObject *op)


::

  PyObject *
  PyArray_EnsureAnyArray(PyObject *op)


::

  PyObject *
  PyArray_FromFile(FILE *fp, PyArray_Descr *dtype, intp num, char *sep)


Given a ``FILE *`` pointer ``fp``, and a ``PyArray_Descr``, return an
array corresponding to the data encoded in that file.

If the dtype is NULL, the default array type is used (double).
If non-null, the reference is stolen.

The number of elements to read is given as ``num``; if it is < 0, then
then as many as possible are read.

If ``sep`` is NULL or empty, then binary data is assumed, else
text data, with ``sep`` as the separator between elements. Whitespace in
the separator matches any length of whitespace in the text, and a match
for whitespace around the separator is added.

For memory-mapped files, use the buffer interface. No more data than
necessary is read by this routine.

::

  PyObject *
  PyArray_FromString(char *data, intp slen, PyArray_Descr *dtype, intp
                     num, char *sep)


Given a pointer to a string ``data``, a string length ``slen``, and
a ``PyArray_Descr``, return an array corresponding to the data
encoded in that string.

If the dtype is NULL, the default array type is used (double).
If non-null, the reference is stolen.

If ``slen`` is < 0, then the end of string is used for text data.
It is an error for ``slen`` to be < 0 for binary data (since embedded NULLs
would be the norm).

The number of elements to read is given as ``num``; if it is < 0, then
then as many as possible are read.

If ``sep`` is NULL or empty, then binary data is assumed, else
text data, with ``sep`` as the separator between elements. Whitespace in
the separator matches any length of whitespace in the text, and a match
for whitespace around the separator is added.

::

  PyObject *
  PyArray_FromBuffer(PyObject *buf, PyArray_Descr *type, intp
                     count, intp offset)


::

  PyObject *
  PyArray_FromIter(PyObject *obj, PyArray_Descr *dtype, intp count)


::

  PyObject *
  PyArray_Return(PyArrayObject *mp)

Return either an array or the appropriate Python object if the array
is 0d and matches a Python type.

::

  PyObject *
  PyArray_GetField(PyArrayObject *self, PyArray_Descr *typed, int
                   offset)

Get a subset of bytes from each element of the array

::

  int
  PyArray_SetField(PyArrayObject *self, PyArray_Descr *dtype, int
                   offset, PyObject *val)

Set a subset of bytes from each element of the array

::

  PyObject *
  PyArray_Byteswap(PyArrayObject *self, Bool inplace)


::

  PyObject *
  PyArray_Resize(PyArrayObject *self, PyArray_Dims *newshape, int
                 refcheck, NPY_ORDER fortran)

Resize (reallocate data).  Only works if nothing else is referencing
this array and it is contiguous.
If refcheck is 0, then the reference count is not checked
and assumed to be 1.
You still must own this data and have no weak-references and no base
object.

::

  int
  PyArray_MoveInto(PyArrayObject *dest, PyArrayObject *src)

Move the memory of one array into another.

::

  int
  PyArray_CopyInto(PyArrayObject *dest, PyArrayObject *src)

Copy an Array into another array -- memory must not overlap.

::

  int
  PyArray_CopyAnyInto(PyArrayObject *dest, PyArrayObject *src)

Copy an Array into another array -- memory must not overlap
Does not require src and dest to have "broadcastable" shapes
(only the same number of elements).

::

  int
  PyArray_CopyObject(PyArrayObject *dest, PyObject *src_object)


::

  PyObject *
  PyArray_NewCopy(PyArrayObject *m1, NPY_ORDER fortran)

Copy an array.

::

  PyObject *
  PyArray_ToList(PyArrayObject *self)

To List

::

  PyObject *
  PyArray_ToString(PyArrayObject *self, NPY_ORDER order)


::

  int
  PyArray_ToFile(PyArrayObject *self, FILE *fp, char *sep, char *format)

To File

::

  int
  PyArray_Dump(PyObject *self, PyObject *file, int protocol)


::

  PyObject *
  PyArray_Dumps(PyObject *self, int protocol)


::

  int
  PyArray_ValidType(int type)

Is the typenum valid?

::

  void
  PyArray_UpdateFlags(PyArrayObject *ret, int flagmask)

Update Several Flags at once.

::

  PyObject *
  PyArray_New(PyTypeObject *subtype, int nd, intp *dims, int
              type_num, intp *strides, void *data, int itemsize, int
              flags, PyObject *obj)

Generic new array creation routine.

::

  PyObject *
  PyArray_NewFromDescr(PyTypeObject *subtype, PyArray_Descr *descr, int
                       nd, intp *dims, intp *strides, void *data, int
                       flags, PyObject *obj)

Generic new array creation routine.

::

  PyArray_Descr *
  PyArray_DescrNew(PyArray_Descr *base)


::

  PyArray_Descr *
  PyArray_DescrNewFromType(int type_num)


::

  double
  PyArray_GetPriority(PyObject *obj, double default_)

Get Priority from object

::

  PyObject *
  PyArray_IterNew(PyObject *obj)

Get Iterator.

::

  PyObject *
  PyArray_MultiIterNew(int n, ... )

Get MultiIterator,

::

  int
  PyArray_PyIntAsInt(PyObject *o)


::

  npy_intp
  PyArray_PyIntAsIntp(PyObject *o)


::

  int
  PyArray_Broadcast(PyArrayMultiIterObject *mit)


::

  void
  PyArray_FillObjectArray(PyArrayObject *arr, PyObject *obj)


::

  int
  PyArray_FillWithScalar(PyArrayObject *arr, PyObject *obj)


::

  npy_bool
  PyArray_CheckStrides(int elsize, int nd, intp numbytes, intp
                       offset, intp *dims, intp *newstrides)


::

  PyArray_Descr *
  PyArray_DescrNewByteorder(PyArray_Descr *self, char newendian)

Deep bytorder change of a data-type descriptor
Leaves reference count of self unchanged --- does not DECREF self ***

::

  PyObject *
  PyArray_IterAllButAxis(PyObject *obj, int *inaxis)

Get Iterator that iterates over all but one axis (don't use this with
PyArray_ITER_GOTO1D).  The axis will be over-written if negative
with the axis having the smallest stride.

::

  PyObject *
  PyArray_CheckFromAny(PyObject *op, PyArray_Descr *descr, int
                       min_depth, int max_depth, int requires, PyObject
                       *context)


::

  PyObject *
  PyArray_FromArray(PyArrayObject *arr, PyArray_Descr *newtype, int
                    flags)


::

  PyObject *
  PyArray_FromInterface(PyObject *input)


::

  PyObject *
  PyArray_FromStructInterface(PyObject *input)


::

  PyObject *
  PyArray_FromArrayAttr(PyObject *op, PyArray_Descr *typecode, PyObject
                        *context)


::

  NPY_SCALARKIND
  PyArray_ScalarKind(int typenum, PyArrayObject **arr)


::

  int
  PyArray_CanCoerceScalar(int thistype, int neededtype, NPY_SCALARKIND
                          scalar)


::

  PyObject *
  PyArray_NewFlagsObject(PyObject *obj)

Get New ArrayFlagsObject

::

  npy_bool
  PyArray_CanCastScalar(PyTypeObject *from, PyTypeObject *to)

See if array scalars can be cast.

::

  int
  PyArray_CompareUCS4(npy_ucs4 *s1, npy_ucs4 *s2, register size_t len)


::

  int
  PyArray_RemoveSmallest(PyArrayMultiIterObject *multi)

Adjusts previously broadcasted iterators so that the axis with
the smallest sum of iterator strides is not iterated over.
Returns dimension which is smallest in the range [0,multi->nd).
A -1 is returned if multi->nd == 0.

::

  int
  PyArray_ElementStrides(PyObject *arr)


::

  void
  PyArray_Item_INCREF(char *data, PyArray_Descr *descr)


::

  void
  PyArray_Item_XDECREF(char *data, PyArray_Descr *descr)


::

  PyObject *
  PyArray_FieldNames(PyObject *fields)

Return the tuple of ordered field names from a dictionary.

::

  PyObject *
  PyArray_Transpose(PyArrayObject *ap, PyArray_Dims *permute)

Return Transpose.

::

  PyObject *
  PyArray_TakeFrom(PyArrayObject *self0, PyObject *indices0, int
                   axis, PyArrayObject *ret, NPY_CLIPMODE clipmode)

Take

::

  PyObject *
  PyArray_PutTo(PyArrayObject *self, PyObject*values0, PyObject
                *indices0, NPY_CLIPMODE clipmode)

Put values into an array

::

  PyObject *
  PyArray_PutMask(PyArrayObject *self, PyObject*values0, PyObject*mask0)

Put values into an array according to a mask.

::

  PyObject *
  PyArray_Repeat(PyArrayObject *aop, PyObject *op, int axis)

Repeat the array.

::

  PyObject *
  PyArray_Choose(PyArrayObject *ip, PyObject *op, PyArrayObject
                 *ret, NPY_CLIPMODE clipmode)


::

  int
  PyArray_Sort(PyArrayObject *op, int axis, NPY_SORTKIND which)

Sort an array in-place

::

  PyObject *
  PyArray_ArgSort(PyArrayObject *op, int axis, NPY_SORTKIND which)

ArgSort an array

::

  PyObject *
  PyArray_SearchSorted(PyArrayObject *op1, PyObject *op2, NPY_SEARCHSIDE
                       side)

Numeric.searchsorted(a,v)

::

  PyObject *
  PyArray_ArgMax(PyArrayObject *op, int axis, PyArrayObject *out)

ArgMax

::

  PyObject *
  PyArray_ArgMin(PyArrayObject *ap, int axis, PyArrayObject *out)

ArgMin

::

  PyObject *
  PyArray_Reshape(PyArrayObject *self, PyObject *shape)

Reshape an array

::

  PyObject *
  PyArray_Newshape(PyArrayObject *self, PyArray_Dims *newdims, NPY_ORDER
                   fortran)

New shape for an array

::

  PyObject *
  PyArray_Squeeze(PyArrayObject *self)


::

  PyObject *
  PyArray_View(PyArrayObject *self, PyArray_Descr *type, PyTypeObject
               *pytype)

View

::

  PyObject *
  PyArray_SwapAxes(PyArrayObject *ap, int a1, int a2)

SwapAxes

::

  PyObject *
  PyArray_Max(PyArrayObject *ap, int axis, PyArrayObject *out)

Max

::

  PyObject *
  PyArray_Min(PyArrayObject *ap, int axis, PyArrayObject *out)

Min

::

  PyObject *
  PyArray_Ptp(PyArrayObject *ap, int axis, PyArrayObject *out)

Ptp

::

  PyObject *
  PyArray_Mean(PyArrayObject *self, int axis, int rtype, PyArrayObject
               *out)

Mean

::

  PyObject *
  PyArray_Trace(PyArrayObject *self, int offset, int axis1, int
                axis2, int rtype, PyArrayObject *out)

Trace

::

  PyObject *
  PyArray_Diagonal(PyArrayObject *self, int offset, int axis1, int
                   axis2)

Diagonal

::

  PyObject *
  PyArray_Clip(PyArrayObject *self, PyObject *min, PyObject
               *max, PyArrayObject *out)

Clip

::

  PyObject *
  PyArray_Conjugate(PyArrayObject *self, PyArrayObject *out)

Conjugate

::

  PyObject *
  PyArray_Nonzero(PyArrayObject *self)

Nonzero

::

  PyObject *
  PyArray_Std(PyArrayObject *self, int axis, int rtype, PyArrayObject
              *out, int variance)

Std

::

  PyObject *
  PyArray_Sum(PyArrayObject *self, int axis, int rtype, PyArrayObject
              *out)

Sum

::

  PyObject *
  PyArray_CumSum(PyArrayObject *self, int axis, int rtype, PyArrayObject
                 *out)

CumSum

::

  PyObject *
  PyArray_Prod(PyArrayObject *self, int axis, int rtype, PyArrayObject
               *out)

Prod

::

  PyObject *
  PyArray_CumProd(PyArrayObject *self, int axis, int
                  rtype, PyArrayObject *out)

CumProd

::

  PyObject *
  PyArray_All(PyArrayObject *self, int axis, PyArrayObject *out)

All

::

  PyObject *
  PyArray_Any(PyArrayObject *self, int axis, PyArrayObject *out)

Any

::

  PyObject *
  PyArray_Compress(PyArrayObject *self, PyObject *condition, int
                   axis, PyArrayObject *out)

Compress

::

  PyObject *
  PyArray_Flatten(PyArrayObject *a, NPY_ORDER order)

Flatten

::

  PyObject *
  PyArray_Ravel(PyArrayObject *a, NPY_ORDER fortran)

Ravel

::

  npy_intp
  PyArray_MultiplyList(register intp *l1, register int n)

Multiply a List

::

  int
  PyArray_MultiplyIntList(register int *l1, register int n)

Multiply a List of ints

::

  void *
  PyArray_GetPtr(PyArrayObject *obj, register intp*ind)

Produce a pointer into array

::

  int
  PyArray_CompareLists(intp *l1, intp *l2, int n)

Compare Lists

::

  int
  PyArray_AsCArray(PyObject **op, void *ptr, intp *dims, int
                   nd, PyArray_Descr*typedescr)

Simulat a C-array

::

  int
  PyArray_As1D(PyObject **op, char **ptr, int *d1, int typecode)

Convert to a 1D C-array

::

  int
  PyArray_As2D(PyObject **op, char ***ptr, int *d1, int *d2, int
               typecode)

Convert to a 2D C-array

::

  int
  PyArray_Free(PyObject *op, void *ptr)

Free pointers created if As2D is called

::

  int
  PyArray_Converter(PyObject *object, PyObject **address)

Useful to pass as converter function for O& processing in
PyArgs_ParseTuple.

::

  int
  PyArray_IntpFromSequence(PyObject *seq, intp *vals, int maxvals)

PyArray_IntpFromSequence

::

  PyObject *
  PyArray_Concatenate(PyObject *op, int axis)

Concatenate an arbitrary Python sequence into an array.

::

  PyObject *
  PyArray_InnerProduct(PyObject *op1, PyObject *op2)

Numeric.innerproduct(a,v)

::

  PyObject *
  PyArray_MatrixProduct(PyObject *op1, PyObject *op2)

Numeric.matrixproduct(a,v)

::

  PyObject *
  PyArray_CopyAndTranspose(PyObject *op)

Fast Copy and Transpose

::

  PyObject *
  PyArray_Correlate(PyObject *op1, PyObject *op2, int mode)

Numeric.correlate(a1,a2,mode)

::

  int
  PyArray_TypestrConvert(int itemsize, int gentype)

Typestr converter

::

  int
  PyArray_DescrConverter(PyObject *obj, PyArray_Descr **at)

Get typenum from an object -- None goes to PyArray_DEFAULT

::

  int
  PyArray_DescrConverter2(PyObject *obj, PyArray_Descr **at)

Get typenum from an object -- None goes to NULL

::

  int
  PyArray_IntpConverter(PyObject *obj, PyArray_Dims *seq)

Get intp chunk from sequence

::

  int
  PyArray_BufferConverter(PyObject *obj, PyArray_Chunk *buf)

Get buffer chunk from object

::

  int
  PyArray_AxisConverter(PyObject *obj, int *axis)

Get axis from an object (possibly None) -- a converter function,

::

  int
  PyArray_BoolConverter(PyObject *object, Bool *val)

Convert an object to true / false

::

  int
  PyArray_ByteorderConverter(PyObject *obj, char *endian)

Convert object to endian

::

  int
  PyArray_OrderConverter(PyObject *object, NPY_ORDER *val)

Convert an object to FORTRAN / C / ANY

::

  unsigned char
  PyArray_EquivTypes(PyArray_Descr *typ1, PyArray_Descr *typ2)


::

  PyObject *
  PyArray_Zeros(int nd, intp *dims, PyArray_Descr *type, int fortran)

Zeros

::

  PyObject *
  PyArray_Empty(int nd, intp *dims, PyArray_Descr *type, int fortran)

Empty

::

  PyObject *
  PyArray_Where(PyObject *condition, PyObject *x, PyObject *y)

Where

::

  PyObject *
  PyArray_Arange(double start, double stop, double step, int type_num)

Arange,

::

  PyObject *
  PyArray_ArangeObj(PyObject *start, PyObject *stop, PyObject
                    *step, PyArray_Descr *dtype)

ArangeObj,

::

  int
  PyArray_SortkindConverter(PyObject *obj, NPY_SORTKIND *sortkind)

Convert object to sort kind

::

  PyObject *
  PyArray_LexSort(PyObject *sort_keys, int axis)

LexSort an array providing indices that will sort a collection of arrays
lexicographically.  The first key is sorted on first, followed by the second key
-- requires that arg"merge"sort is available for each sort_key

Returns an index array that shows the indexes for the lexicographic sort along
the given axis.

::

  PyObject *
  PyArray_Round(PyArrayObject *a, int decimals, PyArrayObject *out)

Round

::

  unsigned char
  PyArray_EquivTypenums(int typenum1, int typenum2)


::

  int
  PyArray_RegisterDataType(PyArray_Descr *descr)

Register Data type
Does not change the reference count of descr

::

  int
  PyArray_RegisterCastFunc(PyArray_Descr *descr, int
                           totype, PyArray_VectorUnaryFunc *castfunc)

Register Casting Function
Replaces any function currently stored.

::

  int
  PyArray_RegisterCanCast(PyArray_Descr *descr, int
                          totype, NPY_SCALARKIND scalar)

Register a type number indicating that a descriptor can be cast
to it safely

::

  void
  PyArray_InitArrFuncs(PyArray_ArrFuncs *f)

Initialize arrfuncs to NULL

::

  PyObject *
  PyArray_IntTupleFromIntp(int len, intp *vals)

PyArray_IntTupleFromIntp

::

  int
  PyArray_TypeNumFromName(char *str)


::

  int
  PyArray_ClipmodeConverter(PyObject *object, NPY_CLIPMODE *val)

Convert an object to NPY_RAISE / NPY_CLIP / NPY_WRAP

::

  int
  PyArray_OutputConverter(PyObject *object, PyArrayObject **address)

Useful to pass as converter function for O& processing in
PyArgs_ParseTuple for output arrays

::

  PyObject *
  PyArray_BroadcastToShape(PyObject *obj, intp *dims, int nd)

Get Iterator broadcast to a particular shape

::

  void
  _PyArray_SigintHandler(int signum)


::

  void*
  _PyArray_GetSigintBuf(void )


::

  int
  PyArray_DescrAlignConverter(PyObject *obj, PyArray_Descr **at)

Get type-descriptor from an object forcing alignment if possible
None goes to DEFAULT type.

::

  int
  PyArray_DescrAlignConverter2(PyObject *obj, PyArray_Descr **at)

Get type-descriptor from an object forcing alignment if possible
None goes to NULL.

::

  int
  PyArray_SearchsideConverter(PyObject *obj, void *addr)

Convert object to searchsorted side

::

  PyObject *
  PyArray_CheckAxis(PyArrayObject *arr, int *axis, int flags)

PyArray_CheckAxis

::

  npy_intp
  PyArray_OverflowMultiplyList(register intp *l1, register int n)

Multiply a List of Non-negative numbers with over-flow detection.

::

  int
  PyArray_CompareString(char *s1, char *s2, size_t len)


