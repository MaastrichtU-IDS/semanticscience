<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<!-- This file generated using Python HTMLgen module. -->
<HEAD>
  <META NAME="GENERATOR" CONTENT="HTMLgen 2.1.1">
        <TITLE>Class MSMS - High level molecule surface class.</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#EE0000" VLINK="#990000">
<span style="width: 60px"></span> 
<A HREF="__init__-readxyzr.html"><IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/BTN_NextPage.gif" height="19" width="71" alt="Next" border="0"></A> 
<IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/blank.gif" height="19" width="71" alt="blank.gif"> 
<A HREF="index.html"><IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/BTN_HomePage.gif" height="19" width="74" alt="Home Page" border="0"></A> 
<H3>Class MSMS - High level molecule surface class.</H3>
<HR>

<H2>SYNOPSIS</H2>

<PRE>import __init__</PRE>

<PRE>class MSMS(MOLSRF)
  <A HREF="# def __init__(self, coords=None, radii=None, atnames=None, filename=None, name='msms', maxnat=0)"> def __init__(self, coords=None, radii=None, atnames=None, filename=None, name='msms', maxnat=0)</A>
  string __module__ = '__init__'
  <A HREF="# def buriedSurfaceArea(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)"> def buriedSurfaceArea(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)</A>
  <A HREF="# def buriedVertices(self, coords, component=None)"> def buriedVertices(self, coords, component=None)</A>
  <A HREF="# def compute(self, probe_radius=1.5, density=1.0)"> def compute(self, probe_radius=1.5, density=1.0)</A>
  <A HREF="# def compute_numeric_area_vol(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)"> def compute_numeric_area_vol(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)</A>
  <A HREF="# def compute_rs(self, probe_radius=1.5, allComponents=0, atoms=None)"> def compute_rs(self, probe_radius=1.5, allComponents=0, atoms=None)</A>
  <A HREF="# def compute_ses(self, component=None)"> def compute_ses(self, component=None)</A>
  <A HREF="# def compute_ses_area(self)"> def compute_ses_area(self)</A>
  <A HREF="# def detailed_info(self)"> def detailed_info(self)</A>
  <A HREF="# def getBuriedSurfaceTriangles(self, cut=1)"> def getBuriedSurfaceTriangles(self, cut=1)</A>
  <A HREF="# def getColorByType(self, component=None)"> def getColorByType(self, component=None)</A>
  <A HREF="# def getTriangles(self, atomIndices=None, base=0, component=0)"> def getTriangles(self, atomIndices=None, base=0, component=0)</A>
  <A HREF="# def info(self)"> def info(self)</A>
  <A HREF="# def initUpdateSurface(self, cut=15.0, cleanup_ses=0)"> def initUpdateSurface(self, cut=15.0, cleanup_ses=0)</A>
  <A HREF="# def resetBuriedVertexArea(self, component=None)"> def resetBuriedVertexArea(self, component=None)</A>
  <A HREF="# def resetBuriedVertexFlags(self, component=None)"> def resetBuriedVertexFlags(self, component=None)</A>
  <A HREF="# def triangulate(self, density=1.0, component=None)"> def triangulate(self, density=1.0, component=None)</A>
  <A HREF="# def triangulate_one_component(self, rs, density=1.0)"> def triangulate_one_component(self, rs, density=1.0)</A>
   def update(self, mode=msms.FULL, density=None, nup=0)
  <A HREF="# def updateCoordsFromFile(self, filename, max=-1)"> def updateCoordsFromFile(self, filename, max=-1)</A>
  <A HREF="# def updateSpheres(self, coords, indices)"> def updateSpheres(self, coords, indices)</A>
  <A HREF="# def updateSurface(self, mode=msms.FULL, density=1.0, update=0)"> def updateSurface(self, mode=msms.FULL, density=1.0, update=0)</A>
  <A HREF="# def updateSurfaceArea(self)"> def updateSurfaceArea(self)</A>
  <A HREF="# def write_ses_area(self, filename, component=None)"> def write_ses_area(self, filename, component=None)</A>
  <A HREF="# def write_triangulation(self, filename, no_header=1, component=None, format=msms.MS_TSES_ASCII )"> def write_triangulation(self, filename, no_header=1, component=None, format=msms.MS_TSES_ASCII )</A>

  # Methods inherited by MSMS from MOLSRFPtr
   def __del__(self,msmsc=msmsc)
   def __getattr__(self,name)
   def __repr__(self)
   def __setattr__(self,name,value)
   def findBuriedVertices(self, *_args, **_kwargs)
   def get_atm(self, *_args, **_kwargs)
</PRE>

<H2>DESCRIPTION</H2>


<P>Such an object can be built by passing wither a filename, an array of Nx4
coordinates or an array of Nx3 centers and an array of N radii.
The class provide methods to compute: one or several reduced surface
components (RS), the corresponding analytical models of the solvent
excluded surface (SES) and triangulations of these models.
In addition, methods to compute analytical and numerical surface areas for
the SES and SAS are available.
This object also provides methods to compute numerically patches of a SES
component buried by a second set of spheres.
Finally, methods allowing to assign new coordinates toa subset of atoms
and re-compute the surface partially are available.
</P>

<H3><A NAME=" def __init__(self, coords=None, radii=None, atnames=None, filename=None, name='msms', maxnat=0)"> def __init__(self, coords=None, radii=None, atnames=None, filename=None, name='msms', maxnat=0)</A></H3>


<P>MSMS &lt;- MSMS(coords=None, radii=None, atnames=None, filename=None,
name=<CODE>msms</CODE>
, maxnat=0)</P>


<P>    This class can be instantiated int a number of ways:</P>

<UL>
<LI>no arguments:
         m = MSMS()

<LI>with an array of Nx4 coordinates:
         m = MSMS(coords = c)

<LI>with an array of Nx3 centers and an array of radii:
         m = MSMS(coords = c, radii = r)

<LI>by specifying a filename from wich to load the xyzr and possibly names
         m = MSMS(filename)
</UL>


<P>    additional parameters are:
    name:    string to name that surface
    atnames: array of N atom names
    maxnat:  maximum number of atoms in the molecule. This number needs to be
             larger than largest number of atoms that surface will ever have.
    </P>

<H3><A NAME=" def buriedSurfaceArea(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)"> def buriedSurfaceArea(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)</A></H3>


<P>buriedSurfaceArea(component=None,mode=msmsc.MS_SEMI_ANALYTICAL)</P>


<P>Compute the surface area corresponding to the buried vertices.
If component is None, this operation is performed on all components.
Components are specified using 0-based integers, 0 being the external one
mode can be one of the following:</P>

<UL>
<LI>MS_NUMERICAL:       use triangle surface area

<LI>MS_SEMI_ANALYTICAL: use spherical triangles surface areas for contact
                      and reentrant faces

<LI>MS_BOTH:            do both calculations

</UL>

<H3><A NAME=" def buriedVertices(self, coords, component=None)"> def buriedVertices(self, coords, component=None)</A></H3>


<P>buriedVertices(coords, component=None)</P>


<P>tags all vertices of an SES trianuglated component that are buried by a
set of spheres.
coords has to be an Mx4 array of floats describing the centers and radii
of the set of spheres used to check if the surface is burried.
If component is None, this operation is performed on all components.
Components are specified using 0-based integers, 0 being the external one
</P>

<H3><A NAME=" def compute(self, probe_radius=1.5, density=1.0)"> def compute(self, probe_radius=1.5, density=1.0)</A></H3>


<P>err &lt;- self.compute(probe_radius=1.5, density=1.0)</P>


<P>Compute the external component of the reduced surface with the
specified probe_radius, then compute the solvent exclude surface
and triangulate it with the specified density.
Return MS_OK upon successfull completion or MS_ERR when it fails. In
the latter case an error message is available in MS_ERR_MSG</P>

<H3><A NAME=" def compute_numeric_area_vol(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)"> def compute_numeric_area_vol(self, component=None, mode=msmsc.MS_SEMI_ANALYTICAL)</A></H3>


<P>compute_numeric_area_vol(component=None,mode=msmsc.MS_SEMI_ANALYTICAL)</P>


<P>compute the surface area using the triangulated surface.
If component is None, all components are calculated. Components are
specified using 0-based integers, 0 being the external component.
mode can be one of the following:</P>

<UL>
<LI>MS_NUMERICAL:       use triangle surface area

<LI>MS_SEMI_ANALYTICAL: use spherical triangles surface areas for contact
                      and reentrant faces

<LI>MS_BOTH:            do both calculations

</UL>

<H3><A NAME=" def compute_rs(self, probe_radius=1.5, allComponents=0, atoms=None)"> def compute_rs(self, probe_radius=1.5, allComponents=0, atoms=None)</A></H3>


<P>self.compute_rs(probe_radius=1.5, allComponents=0, atoms=None)</P>


<P>Compute the external component of the reduced surface.
probe_radius:  should be larger than 0.1.
allComponents: can be either 0 or 1. When it is 1 all surface components
               are looked for and the complexity becomes N^2
atoms:         list of 3 0-based atom indices used to seed the RS
               calculation. This is useful to compute a specific component
</P>

<H3><A NAME=" def compute_ses(self, component=None)"> def compute_ses(self, component=None)</A></H3>


<P>self.compute_ses(component=None)</P>


<P>Compute the analytical SES for the specified component correponding to a
user specified component of the reduced surface.
if component is None, all components are calculated. Components are
specified using 0-based integers, 0 being the external component
</P>

<H3><A NAME=" def compute_ses_area(self)"> def compute_ses_area(self)</A></H3>


<P>err &lt;- compute_ses_area()</P>


<P>Compute the surface area of all faces of the analytical SES model.
after that computation, each SESF has its a_ses_area member set
and the SES has the members a_reent_area, a_toric_area, a_contact_area and
a_ses_area and a_sas_area set.
</P>

<H3><A NAME=" def detailed_info(self)"> def detailed_info(self)</A></H3>


<P> string &lt;- detailed_info(()</P>


<P>return a string describing this molecular surface
</P>

<H3><A NAME=" def getBuriedSurfaceTriangles(self, cut=1)"> def getBuriedSurfaceTriangles(self, cut=1)</A></H3>


<P>vfloat, vint, tri = getBuriedSurfaceTriangles(cut=1)</P>


<P>Return the triangles of the external SES component for which at least <CODE>cut</CODE>

vertices are buried. Obviously 0 &lt; cut &lt; 4.</P>


<P>vfloat and vint hold the data for all vertices of the surface.
tri contains the subset of the triangles that are buried.
</P>

<H3><A NAME=" def getColorByType(self, component=None)"> def getColorByType(self, component=None)</A></H3>


<P>colors &lt;- getColorByType(component=None)</P>


<P>Compute the surface area corresponding to the buried vertices.
If component is None, this operation is performed on all components.
Components are specified using 0-based integers, 0 being the external one
it returns a list of (r,g,b) tuples for each component
</P>

<H3><A NAME=" def getTriangles(self, atomIndices=None, base=0, component=0)"> def getTriangles(self, atomIndices=None, base=0, component=0)</A></H3>


<P>vfloat, vint, tri &lt;- getTriangles(atomIndices=None, base=0, component=0)
Return numeric arrays for vertices floating point (vfloat) and integer
(vint) data and triangles data (tri).
For each vertex vfloat provides (x,y,z,nx,ny,nz,sesA,sasA)
for each vertex vint provides (type, closestAtomindex, buried), where
type can be -1 for SESV, -2 for SESE and the SESF number for vertices
inside faces; closestAtomindex is the 1 based index of the atom closest
to that vertex and buried is 0 or 1 if this vertex is buried.
For each triangles tri provides (i, j, k, type, SESF_num), where type can
be 1:contact, 2:reentrant, 3:toroidal, 4:full torus and
5:full torus with radial singlarity.
The triple (i,j,k) describing the triangle's connectivity can be 0-based
or 1-based according to the value of base (0 or 1).
Components are specified using 0-based integers, 0 being the external
component
    </P>

<H3><A NAME=" def info(self)"> def info(self)</A></H3>


<P> string &lt;- info(()</P>


<P>return a string describing this molecular surface
</P>

<H3><A NAME=" def initUpdateSurface(self, cut=15.0, cleanup_ses=0)"> def initUpdateSurface(self, cut=15.0, cleanup_ses=0)</A></H3>


<P>initUpdateSurface(cut=15.0, cleanup_ses=0)</P>


<P>Call the initialize the data structure before the first partial
recomputation can be performed.
cut: is used as a radius to select probes in fixed positions close to
     the moving atoms
cleanup_ses: this flag has to be set to 1 in order for the genus of the
             updated SES to make sense.
</P>

<H3><A NAME=" def resetBuriedVertexArea(self, component=None)"> def resetBuriedVertexArea(self, component=None)</A></H3>


<P>resetBuriedVertexArea(component=None)</P>


<P>Reset the surface area assigned to each vertex in a triangulated SES
component.
If component is None, this operation is performed on all components.
Components are specified using 0-based integers, 0 being the external one
</P>

<H3><A NAME=" def resetBuriedVertexFlags(self, component=None)"> def resetBuriedVertexFlags(self, component=None)</A></H3>


<P>resetBuriedVertexFlags(component=None)</P>


<P>Reset the buried flag on all SES triangulation vertices.
If component is None, this operation is performed on all components.
Components are specified using 0-based integers, 0 being the external one
</P>

<H3><A NAME=" def triangulate(self, density=1.0, component=None)"> def triangulate(self, density=1.0, component=None)</A></H3>


<P>triangulate(self, density=1.0, component=None)</P>


<P>Triangulate analytical SES models using a user specified density.
If component is None, all components are calculated. Components are
specified using 0-based integers, 0 being the external component
    </P>

<H3><A NAME=" def triangulate_one_component(self, rs, density=1.0)"> def triangulate_one_component(self, rs, density=1.0)</A></H3>

<H4>triangulate_one_component(rs, density=1.0)</H4>


<P>    Triangulate a given solvent excluded component, with the specified
    density
</P>

<H3><A NAME=" def updateCoordsFromFile(self, filename, max=-1)"> def updateCoordsFromFile(self, filename, max=-1)</A></H3>


<P>updateCoordsFromFile(filename, max=-1)</P>


<P>Read a set of new coordinates from a file and assign them to the atoms.
max can be -1 for all atoms specified in the file to be used of any
integer smaller than the number of atoms in the file.
</P>

<H3><A NAME=" def updateSpheres(self, coords, indices)"> def updateSpheres(self, coords, indices)</A></H3>


<P>err &lt;- updateSpheres(coords, indices)</P>


<P>Not tested
coords: Nx4 array of floats
indiced: indices of moving atoms
    </P>

<H3><A NAME=" def updateSurface(self, mode=msms.FULL, density=1.0, update=0)"> def updateSurface(self, mode=msms.FULL, density=1.0, update=0)</A></H3>


<P>err &lt;- updateSurface(mode=mslib.FULL, density=1.0, update=0)</P>


<P>Recompute the surface after a subset of atoms assume new coordinates.
mode can be one of the following:
    FULL             : the surface is rebuilt completely
    TORIC            : only toric faces are triangulated
    ALL_WITH_DENSITY : all rebuilt faces are triangulated with the
                       given density
    define NO_TRIANGULATION : no triangulation at all
density: density of the reconstructed surface patches
update: update number
</P>

<H3><A NAME=" def updateSurfaceArea(self)"> def updateSurfaceArea(self)</A></H3>


<P>updateSurfaceArea()</P>


<P>Update the surface areas after the surface's geometry has been
re-computed.
</P>

<H3><A NAME=" def write_ses_area(self, filename, component=None)"> def write_ses_area(self, filename, component=None)</A></H3>


<P>write_ses_area(filename, component=None)</P>


<P>Write the surface areas to an output files. Results are written by atom.
If component is None, each component is wrtten to a file. Components are
specified using 0-based integers, 0 being the external component.
</P>

<H3><A NAME=" def write_triangulation(self, filename, no_header=1, component=None, format=msms.MS_TSES_ASCII )"> def write_triangulation(self, filename, no_header=1, component=None, format=msms.MS_TSES_ASCII )</A></H3>


<P>write_triangulation(filename, no_header=1, component=None,
format=msms.MS_TSES_ASCII)</P>


<P>    Write the solvent excluded surface to a file.
    no_header allows to add/remove the header lines to these files
    If component is None, all components are calculated. Components are
    specified using 0-based integers, 0 being the external component
    format can be one of the following:
        MS_TSES_ASCII     : Triangulated surface in ASCII format
        MS_ASES_ASCII     : Analytical surface in ASCII format. This is
                            actually a discrete representation of the
                            analytical model.
        MS_TSES_ASCII_AVS : Triangulated surface in ASCII with AVS header
        MS_ASES_ASCII_AVS : Analytical surface in ASCII format with AVS header
    </P>

<H2>SEE ALSO</H2>


<P><A HREF="__init___overview.html">__init__</A></P>


<P><A HREF="msms-MOLSRF.html">MOLSRF</A></P>


<P><HR>
<span style="width: 60px"></span> 
<A HREF="__init__-readxyzr.html"><IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/BTN_NextPage.gif" height="19" width="71" alt="Next" border="0"></A> 
<IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/blank.gif" height="19" width="71" alt="blank.gif"> 
<A HREF="index.html"><IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/BTN_HomePage.gif" height="19" width="74" alt="Home Page" border="0"></A> 
<BR><IMG src="/tsri/python/src/packages/HTMLgen/HTMLgen2.2/image/www_icon.gif" height="40" width="40" alt="www_icon.gif" align="bottom">
<FONT SIZE="-1"><P>Copyright &#169 M. Sanner<BR>All Rights Reserved<BR>

Comments to author: <A HREF="mailto:&#115;a&#110;n&#101;r&#64;s&#99;r&#105;p&#112;s&#46;e&#100;u">sanner@scripps.edu</A><br>
Generated: Fri Sep  1 2000 <BR><hr>
</FONT>
</BODY> </HTML>
