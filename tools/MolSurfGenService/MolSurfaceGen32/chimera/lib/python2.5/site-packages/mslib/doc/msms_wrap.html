<HTML>
<HEAD>
<TITLE>
MSMS library Module</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>MSMS library Module</H1>
<PRE>[ Python Module : msms ]
</PRE>

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. Description</A>
<LI> <A HREF="#s2_">2. Constants</A>
<UL><LI> <A HREF="#s2_1_">2.1. reduced surface output formats</A>
<LI> <A HREF="#s2_2_">2.2. restart modes</A>
<LI> <A HREF="#s2_3_">2.3. triangulation surface output formats</A>
<LI> <A HREF="#s2_4_">2.4. buried surface computation modes</A>
<LI> <A HREF="#s2_5_">2.5. SESF buried flag</A>
<LI> <A HREF="#s2_6_">2.6. analytical SES edges types</A>
<LI> <A HREF="#s2_7_">2.7. toroidal face types</A>
<LI> <A HREF="#s2_8_">2.8. error handling stuff</A>
<LI> <A HREF="#s2_9_">2.9. surface update triangulation modes</A>
</UL><LI> <A HREF="#s3_">3. GLOBALS</A>
<LI> <A HREF="#s4_">4. Data Structures</A>
<UL><LI> <A HREF="#s4_1_">4.1. Reduced Surface Data Structures</A>
<UL><LI> <A HREF="#s4_1_1_">4.1.1. class RSE</A>
<LI> <A HREF="#s4_1_2_">4.1.2. class RSV</A>
<LI> <A HREF="#s4_1_3_">4.1.3. class RSF</A>
<LI> <A HREF="#s4_1_4_">4.1.4. class RS</A>
<LI> <A HREF="#s4_1_5_">4.1.5. class RSR</A>
</UL><LI> <A HREF="#s4_2_">4.2. Triangulation</A>
<UL><LI> <A HREF="#s4_2_1_">4.2.1. class TRIV</A>
<LI> <A HREF="#s4_2_2_">4.2.2. class TRI</A>
</UL><LI> <A HREF="#s4_3_">4.3. Solvent Excluded Surface Data Structures</A>
<UL><LI> <A HREF="#s4_3_1_">4.3.1. class SESV</A>
<LI> <A HREF="#s4_3_2_">4.3.2. class SESE</A>
<LI> <A HREF="#s4_3_3_">4.3.3. class SESF</A>
<LI> <A HREF="#s4_3_4_">4.3.4. class SES</A>
<LI> <A HREF="#s4_3_5_">4.3.5. class SESR</A>
</UL><LI> <A HREF="#s4_4_">4.4. Molecular Surface</A>
<UL><LI> <A HREF="#s4_4_1_">4.4.1. class MOLSRF</A>
</UL></UL><LI> <A HREF="#s5_">5. Functions</A>
</UL>

<A name="s1_">
<HR><H2>1. Description</H2></A>
<PRE></PRE>
<P><PRE>
This module wraps the fast molecular surface calculation library developped 
by Michel Sanner at the Molecular Graphics lab. (TSRI)

The basic functionnality of this library is to create compute solvent excluded
surfaces of molecules. The input is a set of spheres for which a 3D position
can be specified (x,y,z) along with a radius (r) as wella s an optional name
(n). In a first step, a probe sphere representing a solvent molecule is rolled
over the set of spheres, defining the Reduced Surface (RS) (see reference 
below). The radius of the probe sphere is a user specified parameter. From 
the reduced surface the analytical model of the Solvent Excluded Surface (SES)
is computed. This analytical surface can be triangulated with a user specified
vertex density.
In addition, this library allows to:
    - compute and report surface areas that can be computed analytically or 
      numerically. 
    - compute the surface patches buried by a second set of spheres
    - upadte the surface after a subset of atoms assume new positions or radii
    - add/remove ?  atoms to the molecule and recompute the surface partially

example:

      import msms

References:

    - Sanner, M.F., Spehner, J.-C., and Olson, A.J. (1996) Reduced surface: 
      an efficient way to compute molecular surfaces. Biopolymers, Vol. 38, 
      (3), 305-320.
    - Michel F. Sanner and Arthur J. olson. (1997) Real Time Surface 
      Reconstruction For moving Molecular Fragments. Proc. Second Pacific 
      Symposium in Biocomputing.</PRE>

<A name="s2_">
<HR><H2>2. Constants</H2></A>
<PRE></PRE>
<A name="s2_1_">
<H3>2.1. reduced surface output formats</H3></A>
<PRE></PRE>
<P><TT><B>MS_RS_SIMPLE_ASCII1 = 0</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_RS_SIMPLE_ASCII2 = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_RS_SIMPLE_ASCII1_NORMALS = 2</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<A name="s2_2_">
<H3>2.2. restart modes</H3></A>
<PRE></PRE>
<P><TT><B>MS_NON_PARTIAL = 0</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_PARTIAL = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<A name="s2_3_">
<H3>2.3. triangulation surface output formats</H3></A>
<PRE></PRE>
<P><TT><B>MS_TSES_ASCII = 0</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
whole triangulated surface   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_ASES_ASCII = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
discrete representation of the Analytical surf.   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_TSES_ASCII_AVS = 10</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
same as MS_TSES_ASCII and AVS headers   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_ASES_ASCII_AVS = 11</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
same as MS_ASES_ASCII and AVS headers   
</PRE></BLOCKQUOTE>

<A name="s2_4_">
<H3>2.4. buried surface computation modes</H3></A>
<PRE></PRE>
<P><TT><B>MS_NUMERICAL = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
numerical calculation using flat triangles   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_SEMI_ANALYTICAL = 2</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
numerical calculation using spherical tri.   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_BOTH = 3</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<A name="s2_5_">
<H3>2.5. SESF buried flag</H3></A>
<PRE></PRE>
<P><TT><B>MS_NOT_BURIED = 0</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_BURIED = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_PARTIALLY_BURIED = 2</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<A name="s2_6_">
<H3>2.6. analytical SES edges types</H3></A>
<PRE></PRE>
<P><TT><B>SAILLANT = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>RENTRANT = 2</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>TORIQUE = 3</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>SINGULIER = 4</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>SINGULIER_TRAITE = 8</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>SELECT = 16</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>FULL_EATEN = 32</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>RENT_FUS = 64</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<A name="s2_7_">
<H3>2.7. toroidal face types</H3></A>
<PRE></PRE>
<P><TT><B>FULL_TORUS1 = 4</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
SES face type for full torus or first cone   
</PRE></BLOCKQUOTE>

<P><TT><B>FULL_TORUS2 = 5</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
SES face type for second cone of full torus   
</PRE></BLOCKQUOTE>

<A name="s2_8_">
<H3>2.8. error handling stuff</H3></A>
<PRE></PRE>
<P><TT><B>MS_OK = 0</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_ERR = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_ErrMsgMaxLen = 512</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
</PRE></BLOCKQUOTE>

<A name="s2_9_">
<H3>2.9. surface update triangulation modes</H3></A>
<PRE></PRE>
<P><TT><B>FULL = 0</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
the surface is rebuilt complete   
</PRE></BLOCKQUOTE>

<P><TT><B>TORIC = 1</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
only toric faces are triangulated   
</PRE></BLOCKQUOTE>

<P><TT><B>ALL_WITH_DENSITY = 2</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
all rebuilt faces are triangulated with the given density   
</PRE></BLOCKQUOTE>

<P><TT><B>NO_TRIANGULATION = 3</B></TT>
<BLOCKQUOTE><PRE>[ Constant: int  ]
no triangulation at all   
</PRE></BLOCKQUOTE>

<A name="s3_">
<HR><H2>3. GLOBALS</H2></A>
<PRE></PRE>
<P><TT><B>cvar.MS_VERSION</B></TT>
<BLOCKQUOTE><PRE>[ Global : char * MS_VERSION ]
</PRE></BLOCKQUOTE>

<P><TT><B>cvar.MS_err_flag</B></TT>
<BLOCKQUOTE><PRE>[ Global : int  MS_err_flag ]
</PRE></BLOCKQUOTE>

<P><TT><B>cvar.MS_err_msg</B></TT>
<BLOCKQUOTE><PRE>[ Global : char * MS_err_msg ]
</PRE></BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. Data Structures</H2></A>
<PRE></PRE>
<A name="s4_1_">
<H3>4.1. Reduced Surface Data Structures</H3></A>
<PRE></PRE>
<A name="s4_1_1_">
<H4>4.1.1. class RSE</H4></A>
<PRE>[ created from struct RSE__ ]
RS edges   

</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.f</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rsedual</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxtUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
pointeur vers la ou les faces toric dual   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
chain of deleted or reconstructed edges   
</PRE></BLOCKQUOTE>

<P><TT><B>self.n</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
structure qcq   
</PRE></BLOCKQUOTE>

<P><TT><B>self.ct</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
vecteur unitaire de l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.rt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double  ]
centre du tore   
</PRE></BLOCKQUOTE>

<P><TT><B>self.cp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
rayon du tore   
</PRE></BLOCKQUOTE>

<P><TT><B>self.angt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double  ]
centre de la sphere temoin (RS  free edge)   
</PRE></BLOCKQUOTE>

<P><TT><B>self.cc</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
ang entre z1,ct,z2 ou z1 et z2 sont les
                           positions initiale et finale de la sph temoin   
</PRE></BLOCKQUOTE>

<P><TT><B>self.rcc</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
centre des cercles de contact avec le premier
                            atome de l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.ps</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
rayon des cercles de contact   
</PRE></BLOCKQUOTE>

<P><TT><B>self.s</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int * ]
coord. of singular points   
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
indice des atomes sommets de l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.sing</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
numero de l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.comp_num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
# of singular points on each edge   
</PRE></BLOCKQUOTE>

<P><TT><B>self.type</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
numero de la composante connexe   
</PRE></BLOCKQUOTE>

<P><TT><B>_rsf0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_rsf1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_rsedual0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_rsedual1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_n(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_ct(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_cp(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_cc(OUT_ARRAY2D)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_rcc(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_ps(OUT_ARRAY2D)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_s(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_1_2_">
<H4>4.1.2. class RSV</H4></A>
<PRE>[ created from struct RSV__ ]
RS vertex   

</PRE>
<P><TT><B>self.a</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rs</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RS__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rsvdual</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
array of pointer to contact faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.ses_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.sas_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.x</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.r</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.orig_r</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
current atom radius, may change for restart   
</PRE></BLOCKQUOTE>

<P><TT><B>self.bhtind</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
original atom radius   
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
index of atm in rsr-&gt;atmBHT array of BHPoints  
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
numero de l'atome correspondant au sommet   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxtup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
numero du sommet prochain sommet duplique   
</PRE></BLOCKQUOTE>

<P><TT><B>self.type</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
next updated RS vertex   
</PRE></BLOCKQUOTE>

<P><TT><B>self.mnba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
type de l'atome, sert a trouver la sphere
                             triangulee   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
nombre d'aretes allouees   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
nombre d'aretes incidentes   
</PRE></BLOCKQUOTE>

<P><TT><B>self.pb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
nombre de faces de contact pour cet atome   
</PRE></BLOCKQUOTE>

<P><TT><B>self.surf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
used to mark atoms in pb faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.comp_num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
= 1 surface is computed for this atom
                             = 0 atom is used for collision only
                             = 2 if it has been found that this atom
                               cannot create surface
                             = 4 this atom has changed position or radius
                             = 8 this atom has a new radius because of a
                               restart during an update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.free_edge_checked</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
numero de la composante connexe   
</PRE></BLOCKQUOTE>

<P><TT><B>self.split</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
=1 when has been checked for free edge   
</PRE></BLOCKQUOTE>

<P><TT><B>self.name</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns char * ]
=1 when has been checked for free edge   
</PRE></BLOCKQUOTE>

<P><TT><B>get_a(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSE * ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_rsvdual(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_x(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_ses_area(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns double  ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_sas_area(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns double  ]
</PRE></BLOCKQUOTE>

<A name="s4_1_3_">
<H4>4.1.3. class RSF</H4></A>
<PRE>[ created from struct RSF__ ]
RS face   

</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rsfdual</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ ** ]
list des aretes de la face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fs</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
pointeur vers 1 ou 2 faces de SES (2 si
                               singuliere coupee) de SES   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxtUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
pointeur vers la face qui cree une lentille
                            entiere ou partielle   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxtbUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
chain of deleted or reconstructed face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
chain of RSF forming the boundary of the hole
                            created when RSF are deleted during update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.v</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.c</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
vect normal oriente exterieur   
</PRE></BLOCKQUOTE>

<P><TT><B>self.s</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
indexe des sommets dans le tableau atm   
</PRE></BLOCKQUOTE>

<P><TT><B>self.uind</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
face number for debugging purpose   
</PRE></BLOCKQUOTE>

<P><TT><B>self.sind</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
index of RSF in rsr-&gt;uprbBHP array of BHPoints  
</PRE></BLOCKQUOTE>

<P><TT><B>self.comp_num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
index of RSF in rsr-&gt;sprbBHP array of BHPoints  
</PRE></BLOCKQUOTE>

<P><TT><B>self.cp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
numero de la composante connexe   
</PRE></BLOCKQUOTE>

<P><TT><B>self.mfl</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
=1 si la sph. temoin coupe le plan de la face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.dir</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char * ]
utilise pour marquer les cotes traites 1,2,4
                            8 ==&gt; bad face (atom moved or changed rad)
                            16 ==&gt; set when close to moving atoms 
                            32, 64, 128 used by walk_over_rs   
</PRE></BLOCKQUOTE>

<P><TT><B>_a0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSE * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_a1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSE * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_a2()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSE * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_rsfdual0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_rsfdual1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_v(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_c(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_s(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_dir(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_1_4_">
<H4>4.1.4. class RS</H4></A>
<PRE>[ created from struct RS__ ]
RS header   

</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RS__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RS__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ses</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SES__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ffa</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lfa</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lorsf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.far</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
last kept RSF during update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.lar</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ffar</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lfar</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.fstrfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lstrfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
used to update surface: fst deleted RSF   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fstreup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lstreup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
used to update surface: fst deleted RSE   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fstRSbfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lstRSbfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSF__ * ]
list of RSF bounding the holes after delete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fstfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lstfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
list of SESF to be deleted   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fsteup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lsteup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
list of SESE to look at during update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.uprbRBHT</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns TRBHTree * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.sprbRBHT</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns TRBHTree * ]
growable and movable BHtree for all probes concerned
                      by the update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
dynamic size, movable potentially singular probes
                      BHtree, used surf.c to handle singularities   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbfcp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbfco</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
nombre de face de RS collees avec plus d'un cote coupe   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbaf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbs</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ffat</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.needFreeEdgeCheck</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
atom indexes for first RS face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.split_rsv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_dir(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_1_5_">
<H4>4.1.5. class RSR</H4></A>
<PRE>[ created from struct RSR__ ]
RS tree root   

</PRE>
<P><TT><B>self.fst</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RS__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lst</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RS__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.atm</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSV__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.atmBHT</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns TRBHTree * ]
growable and movable atoms BHtree   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nb_free_vert</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of RS components   
</PRE></BLOCKQUOTE>

<P><TT><B>self.ffnba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of free vertices in the Reduced Surface   
</PRE></BLOCKQUOTE>

<P><TT><B>self.ffat</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int * ]
atom indexes for first RS face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.all_comp_done</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ext_comp_done</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>set_ffat(at1,at2,at3)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_ffat(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_2_">
<H3>4.2. Triangulation</H3></A>
<PRE></PRE>
<A name="s4_2_1_">
<H4>4.2.1. class TRIV</H4></A>
<PRE>[ created from struct TRIV__ ]
</PRE>
<P><TT><B>self.c</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.n</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
coord. de ce sommet   
</PRE></BLOCKQUOTE>

<P><TT><B>self.uvw</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
vecteur normal a la surface   
</PRE></BLOCKQUOTE>

<P><TT><B>self.sesArea</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
array of texture uvw's   
</PRE></BLOCKQUOTE>

<P><TT><B>self.sasArea</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
per vertex SES surface area   
</PRE></BLOCKQUOTE>

<P><TT><B>self.atm</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
per vertex SAS surface area   
</PRE></BLOCKQUOTE>

<P><TT><B>self.tvn</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
# de l'atome auquel appartient ce sommet   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fl</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
# du sommet affichage et debuging   
</PRE></BLOCKQUOTE>

<P><TT><B>_c(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_n(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_uvw(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_2_2_">
<H4>4.2.2. class TRI</H4></A>
<PRE>[ created from struct TRI__ ]
</PRE>
<P><TT><B>self.s</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TRIV__ ** ]
triangular face   
</PRE></BLOCKQUOTE>

<P><TT><B>_s0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns TRIV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_s1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns TRIV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_s2()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns TRIV * ]
</PRE></BLOCKQUOTE>

<A name="s4_3_">
<H3>4.3. Solvent Excluded Surface Data Structures</H3></A>
<PRE>-----------------------------------------------------------------------
  data structures for Analytic Solvent Excluded Surface
---------------------------------------------------------------------  

</PRE>
<A name="s4_3_1_">
<H4>4.3.1. class SESV</H4></A>
<PRE>[ created from struct SESV__ ]
</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ * ]
Solvent Excluded Surface Vertex   
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.id</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ ** ]
pointeur vers un autre sommet si duplique   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
tableau de SESE   
</PRE></BLOCKQUOTE>

<P><TT><B>self.n</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.c</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
vecteur normal a la surface   
</PRE></BLOCKQUOTE>

<P><TT><B>self.beta</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
coord.   
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
angle between edges of the reentrant face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.at</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
numero d'ordre du sommet   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
numero de l'atome associe au sommet   
</PRE></BLOCKQUOTE>

<P><TT><B>self.mnba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
nba nombre de SESE   
</PRE></BLOCKQUOTE>

<P><TT><B>self.triv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TRIV__ * ]
nba nombre de *SESE alloues   
</PRE></BLOCKQUOTE>

<P><TT><B>self.type</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
vertex de la surface triangulee   
</PRE></BLOCKQUOTE>

<P><TT><B>get_a(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESE * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_c(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_n(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_3_2_">
<H4>4.3.2. class SESE</H4></A>
<PRE>[ created from struct SESE__ ]
</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
Solvent Excluded Surface Edge   
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.s</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.f</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ar</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct RSE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.triv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TRIV__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxtSESaUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
som. de la surface triangulee pour cette arete
                         triv[0] and triv[e-&gt;nbtriv-1] are the edge's end   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
list of SESE to look at during update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.n</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns double * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.c</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float * ]
vecteur unitaire ortho. au plan de l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.r</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
centre du cercle portant l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.theta</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
rayon de ce cercle   
</PRE></BLOCKQUOTE>

<P><TT><B>self.free_cap_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
  
</PRE></BLOCKQUOTE>

<P><TT><B>self.ang</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
  
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtriv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
angle de l'arc s[0],c,s[1]  
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangulation vertices internal to the
                            edge + 2 (for the ends)   
</PRE></BLOCKQUOTE>

<P><TT><B>self.type</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
numero de l'arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.cont_num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
1 : brin spherique saillant
                            2 : brin spherique rentrant
                            3 : brin interne a une face torique rentrante
                            4 : brin singulier
                           16 : traitee lors de la recherche des face
                                spheriques saillantes   
</PRE></BLOCKQUOTE>

<P><TT><B>_s0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_s1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_f0()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_f1()</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_triv(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns TRIV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_n(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>_c(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_3_3_">
<H4>4.3.3. class SESF</H4></A>
<PRE>[ created from struct SESF__ ]
</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
Solvent Excluded Surface Face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.s</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ ** ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ ** ]
pointeurs vers les sites   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxtUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
aretes bordant cette face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxttorUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
linked list of deleted SESF (Update Surface)   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nxttUp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
linked list of toric SESF that need to be
                             looked at to find contact faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.dual</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
linked list of SESF that need a new
                            triangulation(Update Surface)   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
pointeur vers l'element dual de SR   
</PRE></BLOCKQUOTE>

<P><TT><B>self.tri</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TRI__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.triv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TRIV__ ** ]
array of triangular faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.buried</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
array of triangulation vertices (internal)   
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_ses_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
ratio of buried_vertices/not_buried vertices   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtri</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtriv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangles   
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of internal triangulation vertices   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
numero d'ordre de la face (debug)   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
nombre d'aretes allouees   
</PRE></BLOCKQUOTE>

<P><TT><B>self.type</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
nombre d'aretes   
</PRE></BLOCKQUOTE>

<P><TT><B>self.pb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
 1 : spherique saillante
                             2 : spherique rentrante
                             3 : torique rentrante
                             4 : full torus 1
                             5 : full torus 2
                             6 : update_rs ==&gt; has to be deleted   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fl</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.cont_nb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
bit 1: set when face needs to have edges
                                   re-ordered
                           
</PRE></BLOCKQUOTE>

<P><TT><B>self.direct</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char * ]
number of cycles forming the edge   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtriv_iso</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
1 quand l'arete est parcourue positivement
                            0 sinon   
</PRE></BLOCKQUOTE>

<P><TT><B>get_a(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns SESE * ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_tri(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns TRI * ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_triv(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns TRIV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_direct(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns int  ]
</PRE></BLOCKQUOTE>

<A name="s4_3_4_">
<H4>4.3.4. class SES</H4></A>
<PRE>[ created from struct SES__ ]
</PRE>
<P><TT><B>self.nxt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SES__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.prv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SES__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.ffa</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
analytical surface description   
</PRE></BLOCKQUOTE>

<P><TT><B>self.lfa</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
pointer to first face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.far</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
pointer to last face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.lar</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
pointer to first arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fso</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ * ]
pointer to last arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.lso</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ * ]
pointer to first sommet   
</PRE></BLOCKQUOTE>

<P><TT><B>self.lsesf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
last ses face kept during update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fsttfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lsttfup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
linked list of faces which need triangulat.   
</PRE></BLOCKQUOTE>

<P><TT><B>self.fsttorup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lsttorup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESF__ * ]
list of toric SESF to look at for finding   
</PRE></BLOCKQUOTE>

<P><TT><B>self.lsese</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESE__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lsesv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SESV__ * ]
last ses edge kept during update   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbf</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nba</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbs</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of aretes   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbss</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of sites   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbse</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of singular sites   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbft</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int * ]
number of singular edges   
</PRE></BLOCKQUOTE>

<P><TT><B>self.num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
used to count the number of contact faces of each
     type (0:contact 1:reentrant 2,3:toric). The number of contact face
     corresponds to the number of vertices in the reduced surface.
     This number can be larger than envred.nbs because of the multiplicity
     index of vertices in SR   
</PRE></BLOCKQUOTE>

<P><TT><B>self.holes_reent</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.holes_cont</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nb_comp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_reent_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
number of components in that SES surface
               this can happen when we have a singular free RS edge   
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_toric_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_contact_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_ses_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_sas_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_ses_volume</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_sas_volume</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_buried_ses_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.a_buried_sas_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.density</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
triangulated surface   
</PRE></BLOCKQUOTE>

<P><TT><B>self.density_sq</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.cercang</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.npcerc</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
angle between 2 dots on a cercle of radius 1.0   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtri1</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of dots on a cercle of radius 1.0   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtri2</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangles in spheric reentrant faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtri3</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangles in toric reentrant faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtri</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangles in contact faces   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtriv</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangles   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbtriv_iso</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of triangulation vertices   
</PRE></BLOCKQUOTE>

<P><TT><B>self.tri_cont</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
nombre de sommets n'appartenant a aucune arete   
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_area_mode</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
remember if contact faces have already
                                    been triangulated   
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_ses_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
MS_NUMERICAL or MS_SEMI_ANALYTICAL   
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_sas_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_buried_ses_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_buried_sas_area</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_ses_volume</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.n_sas_volume</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.genusAna</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.genusTri</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.tmprb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TM__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>_nbft(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<A name="s4_3_5_">
<H4>4.3.5. class SESR</H4></A>
<PRE>[ created from struct SESR__ ]
</PRE>
<P><TT><B>self.fst</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SES__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.lst</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct SES__ * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nb</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<A name="s4_4_">
<H3>4.4. Molecular Surface</H3></A>
<PRE></PRE>
<A name="s4_4_1_">
<H4>4.4.1. class MOLSRF</H4></A>
<PRE>[ created from struct MOLSRF ]
</PRE>
<P><TT><B>self.name</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns char * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rsr</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns RSR * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.sesr</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns SESR * ]
pointer to the root of the RS tree   
</PRE></BLOCKQUOTE>

<P><TT><B>self.data</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns void * ]
pointer to the root of the SES tree   
</PRE></BLOCKQUOTE>

<P><TT><B>self.maxr</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
sphere set stuff   
</PRE></BLOCKQUOTE>

<P><TT><B>self.minr</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.extreme</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbat</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
indices of extreme atoms along x,y and z axis   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nats</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.natc</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.maxat</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.filename</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns char * ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rp</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rp1</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.density</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.tmtab</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns struct TM__ ** ]
triangulation stuff   
</PRE></BLOCKQUOTE>

<P><TT><B>self.dots</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns TDOT * ]
pointers to template spheres   
</PRE></BLOCKQUOTE>

<P><TT><B>self.Maxnbt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
array used to store translated template vertices 
                   during the triangulation of reentrant and contact SESF   
</PRE></BLOCKQUOTE>

<P><TT><B>self.nbt</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of allocated pointers to templates spheres   
</PRE></BLOCKQUOTE>

<P><TT><B>self.MaxDots</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
number of templates spheres   
</PRE></BLOCKQUOTE>

<P><TT><B>self.MaxEdges</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
largest number of vertices on template   
</PRE></BLOCKQUOTE>

<P><TT><B>self.MaxTriangles</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
largest number of edges on template   
</PRE></BLOCKQUOTE>

<P><TT><B>self.allocated_MaxDots</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
largest number of triangles on template   
</PRE></BLOCKQUOTE>

<P><TT><B>self.MinDistSites2</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.all_components</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.free_vert</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.cusp_trim</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.noh</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.dotsOnly</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.cleanup_rs</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
write only .vert file, no triangulation   
</PRE></BLOCKQUOTE>

<P><TT><B>self.cleanup_ses</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.fstup</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
update stuff   
</PRE></BLOCKQUOTE>

<P><TT><B>self.up_num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
first updated RS vertex   
</PRE></BLOCKQUOTE>

<P><TT><B>self.up_mode</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.up_density</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
update_mode   
</PRE></BLOCKQUOTE>

<P><TT><B>self.MS_mfl</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
update_density   
</PRE></BLOCKQUOTE>

<P><TT><B>self.restart_mode</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns unsigned char  ]
MS_PARTIAL (default) or MS_NON_PARTIAL   
</PRE></BLOCKQUOTE>

<P><TT><B>self.mod_dist</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.restart_ana</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
restart modification distance ??? every atom within
                     rest_mod_dist of a modified atom is marked modified   
</PRE></BLOCKQUOTE>

<P><TT><B>self.restart_tri</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
restart computation after analytical SES pb   
</PRE></BLOCKQUOTE>

<P><TT><B>self.rest_on_pbr</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
</PRE></BLOCKQUOTE>

<P><TT><B>self.rest_on_pbc</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
restart after pb while triangulating a reent. face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.max_try</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
restart after pb while triangulating a contact face   
</PRE></BLOCKQUOTE>

<P><TT><B>self.try_num</B></TT>
<BLOCKQUOTE><PRE>[ Member data: returns short  ]
current number of re-tries   
</PRE></BLOCKQUOTE>

<P><TT><B>_extreme(OUT_VECTOR)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>get_atm(i)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns RSV * ]
</PRE></BLOCKQUOTE>

<P><TT><B>MOLSRF(name,coord,nat,maxat,names)</B></TT>
<BLOCKQUOTE><PRE>[ Constructor: returns MOLSRF * ]
</PRE></BLOCKQUOTE>

<P><TT><B>del this</B></TT>
<BLOCKQUOTE><PRE>[ Destructor: returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>findBuriedVertices(su,coord,nat)</B></TT>
<BLOCKQUOTE><PRE>[ Member : returns int  ]
</PRE></BLOCKQUOTE>

<A name="s5_">
<HR><H2>5. Functions</H2></A>
<PRE></PRE>
<P><TT><B>MS_detailed_info_molsrf(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_info_molsrf(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B></B></TT>

<P><TT><B>MS_reset_atom_update_flag(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_get_xyzr_update(ms,file,max)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_updateSpheres(ms,nb,indices,coords)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_addSpheres(ms,nb,coords,names)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_reduced_surface(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
reduced surface   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_update_reduced_surface(ms,rs,nup)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_write_rs_component(ms,rs,name,mode)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
not really useful since I can &quot;walk the pointers&quot; in Python
xtern RS   *MS_find_rs_component_by_num( MOLSRF *ms, int i );
</PRE></BLOCKQUOTE>

<P><TT><B>MS_writeSolventAccessibleatoms(ms,name,mode)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_reset_RSR(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_free_RS_vertices(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_solvent_excluded_surface(ms,rs)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
analytical solvent excluded surface   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_update_ses(ms,rs,nup)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_compute_SES_area(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_update_SES_area(ms,su)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_write_surface_areas(ms,f,cpnum)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
not really useful since I can &quot;walk the pointers&quot; in Python
xtern SES   *MS_find_SES_component_by_num( MOLSRF *ms, int i );
</PRE></BLOCKQUOTE>

<P><TT><B>MS_set_SES_density(ses,density,rp)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_free_SES_comp(su)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_reset_SESR(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_make_templates(ms,s)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
triangulated solvent excluded surface   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_triangulate_SES_component(ms,rs)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_compute_numerical_area_vol(ms,sc,mode)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_update_triangulation_SES_component(ms,rs,mode,density,nup)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_write_triangulated_SES_component(file,ms,s,no_header,mode)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_free_templates(ms)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_free_triangulated_surface(s)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_resetBuriedVertexFlags(su)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
buried surface   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_resetBuriedVertexArea(su)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_vertexBuriedSurfaceArea(su)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
 %apply float ARRAY2D[1][4] { float **atm }   
 #int   MS_findBuriedVertices(MOLSRF *ms,SES *su,float **atm, int nbat);   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_write_coordinates(ms,filename)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
misc   
</PRE></BLOCKQUOTE>

<P><TT><B>MS_restore_radii(ms,rs)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_printInfo(ms,keyString)</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_genus(c,v,e,f)</B></TT>
<BLOCKQUOTE><PRE>[ returns float  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_tagCloseProbes(ms,rs,cut)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_compute_surface(ms,rp,dens)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_update_surface(ms,rs,mode,density,nup)</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
</PRE></BLOCKQUOTE>

<P><TT><B>MS_reset_msms_err()</B></TT>
<BLOCKQUOTE><PRE>[ returns void  ]
</PRE></BLOCKQUOTE>

<P><TT><B></B></TT>


</BODY>
</HTML>
